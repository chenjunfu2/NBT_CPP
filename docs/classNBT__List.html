<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>chenjunfu2-nbt-cpp: NBT_List&lt; List &gt; 模板类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">chenjunfu2-nbt-cpp<span id="projectnumber">&#160;v1.0.2</span>
   </div>
   <div id="projectbrief">一个基于CPP20的NBT(Named Binary Tag)库</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','搜索',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classNBT__List.html','','classNBT__List-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">NBT_List&lt; List &gt; 模板类 参考</div></div>
</div><!--header-->
<div class="contents">

<p>继承自标准库容器的代理类，用于存储和管理NBT列表  
 <a href="#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="NBT__List_8hpp_source.html">NBT_List.hpp</a>&gt;</code></p>
<div class="dynheader">
类 NBT_List&lt; List &gt; 继承关系图:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classNBT__List.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
类</h2></td></tr>
<tr class="memitem:NoCheck_5FT" id="r_NoCheck_5FT"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNBT__List_1_1NoCheck__T.html">NoCheck_T</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">提示性标签，用于取消构造函数对类型符合性的检测，类型检查要求列表中所有元素类型一致  <a href="structNBT__List_1_1NoCheck__T.html#details">更多...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:af6bd87a7f9227b66c1924c6913ae78c4" id="r_af6bd87a7f9227b66c1924c6913ae78c4"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:af6bd87a7f9227b66c1924c6913ae78c4 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6bd87a7f9227b66c1924c6913ae78c4">NBT_List</a> (<a class="el" href="NBT__TAG_8hpp.html#ada3a2766daa185b5461d684c766b4a2e">NBT_TAG</a> _enElementTag, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:af6bd87a7f9227b66c1924c6913ae78c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">构造函数  <br /></td></tr>
<tr class="memitem:a63c724e51ab9db538a22cca06a4a1587" id="r_a63c724e51ab9db538a22cca06a4a1587"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a63c724e51ab9db538a22cca06a4a1587 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63c724e51ab9db538a22cca06a4a1587">NBT_List</a> (<a class="el" href="structNBT__List_1_1NoCheck__T.html">NoCheck_T</a> _NoCheck, <a class="el" href="NBT__TAG_8hpp.html#ada3a2766daa185b5461d684c766b4a2e">NBT_TAG</a> _enElementTag, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a63c724e51ab9db538a22cca06a4a1587"><td class="mdescLeft">&#160;</td><td class="mdescRight">构造函数  <br /></td></tr>
<tr class="memitem:a8d0616bbbefa1d2eb5bb5b0263d17f9c" id="r_a8d0616bbbefa1d2eb5bb5b0263d17f9c"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a8d0616bbbefa1d2eb5bb5b0263d17f9c template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d0616bbbefa1d2eb5bb5b0263d17f9c">NBT_List</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a8d0616bbbefa1d2eb5bb5b0263d17f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">构造函数  <br /></td></tr>
<tr class="memitem:a5cb5b0e0cf576606c80dacb63cb41a33" id="r_a5cb5b0e0cf576606c80dacb63cb41a33"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a5cb5b0e0cf576606c80dacb63cb41a33 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cb5b0e0cf576606c80dacb63cb41a33">NBT_List</a> (<a class="el" href="structNBT__List_1_1NoCheck__T.html">NoCheck_T</a> _NoCheck, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a5cb5b0e0cf576606c80dacb63cb41a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">构造函数  <br /></td></tr>
<tr class="memitem:af75b25a6eaaf9a79d7e18c47ef14f2f3" id="r_af75b25a6eaaf9a79d7e18c47ef14f2f3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af75b25a6eaaf9a79d7e18c47ef14f2f3">NBT_List</a> (<a class="el" href="NBT__TAG_8hpp.html#ada3a2766daa185b5461d684c766b4a2e">NBT_TAG</a> _enElementTag, std::initializer_list&lt; typename List::value_type &gt; init)</td></tr>
<tr class="memdesc:af75b25a6eaaf9a79d7e18c47ef14f2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">初始化列表构造函数  <br /></td></tr>
<tr class="memitem:a0a5f22e336701c18afc8c5916f119085" id="r_a0a5f22e336701c18afc8c5916f119085"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a5f22e336701c18afc8c5916f119085">NBT_List</a> (<a class="el" href="structNBT__List_1_1NoCheck__T.html">NoCheck_T</a> _NoCheck, <a class="el" href="NBT__TAG_8hpp.html#ada3a2766daa185b5461d684c766b4a2e">NBT_TAG</a> _enElementTag, std::initializer_list&lt; typename List::value_type &gt; init)</td></tr>
<tr class="memdesc:a0a5f22e336701c18afc8c5916f119085"><td class="mdescLeft">&#160;</td><td class="mdescRight">初始化列表构造函数  <br /></td></tr>
<tr class="memitem:aa332cbd20b92bdc65800f85dfd0b62fa" id="r_aa332cbd20b92bdc65800f85dfd0b62fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa332cbd20b92bdc65800f85dfd0b62fa">NBT_List</a> (std::initializer_list&lt; typename List::value_type &gt; init)</td></tr>
<tr class="memdesc:aa332cbd20b92bdc65800f85dfd0b62fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">初始化列表构造函数  <br /></td></tr>
<tr class="memitem:ab7fb485a0554f31f31b9fa79867025da" id="r_ab7fb485a0554f31f31b9fa79867025da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7fb485a0554f31f31b9fa79867025da">NBT_List</a> (<a class="el" href="structNBT__List_1_1NoCheck__T.html">NoCheck_T</a> _NoCheck, std::initializer_list&lt; typename List::value_type &gt; init)</td></tr>
<tr class="memdesc:ab7fb485a0554f31f31b9fa79867025da"><td class="mdescLeft">&#160;</td><td class="mdescRight">初始化列表构造函数  <br /></td></tr>
<tr class="memitem:a9a2c712374336f988e5a94d87cb9b342" id="r_a9a2c712374336f988e5a94d87cb9b342"><td class="memItemLeft" align="right" valign="top"><a id="a9a2c712374336f988e5a94d87cb9b342" name="a9a2c712374336f988e5a94d87cb9b342"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NBT_List</b> (void)=default</td></tr>
<tr class="memdesc:a9a2c712374336f988e5a94d87cb9b342"><td class="mdescLeft">&#160;</td><td class="mdescRight">默认构造函数 <br /></td></tr>
<tr class="memitem:a824493f45cf263fb50a067b3942a5ef0" id="r_a824493f45cf263fb50a067b3942a5ef0"><td class="memItemLeft" align="right" valign="top"><a id="a824493f45cf263fb50a067b3942a5ef0" name="a824493f45cf263fb50a067b3942a5ef0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~NBT_List</b> (void)</td></tr>
<tr class="memdesc:a824493f45cf263fb50a067b3942a5ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">析构函数 <br /></td></tr>
<tr class="memitem:a239175779687a0bb0b9cb8159d9da3ce" id="r_a239175779687a0bb0b9cb8159d9da3ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a239175779687a0bb0b9cb8159d9da3ce">NBT_List</a> (<a class="el" href="classNBT__List.html">NBT_List</a> &amp;&amp;_Move) noexcept</td></tr>
<tr class="memdesc:a239175779687a0bb0b9cb8159d9da3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">移动构造函数  <br /></td></tr>
<tr class="memitem:a8f49150a869ceae816f4f7e68b9ca89e" id="r_a8f49150a869ceae816f4f7e68b9ca89e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f49150a869ceae816f4f7e68b9ca89e">NBT_List</a> (const <a class="el" href="classNBT__List.html">NBT_List</a> &amp;_Copy)</td></tr>
<tr class="memdesc:a8f49150a869ceae816f4f7e68b9ca89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">拷贝构造函数  <br /></td></tr>
<tr class="memitem:af3df4c5ad24a803298ea08945f98ecf4" id="r_af3df4c5ad24a803298ea08945f98ecf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__List.html">NBT_List</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3df4c5ad24a803298ea08945f98ecf4">operator=</a> (<a class="el" href="classNBT__List.html">NBT_List</a> &amp;&amp;_Move) noexcept</td></tr>
<tr class="memdesc:af3df4c5ad24a803298ea08945f98ecf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">移动赋值运算符  <br /></td></tr>
<tr class="memitem:ad930fb96a7e2669c7b9b41ec5f273579" id="r_ad930fb96a7e2669c7b9b41ec5f273579"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__List.html">NBT_List</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad930fb96a7e2669c7b9b41ec5f273579">operator=</a> (const <a class="el" href="classNBT__List.html">NBT_List</a> &amp;_Copy)</td></tr>
<tr class="memdesc:ad930fb96a7e2669c7b9b41ec5f273579"><td class="mdescLeft">&#160;</td><td class="mdescRight">拷贝赋值运算符  <br /></td></tr>
<tr class="memitem:a25e00aaf9a73e10ee50015dfb0db9a3d" id="r_a25e00aaf9a73e10ee50015dfb0db9a3d"><td class="memItemLeft" align="right" valign="top">const List &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25e00aaf9a73e10ee50015dfb0db9a3d">GetData</a> (void) const noexcept</td></tr>
<tr class="memdesc:a25e00aaf9a73e10ee50015dfb0db9a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取底层容器数据的常量引用  <br /></td></tr>
<tr class="memitem:a4d0ea5289652b19875b60db4cb2bafe7" id="r_a4d0ea5289652b19875b60db4cb2bafe7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d0ea5289652b19875b60db4cb2bafe7">operator==</a> (const <a class="el" href="classNBT__List.html">NBT_List</a> &amp;_Right) const noexcept</td></tr>
<tr class="memdesc:a4d0ea5289652b19875b60db4cb2bafe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">相等比较运算符  <br /></td></tr>
<tr class="memitem:acf5a296aea4f101b24807d7a351f3474" id="r_acf5a296aea4f101b24807d7a351f3474"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf5a296aea4f101b24807d7a351f3474">operator!=</a> (const <a class="el" href="classNBT__List.html">NBT_List</a> &amp;_Right) const noexcept</td></tr>
<tr class="memdesc:acf5a296aea4f101b24807d7a351f3474"><td class="mdescLeft">&#160;</td><td class="mdescRight">不等比较运算符  <br /></td></tr>
<tr class="memitem:a6a52ad85258d584cbdf392ddf039d177" id="r_a6a52ad85258d584cbdf392ddf039d177"><td class="memItemLeft" align="right" valign="top">std::partial_ordering&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a52ad85258d584cbdf392ddf039d177">operator&lt;=&gt;</a> (const <a class="el" href="classNBT__List.html">NBT_List</a> &amp;_Right) const noexcept</td></tr>
<tr class="memdesc:a6a52ad85258d584cbdf392ddf039d177"><td class="mdescLeft">&#160;</td><td class="mdescRight">三路比较运算符  <br /></td></tr>
<tr class="memitem:a00a65dd7575931753fc8a88b8dff34ad" id="r_a00a65dd7575931753fc8a88b8dff34ad"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a00a65dd7575931753fc8a88b8dff34ad template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, void, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00a65dd7575931753fc8a88b8dff34ad">SetTag</a> (<a class="el" href="NBT__TAG_8hpp.html#ada3a2766daa185b5461d684c766b4a2e">NBT_TAG</a> tagNewValue) noexcept</td></tr>
<tr class="memdesc:a00a65dd7575931753fc8a88b8dff34ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置列表元素类型  <br /></td></tr>
<tr class="memitem:af281716463eaf9a843a8b2ec4932747b" id="r_af281716463eaf9a843a8b2ec4932747b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="NBT__TAG_8hpp.html#ada3a2766daa185b5461d684c766b4a2e">NBT_TAG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af281716463eaf9a843a8b2ec4932747b">GetTag</a> (void) const noexcept</td></tr>
<tr class="memdesc:af281716463eaf9a843a8b2ec4932747b"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表存储的元素类型  <br /></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">查询接口</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>提供一组接口用于对list不同元素的访问</p>
<dl class="section note"><dt>注解</dt><dd>请不要使用这些API修改list内部对象的类型（注意是类型而非值）， 这些接口无法简单的进行封装并检查用户对类型的操作 </dd></dl>
</div></td></tr>
<tr class="memitem:a3501ef3c21061818d95ad6e95d367bb7" id="r_a3501ef3c21061818d95ad6e95d367bb7"><td class="memItemLeft" align="right" valign="top">List::value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3501ef3c21061818d95ad6e95d367bb7">Get</a> (const typename List::size_type &amp;szPos)</td></tr>
<tr class="memdesc:a3501ef3c21061818d95ad6e95d367bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">根据位置获取值  <br /></td></tr>
<tr class="memitem:aeb7ec88c2ad30e87f6a848beaeb7f16d" id="r_aeb7ec88c2ad30e87f6a848beaeb7f16d"><td class="memItemLeft" align="right" valign="top">const List::value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb7ec88c2ad30e87f6a848beaeb7f16d">Get</a> (const typename List::size_type &amp;szPos) const</td></tr>
<tr class="memdesc:aeb7ec88c2ad30e87f6a848beaeb7f16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">根据位置获取值  <br /></td></tr>
<tr class="memitem:aa9374edc7e1d1460f8a3bfbf80534315" id="r_aa9374edc7e1d1460f8a3bfbf80534315"><td class="memItemLeft" align="right" valign="top">List::value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9374edc7e1d1460f8a3bfbf80534315">Front</a> (void) noexcept</td></tr>
<tr class="memdesc:aa9374edc7e1d1460f8a3bfbf80534315"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表开头的元素  <br /></td></tr>
<tr class="memitem:a6bad24d55e5194e978bef573296294ca" id="r_a6bad24d55e5194e978bef573296294ca"><td class="memItemLeft" align="right" valign="top">const List::value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bad24d55e5194e978bef573296294ca">Front</a> (void) const noexcept</td></tr>
<tr class="memdesc:a6bad24d55e5194e978bef573296294ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表开头的元素  <br /></td></tr>
<tr class="memitem:a91cb4f977562650046b99d727c223970" id="r_a91cb4f977562650046b99d727c223970"><td class="memItemLeft" align="right" valign="top">List::value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91cb4f977562650046b99d727c223970">Back</a> (void) noexcept</td></tr>
<tr class="memdesc:a91cb4f977562650046b99d727c223970"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后的元素  <br /></td></tr>
<tr class="memitem:a3a63bc1ee772758f149d9b418fbda13b" id="r_a3a63bc1ee772758f149d9b418fbda13b"><td class="memItemLeft" align="right" valign="top">const List::value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a63bc1ee772758f149d9b418fbda13b">Back</a> (void) const noexcept</td></tr>
<tr class="memdesc:a3a63bc1ee772758f149d9b418fbda13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后的元素  <br /></td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">插入接口</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>提供一组接口用于对list进行元素插入</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">待办事项</a></b></dt><dd>提供范围插入等功能 </dd></dl>
</div></td></tr>
<tr class="memitem:aba7d982ab17670afeebe1d37f9c106bd" id="r_aba7d982ab17670afeebe1d37f9c106bd"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false, typename V&gt; </td></tr>
<tr class="memitem:aba7d982ab17670afeebe1d37f9c106bd template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba7d982ab17670afeebe1d37f9c106bd">Add</a> (size_t szPos, V &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:aba7d982ab17670afeebe1d37f9c106bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置的前面插入元素  <br /></td></tr>
<tr class="memitem:ad8554eee64f0aadec16906e67e1ab2ee" id="r_ad8554eee64f0aadec16906e67e1ab2ee"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false, typename V&gt; </td></tr>
<tr class="memitem:ad8554eee64f0aadec16906e67e1ab2ee template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8554eee64f0aadec16906e67e1ab2ee">AddFront</a> (V &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:ad8554eee64f0aadec16906e67e1ab2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入元素  <br /></td></tr>
<tr class="memitem:af2cd15f196a11789f17c1660c592d5dd" id="r_af2cd15f196a11789f17c1660c592d5dd"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false, typename V&gt; </td></tr>
<tr class="memitem:af2cd15f196a11789f17c1660c592d5dd template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2cd15f196a11789f17c1660c592d5dd">AddBack</a> (V &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:af2cd15f196a11789f17c1660c592d5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入元素  <br /></td></tr>
<tr class="memitem:add90f3046175135ca380d11f12ee4856" id="r_add90f3046175135ca380d11f12ee4856"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false, typename V&gt; </td></tr>
<tr class="memitem:add90f3046175135ca380d11f12ee4856 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add90f3046175135ca380d11f12ee4856">Set</a> (size_t szPos, V &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:add90f3046175135ca380d11f12ee4856"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置（替换）指定位置的元素  <br /></td></tr>
<tr class="memitem:a76a5a5b81b2112475e4cfad466c79520" id="r_a76a5a5b81b2112475e4cfad466c79520"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a76a5a5b81b2112475e4cfad466c79520 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, void, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76a5a5b81b2112475e4cfad466c79520">Remove</a> (size_t szPos)</td></tr>
<tr class="memdesc:a76a5a5b81b2112475e4cfad466c79520"><td class="mdescLeft">&#160;</td><td class="mdescRight">删除指定位置的元素  <br /></td></tr>
<tr class="memitem:a7096884de61f70ec185883f4012f6298" id="r_a7096884de61f70ec185883f4012f6298"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7096884de61f70ec185883f4012f6298">Clear</a> (void)</td></tr>
<tr class="memdesc:a7096884de61f70ec185883f4012f6298"><td class="mdescLeft">&#160;</td><td class="mdescRight">清空所有元素  <br /></td></tr>
<tr class="memitem:a1360a1e15ef94b44711422085cfdf715" id="r_a1360a1e15ef94b44711422085cfdf715"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1360a1e15ef94b44711422085cfdf715">Empty</a> (void) const noexcept</td></tr>
<tr class="memdesc:a1360a1e15ef94b44711422085cfdf715"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查容器是否为空  <br /></td></tr>
<tr class="memitem:a23c3ca65d44c65a8d4d08b70ad07248a" id="r_a23c3ca65d44c65a8d4d08b70ad07248a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23c3ca65d44c65a8d4d08b70ad07248a">Size</a> (void) const noexcept</td></tr>
<tr class="memdesc:a23c3ca65d44c65a8d4d08b70ad07248a"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取容器中元素的数量  <br /></td></tr>
<tr class="memitem:a37e987122627aa6ed7b9f13d7db9da52" id="r_a37e987122627aa6ed7b9f13d7db9da52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37e987122627aa6ed7b9f13d7db9da52">Reserve</a> (size_t szNewCap)</td></tr>
<tr class="memdesc:a37e987122627aa6ed7b9f13d7db9da52"><td class="mdescLeft">&#160;</td><td class="mdescRight">预留存储空间  <br /></td></tr>
<tr class="memitem:a8d7d9cb615745f30b38ee9c3d5d03082" id="r_a8d7d9cb615745f30b38ee9c3d5d03082"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d7d9cb615745f30b38ee9c3d5d03082">Resize</a> (size_t szNewSize)</td></tr>
<tr class="memdesc:a8d7d9cb615745f30b38ee9c3d5d03082"><td class="mdescLeft">&#160;</td><td class="mdescRight">调整容器大小  <br /></td></tr>
<tr class="memitem:a469e207915a47db951d1a497e9a536ea" id="r_a469e207915a47db951d1a497e9a536ea"><td class="memItemLeft" align="right" valign="top"><a id="a469e207915a47db951d1a497e9a536ea" name="a469e207915a47db951d1a497e9a536ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ShrinkToFit</b> (void)</td></tr>
<tr class="memdesc:a469e207915a47db951d1a497e9a536ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">缩减容器容量以匹配大小 <br /></td></tr>
<tr class="memitem:a44139650112584d40a6aba71ec9fe2e7" id="r_a44139650112584d40a6aba71ec9fe2e7"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a44139650112584d40a6aba71ec9fe2e7 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, void, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44139650112584d40a6aba71ec9fe2e7">Merge</a> (const <a class="el" href="classNBT__List.html">NBT_List</a> &amp;_Copy)</td></tr>
<tr class="memdesc:a44139650112584d40a6aba71ec9fe2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">拷贝合并另一个NBT_List的内容  <br /></td></tr>
<tr class="memitem:a059fe5bd8f1b608e3cd95f715c9ed06c" id="r_a059fe5bd8f1b608e3cd95f715c9ed06c"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a059fe5bd8f1b608e3cd95f715c9ed06c template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, void, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a059fe5bd8f1b608e3cd95f715c9ed06c">Merge</a> (<a class="el" href="classNBT__List.html">NBT_List</a> &amp;&amp;_Move)</td></tr>
<tr class="memdesc:a059fe5bd8f1b608e3cd95f715c9ed06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">移动合并另一个NBT_List的内容  <br /></td></tr>
<tr class="memitem:a4043ffc0168fd0d771e13ba13cf5abdf" id="r_a4043ffc0168fd0d771e13ba13cf5abdf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4043ffc0168fd0d771e13ba13cf5abdf">Contains</a> (const typename List::value_type &amp;tValue) const noexcept</td></tr>
<tr class="memdesc:a4043ffc0168fd0d771e13ba13cf5abdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查是否包含指定元素  <br /></td></tr>
<tr class="memitem:ae23aa4a70a9ead0f4ea61bb65f5b9c54" id="r_ae23aa4a70a9ead0f4ea61bb65f5b9c54"><td class="memTemplParams" colspan="2">template&lt;typename Predicate&gt; </td></tr>
<tr class="memitem:ae23aa4a70a9ead0f4ea61bb65f5b9c54 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae23aa4a70a9ead0f4ea61bb65f5b9c54">ContainsIf</a> (Predicate pred) const noexcept</td></tr>
<tr class="memdesc:ae23aa4a70a9ead0f4ea61bb65f5b9c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">使用谓词检查是否存在满足条件的元素  <br /></td></tr>
<tr id="pub-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">针对每种类型提供一个方便使用的函数，由宏批量生成</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>具体作用说明：</p>
<ul>
<li>Get开头+类型名的函数：直接获取指定位置且对应类型的引用，异常由std::vector的at与std::get具体实现决定</li>
<li>Front开头+类型名的函数：获取列表第一个对应类型的元素引用</li>
<li>Back开头+类型名的函数：获取列表最后一个对应类型的元素引用 <dl class="section note"><dt>注解</dt><dd>请不要使用这些API修改list内部对象的类型（注意是类型而非值）， 这些接口无法简单的进行封装并检查用户对类型的操作 </dd></dl>
</li>
</ul>
</div></td></tr>
<tr class="memitem:a786560be056be2304e56157027bd5b9b" id="r_a786560be056be2304e56157027bd5b9b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a786560be056be2304e56157027bd5b9b">GetEnd</a> (const typename List::size_type &amp;szPos) const</td></tr>
<tr class="memdesc:a786560be056be2304e56157027bd5b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定位置的 End 类型数据  <br /></td></tr>
<tr class="memitem:a9233fc78a51841aa441dfb7cb4053b05" id="r_a9233fc78a51841aa441dfb7cb4053b05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9233fc78a51841aa441dfb7cb4053b05">GetEnd</a> (const typename List::size_type &amp;szPos)</td></tr>
<tr class="memdesc:a9233fc78a51841aa441dfb7cb4053b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定位置的 End 类型数据  <br /></td></tr>
<tr class="memitem:a3b2c6ffc6a3a7929cf6d592779e9ab6e" id="r_a3b2c6ffc6a3a7929cf6d592779e9ab6e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b2c6ffc6a3a7929cf6d592779e9ab6e">FrontEnd</a> (void) const</td></tr>
<tr class="memdesc:a3b2c6ffc6a3a7929cf6d592779e9ab6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表第一个 End 类型数据  <br /></td></tr>
<tr class="memitem:a80508b785fb2702300a153e56772e374" id="r_a80508b785fb2702300a153e56772e374"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80508b785fb2702300a153e56772e374">FrontEnd</a> (void)</td></tr>
<tr class="memdesc:a80508b785fb2702300a153e56772e374"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表第一个 End 类型数据  <br /></td></tr>
<tr class="memitem:a738bdbf24c60e1ab72a84d0da6b284a7" id="r_a738bdbf24c60e1ab72a84d0da6b284a7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a738bdbf24c60e1ab72a84d0da6b284a7">BackEnd</a> (void) const</td></tr>
<tr class="memdesc:a738bdbf24c60e1ab72a84d0da6b284a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后一个 End 类型数据  <br /></td></tr>
<tr class="memitem:a1b96bfcfdef5e380c4886f6b18ff4de0" id="r_a1b96bfcfdef5e380c4886f6b18ff4de0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b96bfcfdef5e380c4886f6b18ff4de0">BackEnd</a> (void)</td></tr>
<tr class="memdesc:a1b96bfcfdef5e380c4886f6b18ff4de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后一个 End 类型数据  <br /></td></tr>
<tr class="memitem:a18a22e21bdfd72af85763149cd3dad4c" id="r_a18a22e21bdfd72af85763149cd3dad4c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18a22e21bdfd72af85763149cd3dad4c">GetByte</a> (const typename List::size_type &amp;szPos) const</td></tr>
<tr class="memdesc:a18a22e21bdfd72af85763149cd3dad4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定位置的 Byte 类型数据  <br /></td></tr>
<tr class="memitem:a5612154508f7f97e25f811ac77b2f8f3" id="r_a5612154508f7f97e25f811ac77b2f8f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5612154508f7f97e25f811ac77b2f8f3">GetByte</a> (const typename List::size_type &amp;szPos)</td></tr>
<tr class="memdesc:a5612154508f7f97e25f811ac77b2f8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定位置的 Byte 类型数据  <br /></td></tr>
<tr class="memitem:ab5d0c57d7a9e30dd4fdc008c5a73b9d4" id="r_ab5d0c57d7a9e30dd4fdc008c5a73b9d4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5d0c57d7a9e30dd4fdc008c5a73b9d4">FrontByte</a> (void) const</td></tr>
<tr class="memdesc:ab5d0c57d7a9e30dd4fdc008c5a73b9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表第一个 Byte 类型数据  <br /></td></tr>
<tr class="memitem:a42997c41c8530a37777406a2d1a3b2aa" id="r_a42997c41c8530a37777406a2d1a3b2aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42997c41c8530a37777406a2d1a3b2aa">FrontByte</a> (void)</td></tr>
<tr class="memdesc:a42997c41c8530a37777406a2d1a3b2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表第一个 Byte 类型数据  <br /></td></tr>
<tr class="memitem:adfbb3fd24f2c105bc69e9d241b2773dc" id="r_adfbb3fd24f2c105bc69e9d241b2773dc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfbb3fd24f2c105bc69e9d241b2773dc">BackByte</a> (void) const</td></tr>
<tr class="memdesc:adfbb3fd24f2c105bc69e9d241b2773dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后一个 Byte 类型数据  <br /></td></tr>
<tr class="memitem:aa4741feb1fb63d461b48d4f54ea2d76e" id="r_aa4741feb1fb63d461b48d4f54ea2d76e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4741feb1fb63d461b48d4f54ea2d76e">BackByte</a> (void)</td></tr>
<tr class="memdesc:aa4741feb1fb63d461b48d4f54ea2d76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后一个 Byte 类型数据  <br /></td></tr>
<tr class="memitem:addfe7c457d40de475e6a20fb4b40b779" id="r_addfe7c457d40de475e6a20fb4b40b779"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addfe7c457d40de475e6a20fb4b40b779">GetShort</a> (const typename List::size_type &amp;szPos) const</td></tr>
<tr class="memdesc:addfe7c457d40de475e6a20fb4b40b779"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定位置的 Short 类型数据  <br /></td></tr>
<tr class="memitem:ad6d645db1759d193fd318905a78f90f2" id="r_ad6d645db1759d193fd318905a78f90f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6d645db1759d193fd318905a78f90f2">GetShort</a> (const typename List::size_type &amp;szPos)</td></tr>
<tr class="memdesc:ad6d645db1759d193fd318905a78f90f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定位置的 Short 类型数据  <br /></td></tr>
<tr class="memitem:a2f44a296b497922e210e4330df802444" id="r_a2f44a296b497922e210e4330df802444"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f44a296b497922e210e4330df802444">FrontShort</a> (void) const</td></tr>
<tr class="memdesc:a2f44a296b497922e210e4330df802444"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表第一个 Short 类型数据  <br /></td></tr>
<tr class="memitem:a372700f778f2515d09bf92d386ae0eea" id="r_a372700f778f2515d09bf92d386ae0eea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a372700f778f2515d09bf92d386ae0eea">FrontShort</a> (void)</td></tr>
<tr class="memdesc:a372700f778f2515d09bf92d386ae0eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表第一个 Short 类型数据  <br /></td></tr>
<tr class="memitem:aac36fac7dc70f865f142008a1d2f60ec" id="r_aac36fac7dc70f865f142008a1d2f60ec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac36fac7dc70f865f142008a1d2f60ec">BackShort</a> (void) const</td></tr>
<tr class="memdesc:aac36fac7dc70f865f142008a1d2f60ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后一个 Short 类型数据  <br /></td></tr>
<tr class="memitem:a762e4d37d2cf357de4dbec6cc8cc6d31" id="r_a762e4d37d2cf357de4dbec6cc8cc6d31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a762e4d37d2cf357de4dbec6cc8cc6d31">BackShort</a> (void)</td></tr>
<tr class="memdesc:a762e4d37d2cf357de4dbec6cc8cc6d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后一个 Short 类型数据  <br /></td></tr>
<tr class="memitem:a7361c8851911c9db2fc38a819de77cd8" id="r_a7361c8851911c9db2fc38a819de77cd8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7361c8851911c9db2fc38a819de77cd8">GetInt</a> (const typename List::size_type &amp;szPos) const</td></tr>
<tr class="memdesc:a7361c8851911c9db2fc38a819de77cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定位置的 Int 类型数据  <br /></td></tr>
<tr class="memitem:a6ca48f901e3b389bd5bd0a5b3db90816" id="r_a6ca48f901e3b389bd5bd0a5b3db90816"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ca48f901e3b389bd5bd0a5b3db90816">GetInt</a> (const typename List::size_type &amp;szPos)</td></tr>
<tr class="memdesc:a6ca48f901e3b389bd5bd0a5b3db90816"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定位置的 Int 类型数据  <br /></td></tr>
<tr class="memitem:a7e67e5cd91784e348a57038eb365b1ad" id="r_a7e67e5cd91784e348a57038eb365b1ad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e67e5cd91784e348a57038eb365b1ad">FrontInt</a> (void) const</td></tr>
<tr class="memdesc:a7e67e5cd91784e348a57038eb365b1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表第一个 Int 类型数据  <br /></td></tr>
<tr class="memitem:a3ced3d12eacd744ccee23aa12f85c28d" id="r_a3ced3d12eacd744ccee23aa12f85c28d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ced3d12eacd744ccee23aa12f85c28d">FrontInt</a> (void)</td></tr>
<tr class="memdesc:a3ced3d12eacd744ccee23aa12f85c28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表第一个 Int 类型数据  <br /></td></tr>
<tr class="memitem:a734599a4a05b95cdf4d96b8c72946b22" id="r_a734599a4a05b95cdf4d96b8c72946b22"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a734599a4a05b95cdf4d96b8c72946b22">BackInt</a> (void) const</td></tr>
<tr class="memdesc:a734599a4a05b95cdf4d96b8c72946b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后一个 Int 类型数据  <br /></td></tr>
<tr class="memitem:aaafef9953442e883ce3a898040401018" id="r_aaafef9953442e883ce3a898040401018"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaafef9953442e883ce3a898040401018">BackInt</a> (void)</td></tr>
<tr class="memdesc:aaafef9953442e883ce3a898040401018"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后一个 Int 类型数据  <br /></td></tr>
<tr class="memitem:ae034ae01360e74bd983868ac340eba13" id="r_ae034ae01360e74bd983868ac340eba13"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae034ae01360e74bd983868ac340eba13">GetLong</a> (const typename List::size_type &amp;szPos) const</td></tr>
<tr class="memdesc:ae034ae01360e74bd983868ac340eba13"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定位置的 Long 类型数据  <br /></td></tr>
<tr class="memitem:a2a18666ca33e3a1f495233edf16cfc4b" id="r_a2a18666ca33e3a1f495233edf16cfc4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a18666ca33e3a1f495233edf16cfc4b">GetLong</a> (const typename List::size_type &amp;szPos)</td></tr>
<tr class="memdesc:a2a18666ca33e3a1f495233edf16cfc4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定位置的 Long 类型数据  <br /></td></tr>
<tr class="memitem:a24811a2f88874bfbd6de17bd6f584937" id="r_a24811a2f88874bfbd6de17bd6f584937"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24811a2f88874bfbd6de17bd6f584937">FrontLong</a> (void) const</td></tr>
<tr class="memdesc:a24811a2f88874bfbd6de17bd6f584937"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表第一个 Long 类型数据  <br /></td></tr>
<tr class="memitem:ac68d606bb44101413218c4c2093cbfa1" id="r_ac68d606bb44101413218c4c2093cbfa1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac68d606bb44101413218c4c2093cbfa1">FrontLong</a> (void)</td></tr>
<tr class="memdesc:ac68d606bb44101413218c4c2093cbfa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表第一个 Long 类型数据  <br /></td></tr>
<tr class="memitem:a04f4e190b5da30d35656846b91bf2bfe" id="r_a04f4e190b5da30d35656846b91bf2bfe"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04f4e190b5da30d35656846b91bf2bfe">BackLong</a> (void) const</td></tr>
<tr class="memdesc:a04f4e190b5da30d35656846b91bf2bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后一个 Long 类型数据  <br /></td></tr>
<tr class="memitem:a2ec95f92f2a8bd0410eefe5bdde6d9a8" id="r_a2ec95f92f2a8bd0410eefe5bdde6d9a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ec95f92f2a8bd0410eefe5bdde6d9a8">BackLong</a> (void)</td></tr>
<tr class="memdesc:a2ec95f92f2a8bd0410eefe5bdde6d9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后一个 Long 类型数据  <br /></td></tr>
<tr class="memitem:a2739186fa374e41e5e472c77b2f05e80" id="r_a2739186fa374e41e5e472c77b2f05e80"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2739186fa374e41e5e472c77b2f05e80">GetFloat</a> (const typename List::size_type &amp;szPos) const</td></tr>
<tr class="memdesc:a2739186fa374e41e5e472c77b2f05e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定位置的 Float 类型数据  <br /></td></tr>
<tr class="memitem:a507dbde600395082315d9a8265be9eb7" id="r_a507dbde600395082315d9a8265be9eb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a507dbde600395082315d9a8265be9eb7">GetFloat</a> (const typename List::size_type &amp;szPos)</td></tr>
<tr class="memdesc:a507dbde600395082315d9a8265be9eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定位置的 Float 类型数据  <br /></td></tr>
<tr class="memitem:a78ef7b5ea688936da07a76f8f70f3e95" id="r_a78ef7b5ea688936da07a76f8f70f3e95"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78ef7b5ea688936da07a76f8f70f3e95">FrontFloat</a> (void) const</td></tr>
<tr class="memdesc:a78ef7b5ea688936da07a76f8f70f3e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表第一个 Float 类型数据  <br /></td></tr>
<tr class="memitem:a279536fa8442390f61773802ca9e3c33" id="r_a279536fa8442390f61773802ca9e3c33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a279536fa8442390f61773802ca9e3c33">FrontFloat</a> (void)</td></tr>
<tr class="memdesc:a279536fa8442390f61773802ca9e3c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表第一个 Float 类型数据  <br /></td></tr>
<tr class="memitem:a7bb1ac7dbafa4023dcb32e6ab46f64e4" id="r_a7bb1ac7dbafa4023dcb32e6ab46f64e4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bb1ac7dbafa4023dcb32e6ab46f64e4">BackFloat</a> (void) const</td></tr>
<tr class="memdesc:a7bb1ac7dbafa4023dcb32e6ab46f64e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后一个 Float 类型数据  <br /></td></tr>
<tr class="memitem:a8bbd027166ecd724dbd2001aaeb2218a" id="r_a8bbd027166ecd724dbd2001aaeb2218a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bbd027166ecd724dbd2001aaeb2218a">BackFloat</a> (void)</td></tr>
<tr class="memdesc:a8bbd027166ecd724dbd2001aaeb2218a"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后一个 Float 类型数据  <br /></td></tr>
<tr class="memitem:ab7fb4dba81f97182f262aa7195068a23" id="r_ab7fb4dba81f97182f262aa7195068a23"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7fb4dba81f97182f262aa7195068a23">GetDouble</a> (const typename List::size_type &amp;szPos) const</td></tr>
<tr class="memdesc:ab7fb4dba81f97182f262aa7195068a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定位置的 Double 类型数据  <br /></td></tr>
<tr class="memitem:aea609b3edea68f5e06952ce030e60c31" id="r_aea609b3edea68f5e06952ce030e60c31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea609b3edea68f5e06952ce030e60c31">GetDouble</a> (const typename List::size_type &amp;szPos)</td></tr>
<tr class="memdesc:aea609b3edea68f5e06952ce030e60c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定位置的 Double 类型数据  <br /></td></tr>
<tr class="memitem:a53c4584fbaf427c862a2bd8709797df2" id="r_a53c4584fbaf427c862a2bd8709797df2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53c4584fbaf427c862a2bd8709797df2">FrontDouble</a> (void) const</td></tr>
<tr class="memdesc:a53c4584fbaf427c862a2bd8709797df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表第一个 Double 类型数据  <br /></td></tr>
<tr class="memitem:a10b1c68fb2c9a71a8aa0649110f595ba" id="r_a10b1c68fb2c9a71a8aa0649110f595ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10b1c68fb2c9a71a8aa0649110f595ba">FrontDouble</a> (void)</td></tr>
<tr class="memdesc:a10b1c68fb2c9a71a8aa0649110f595ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表第一个 Double 类型数据  <br /></td></tr>
<tr class="memitem:a6ce2e43b13e77cfe11553adf80e0c679" id="r_a6ce2e43b13e77cfe11553adf80e0c679"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ce2e43b13e77cfe11553adf80e0c679">BackDouble</a> (void) const</td></tr>
<tr class="memdesc:a6ce2e43b13e77cfe11553adf80e0c679"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后一个 Double 类型数据  <br /></td></tr>
<tr class="memitem:ae421ede17891982b0a802ae61a559093" id="r_ae421ede17891982b0a802ae61a559093"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae421ede17891982b0a802ae61a559093">BackDouble</a> (void)</td></tr>
<tr class="memdesc:ae421ede17891982b0a802ae61a559093"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后一个 Double 类型数据  <br /></td></tr>
<tr class="memitem:a054086d23ad47e960d31bb45426b05c3" id="r_a054086d23ad47e960d31bb45426b05c3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a054086d23ad47e960d31bb45426b05c3">GetByteArray</a> (const typename List::size_type &amp;szPos) const</td></tr>
<tr class="memdesc:a054086d23ad47e960d31bb45426b05c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定位置的 ByteArray 类型数据  <br /></td></tr>
<tr class="memitem:ade469517baffb5656d30dd736e7d7680" id="r_ade469517baffb5656d30dd736e7d7680"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade469517baffb5656d30dd736e7d7680">GetByteArray</a> (const typename List::size_type &amp;szPos)</td></tr>
<tr class="memdesc:ade469517baffb5656d30dd736e7d7680"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定位置的 ByteArray 类型数据  <br /></td></tr>
<tr class="memitem:a6c3a0bc37533c7962ab34ae01c696b7d" id="r_a6c3a0bc37533c7962ab34ae01c696b7d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c3a0bc37533c7962ab34ae01c696b7d">FrontByteArray</a> (void) const</td></tr>
<tr class="memdesc:a6c3a0bc37533c7962ab34ae01c696b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表第一个 ByteArray 类型数据  <br /></td></tr>
<tr class="memitem:ae9ae8598dd714f21cb246eff6a3bde23" id="r_ae9ae8598dd714f21cb246eff6a3bde23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9ae8598dd714f21cb246eff6a3bde23">FrontByteArray</a> (void)</td></tr>
<tr class="memdesc:ae9ae8598dd714f21cb246eff6a3bde23"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表第一个 ByteArray 类型数据  <br /></td></tr>
<tr class="memitem:a2f25fbfd543caa08e8285e28f1c63b67" id="r_a2f25fbfd543caa08e8285e28f1c63b67"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f25fbfd543caa08e8285e28f1c63b67">BackByteArray</a> (void) const</td></tr>
<tr class="memdesc:a2f25fbfd543caa08e8285e28f1c63b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后一个 ByteArray 类型数据  <br /></td></tr>
<tr class="memitem:a1d73d014ec6efd2191820e6cb88feef5" id="r_a1d73d014ec6efd2191820e6cb88feef5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d73d014ec6efd2191820e6cb88feef5">BackByteArray</a> (void)</td></tr>
<tr class="memdesc:a1d73d014ec6efd2191820e6cb88feef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后一个 ByteArray 类型数据  <br /></td></tr>
<tr class="memitem:a75b438d38a78a2628bc543a3a5a076c6" id="r_a75b438d38a78a2628bc543a3a5a076c6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75b438d38a78a2628bc543a3a5a076c6">GetIntArray</a> (const typename List::size_type &amp;szPos) const</td></tr>
<tr class="memdesc:a75b438d38a78a2628bc543a3a5a076c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定位置的 IntArray 类型数据  <br /></td></tr>
<tr class="memitem:a2499e845602b75380e1c4dab8d1bf123" id="r_a2499e845602b75380e1c4dab8d1bf123"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2499e845602b75380e1c4dab8d1bf123">GetIntArray</a> (const typename List::size_type &amp;szPos)</td></tr>
<tr class="memdesc:a2499e845602b75380e1c4dab8d1bf123"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定位置的 IntArray 类型数据  <br /></td></tr>
<tr class="memitem:a513f1685f2807c31062248ca20d3bab8" id="r_a513f1685f2807c31062248ca20d3bab8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a513f1685f2807c31062248ca20d3bab8">FrontIntArray</a> (void) const</td></tr>
<tr class="memdesc:a513f1685f2807c31062248ca20d3bab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表第一个 IntArray 类型数据  <br /></td></tr>
<tr class="memitem:ae657d5365d88c1adad6576a3a17e875a" id="r_ae657d5365d88c1adad6576a3a17e875a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae657d5365d88c1adad6576a3a17e875a">FrontIntArray</a> (void)</td></tr>
<tr class="memdesc:ae657d5365d88c1adad6576a3a17e875a"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表第一个 IntArray 类型数据  <br /></td></tr>
<tr class="memitem:a783bf0891343e5fd3fe43bfc19a7c84d" id="r_a783bf0891343e5fd3fe43bfc19a7c84d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a783bf0891343e5fd3fe43bfc19a7c84d">BackIntArray</a> (void) const</td></tr>
<tr class="memdesc:a783bf0891343e5fd3fe43bfc19a7c84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后一个 IntArray 类型数据  <br /></td></tr>
<tr class="memitem:ad79dbba6510361a6af9fef2467b3c8b1" id="r_ad79dbba6510361a6af9fef2467b3c8b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad79dbba6510361a6af9fef2467b3c8b1">BackIntArray</a> (void)</td></tr>
<tr class="memdesc:ad79dbba6510361a6af9fef2467b3c8b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后一个 IntArray 类型数据  <br /></td></tr>
<tr class="memitem:af41afd1296f60af65a371322223302e5" id="r_af41afd1296f60af65a371322223302e5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af41afd1296f60af65a371322223302e5">GetLongArray</a> (const typename List::size_type &amp;szPos) const</td></tr>
<tr class="memdesc:af41afd1296f60af65a371322223302e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定位置的 LongArray 类型数据  <br /></td></tr>
<tr class="memitem:a66425e8dd69f523fbdf29def1c999b8e" id="r_a66425e8dd69f523fbdf29def1c999b8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66425e8dd69f523fbdf29def1c999b8e">GetLongArray</a> (const typename List::size_type &amp;szPos)</td></tr>
<tr class="memdesc:a66425e8dd69f523fbdf29def1c999b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定位置的 LongArray 类型数据  <br /></td></tr>
<tr class="memitem:adcf1a6b30ba3d7c65bc4284ba58494f1" id="r_adcf1a6b30ba3d7c65bc4284ba58494f1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcf1a6b30ba3d7c65bc4284ba58494f1">FrontLongArray</a> (void) const</td></tr>
<tr class="memdesc:adcf1a6b30ba3d7c65bc4284ba58494f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表第一个 LongArray 类型数据  <br /></td></tr>
<tr class="memitem:a639720276cd5188385f5c007cced97b0" id="r_a639720276cd5188385f5c007cced97b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a639720276cd5188385f5c007cced97b0">FrontLongArray</a> (void)</td></tr>
<tr class="memdesc:a639720276cd5188385f5c007cced97b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表第一个 LongArray 类型数据  <br /></td></tr>
<tr class="memitem:ad9ae79518d8d70bbecd81b18e2a11252" id="r_ad9ae79518d8d70bbecd81b18e2a11252"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9ae79518d8d70bbecd81b18e2a11252">BackLongArray</a> (void) const</td></tr>
<tr class="memdesc:ad9ae79518d8d70bbecd81b18e2a11252"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后一个 LongArray 类型数据  <br /></td></tr>
<tr class="memitem:a607f2066a7e198d87044d4f539874da4" id="r_a607f2066a7e198d87044d4f539874da4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a607f2066a7e198d87044d4f539874da4">BackLongArray</a> (void)</td></tr>
<tr class="memdesc:a607f2066a7e198d87044d4f539874da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后一个 LongArray 类型数据  <br /></td></tr>
<tr class="memitem:a5d5d29783e19906cec144c8cd1bdc366" id="r_a5d5d29783e19906cec144c8cd1bdc366"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d5d29783e19906cec144c8cd1bdc366">GetString</a> (const typename List::size_type &amp;szPos) const</td></tr>
<tr class="memdesc:a5d5d29783e19906cec144c8cd1bdc366"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定位置的 String 类型数据  <br /></td></tr>
<tr class="memitem:a344e70687c926836000ce737edcd0026" id="r_a344e70687c926836000ce737edcd0026"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a344e70687c926836000ce737edcd0026">GetString</a> (const typename List::size_type &amp;szPos)</td></tr>
<tr class="memdesc:a344e70687c926836000ce737edcd0026"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定位置的 String 类型数据  <br /></td></tr>
<tr class="memitem:aa88006d80991ab9ec7998f0f2d25eb25" id="r_aa88006d80991ab9ec7998f0f2d25eb25"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa88006d80991ab9ec7998f0f2d25eb25">FrontString</a> (void) const</td></tr>
<tr class="memdesc:aa88006d80991ab9ec7998f0f2d25eb25"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表第一个 String 类型数据  <br /></td></tr>
<tr class="memitem:ada5c71f83095374e718e576a7324048e" id="r_ada5c71f83095374e718e576a7324048e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada5c71f83095374e718e576a7324048e">FrontString</a> (void)</td></tr>
<tr class="memdesc:ada5c71f83095374e718e576a7324048e"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表第一个 String 类型数据  <br /></td></tr>
<tr class="memitem:a7482809de9d8d5e02078230018f450b6" id="r_a7482809de9d8d5e02078230018f450b6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7482809de9d8d5e02078230018f450b6">BackString</a> (void) const</td></tr>
<tr class="memdesc:a7482809de9d8d5e02078230018f450b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后一个 String 类型数据  <br /></td></tr>
<tr class="memitem:affd46b6a866f1e29d5d68cebf96ff392" id="r_affd46b6a866f1e29d5d68cebf96ff392"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affd46b6a866f1e29d5d68cebf96ff392">BackString</a> (void)</td></tr>
<tr class="memdesc:affd46b6a866f1e29d5d68cebf96ff392"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后一个 String 类型数据  <br /></td></tr>
<tr class="memitem:a9d0200e874f1a892e6beb8176c9f51fa" id="r_a9d0200e874f1a892e6beb8176c9f51fa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d0200e874f1a892e6beb8176c9f51fa">GetList</a> (const typename List::size_type &amp;szPos) const</td></tr>
<tr class="memdesc:a9d0200e874f1a892e6beb8176c9f51fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定位置的 List 类型数据  <br /></td></tr>
<tr class="memitem:a8b198553f931211b046d668f542810d1" id="r_a8b198553f931211b046d668f542810d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b198553f931211b046d668f542810d1">GetList</a> (const typename List::size_type &amp;szPos)</td></tr>
<tr class="memdesc:a8b198553f931211b046d668f542810d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定位置的 List 类型数据  <br /></td></tr>
<tr class="memitem:a8ee5eceed2bd5f49541efc91c1c21bf3" id="r_a8ee5eceed2bd5f49541efc91c1c21bf3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ee5eceed2bd5f49541efc91c1c21bf3">FrontList</a> (void) const</td></tr>
<tr class="memdesc:a8ee5eceed2bd5f49541efc91c1c21bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表第一个 List 类型数据  <br /></td></tr>
<tr class="memitem:a601850a5e99fb85915db0f687f813668" id="r_a601850a5e99fb85915db0f687f813668"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a601850a5e99fb85915db0f687f813668">FrontList</a> (void)</td></tr>
<tr class="memdesc:a601850a5e99fb85915db0f687f813668"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表第一个 List 类型数据  <br /></td></tr>
<tr class="memitem:a86108f837132723b207401fbb68ee643" id="r_a86108f837132723b207401fbb68ee643"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86108f837132723b207401fbb68ee643">BackList</a> (void) const</td></tr>
<tr class="memdesc:a86108f837132723b207401fbb68ee643"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后一个 List 类型数据  <br /></td></tr>
<tr class="memitem:afb41e3311127d23ccd5005301609bbdf" id="r_afb41e3311127d23ccd5005301609bbdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb41e3311127d23ccd5005301609bbdf">BackList</a> (void)</td></tr>
<tr class="memdesc:afb41e3311127d23ccd5005301609bbdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后一个 List 类型数据  <br /></td></tr>
<tr class="memitem:a33e2acdb1d5b309a59995f956072a9ce" id="r_a33e2acdb1d5b309a59995f956072a9ce"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33e2acdb1d5b309a59995f956072a9ce">GetCompound</a> (const typename List::size_type &amp;szPos) const</td></tr>
<tr class="memdesc:a33e2acdb1d5b309a59995f956072a9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定位置的 Compound 类型数据  <br /></td></tr>
<tr class="memitem:affbd47cfb0a9f7df632f5df56e1f6204" id="r_affbd47cfb0a9f7df632f5df56e1f6204"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affbd47cfb0a9f7df632f5df56e1f6204">GetCompound</a> (const typename List::size_type &amp;szPos)</td></tr>
<tr class="memdesc:affbd47cfb0a9f7df632f5df56e1f6204"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定位置的 Compound 类型数据  <br /></td></tr>
<tr class="memitem:a025ab42547a78b0493667afc8c86bc73" id="r_a025ab42547a78b0493667afc8c86bc73"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a025ab42547a78b0493667afc8c86bc73">FrontCompound</a> (void) const</td></tr>
<tr class="memdesc:a025ab42547a78b0493667afc8c86bc73"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表第一个 Compound 类型数据  <br /></td></tr>
<tr class="memitem:ae13f10a6eeabb8700de84cd8d3df3b99" id="r_ae13f10a6eeabb8700de84cd8d3df3b99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae13f10a6eeabb8700de84cd8d3df3b99">FrontCompound</a> (void)</td></tr>
<tr class="memdesc:ae13f10a6eeabb8700de84cd8d3df3b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表第一个 Compound 类型数据  <br /></td></tr>
<tr class="memitem:a09068d3a8b8875cd12ccfaa5db82cf88" id="r_a09068d3a8b8875cd12ccfaa5db82cf88"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09068d3a8b8875cd12ccfaa5db82cf88">BackCompound</a> (void) const</td></tr>
<tr class="memdesc:a09068d3a8b8875cd12ccfaa5db82cf88"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后一个 Compound 类型数据  <br /></td></tr>
<tr class="memitem:a9aa75768fee5124f5fb0f92346f3f383" id="r_a9aa75768fee5124f5fb0f92346f3f383"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9aa75768fee5124f5fb0f92346f3f383">BackCompound</a> (void)</td></tr>
<tr class="memdesc:a9aa75768fee5124f5fb0f92346f3f383"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取列表最后一个 Compound 类型数据  <br /></td></tr>
<tr id="pub-methods-3" class="groupHeader"><td colspan="2"><div class="groupHeader">针对每种类型提供插入和设置函数，由宏批量生成</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>具体作用说明：</p>
<ul>
<li>Add开头+类型名的函数：在指定位置插入指定类型的数据</li>
<li>AddFront开头+类型名的函数：在列表末尾插入指定类型的数据</li>
<li>AddBack开头+类型名的函数：在列表末尾插入指定类型的数据</li>
<li>Set开头+类型名的函数：设置指定位置的指定类型数据 </li>
</ul>
</div></td></tr>
<tr class="memitem:a730abf221fdf1a880ce0725cf85d3fc4" id="r_a730abf221fdf1a880ce0725cf85d3fc4"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a730abf221fdf1a880ce0725cf85d3fc4 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a730abf221fdf1a880ce0725cf85d3fc4">AddEnd</a> (size_t szPos, const typename <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a730abf221fdf1a880ce0725cf85d3fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置插入 End 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:ae45d0b0c8d81ee7b8539190fa3f18d70" id="r_ae45d0b0c8d81ee7b8539190fa3f18d70"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:ae45d0b0c8d81ee7b8539190fa3f18d70 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae45d0b0c8d81ee7b8539190fa3f18d70">AddEnd</a> (size_t szPos, typename <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:ae45d0b0c8d81ee7b8539190fa3f18d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置插入 End 类型数据（移动）  <br /></td></tr>
<tr class="memitem:aebea6c67b50c0af1a893fd7ce9f7e1e8" id="r_aebea6c67b50c0af1a893fd7ce9f7e1e8"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:aebea6c67b50c0af1a893fd7ce9f7e1e8 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebea6c67b50c0af1a893fd7ce9f7e1e8">AddFrontEnd</a> (const typename <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:aebea6c67b50c0af1a893fd7ce9f7e1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入 End 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:aa1daa840857d32ad24b2f9dc55766dc9" id="r_aa1daa840857d32ad24b2f9dc55766dc9"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:aa1daa840857d32ad24b2f9dc55766dc9 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1daa840857d32ad24b2f9dc55766dc9">AddFrontEnd</a> (typename <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:aa1daa840857d32ad24b2f9dc55766dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入 End 类型数据（移动）  <br /></td></tr>
<tr class="memitem:af6b875f5662863b0de911e6a66b00712" id="r_af6b875f5662863b0de911e6a66b00712"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:af6b875f5662863b0de911e6a66b00712 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6b875f5662863b0de911e6a66b00712">AddBackEnd</a> (const typename <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:af6b875f5662863b0de911e6a66b00712"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入 End 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:aa9c9f13c63ba7ff58879aedd773772e5" id="r_aa9c9f13c63ba7ff58879aedd773772e5"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:aa9c9f13c63ba7ff58879aedd773772e5 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9c9f13c63ba7ff58879aedd773772e5">AddBackEnd</a> (typename <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:aa9c9f13c63ba7ff58879aedd773772e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入 End 类型数据（移动）  <br /></td></tr>
<tr class="memitem:acd3fcc314939825229d63144c1934028" id="r_acd3fcc314939825229d63144c1934028"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:acd3fcc314939825229d63144c1934028 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd3fcc314939825229d63144c1934028">SetEnd</a> (size_t szPos, const typename <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:acd3fcc314939825229d63144c1934028"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指定位置的 End 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a57109329800542886fd5b1556a6a1bcc" id="r_a57109329800542886fd5b1556a6a1bcc"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a57109329800542886fd5b1556a6a1bcc template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57109329800542886fd5b1556a6a1bcc">SetEnd</a> (size_t szPos, typename <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a57109329800542886fd5b1556a6a1bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指定位置的 End 类型数据（移动）  <br /></td></tr>
<tr class="memitem:aad6a254428ae295846e69736555e4088" id="r_aad6a254428ae295846e69736555e4088"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:aad6a254428ae295846e69736555e4088 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad6a254428ae295846e69736555e4088">AddByte</a> (size_t szPos, const typename <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:aad6a254428ae295846e69736555e4088"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置插入 Byte 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:aaaa2766198b1a61b0d3dd4682478c6e5" id="r_aaaa2766198b1a61b0d3dd4682478c6e5"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:aaaa2766198b1a61b0d3dd4682478c6e5 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaaa2766198b1a61b0d3dd4682478c6e5">AddByte</a> (size_t szPos, typename <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:aaaa2766198b1a61b0d3dd4682478c6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置插入 Byte 类型数据（移动）  <br /></td></tr>
<tr class="memitem:a99185401ccff9c434da8841f5fd1c756" id="r_a99185401ccff9c434da8841f5fd1c756"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a99185401ccff9c434da8841f5fd1c756 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99185401ccff9c434da8841f5fd1c756">AddFrontByte</a> (const typename <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a99185401ccff9c434da8841f5fd1c756"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入 Byte 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a8fdec2871bb9e230ba7ed1b531cf1924" id="r_a8fdec2871bb9e230ba7ed1b531cf1924"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a8fdec2871bb9e230ba7ed1b531cf1924 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fdec2871bb9e230ba7ed1b531cf1924">AddFrontByte</a> (typename <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a8fdec2871bb9e230ba7ed1b531cf1924"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入 Byte 类型数据（移动）  <br /></td></tr>
<tr class="memitem:abcde763caf1ece013cd4193b2f8dc8b0" id="r_abcde763caf1ece013cd4193b2f8dc8b0"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:abcde763caf1ece013cd4193b2f8dc8b0 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcde763caf1ece013cd4193b2f8dc8b0">AddBackByte</a> (const typename <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:abcde763caf1ece013cd4193b2f8dc8b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入 Byte 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a190c2f25b481703ea0e10ada1e7d234f" id="r_a190c2f25b481703ea0e10ada1e7d234f"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a190c2f25b481703ea0e10ada1e7d234f template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a190c2f25b481703ea0e10ada1e7d234f">AddBackByte</a> (typename <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a190c2f25b481703ea0e10ada1e7d234f"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入 Byte 类型数据（移动）  <br /></td></tr>
<tr class="memitem:a3cc82fba3592f11d3f296563408616a3" id="r_a3cc82fba3592f11d3f296563408616a3"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a3cc82fba3592f11d3f296563408616a3 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cc82fba3592f11d3f296563408616a3">SetByte</a> (size_t szPos, const typename <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a3cc82fba3592f11d3f296563408616a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指定位置的 Byte 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:ac6f247856e667d0630ccb89d9798a9d4" id="r_ac6f247856e667d0630ccb89d9798a9d4"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:ac6f247856e667d0630ccb89d9798a9d4 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6f247856e667d0630ccb89d9798a9d4">SetByte</a> (size_t szPos, typename <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:ac6f247856e667d0630ccb89d9798a9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指定位置的 Byte 类型数据（移动）  <br /></td></tr>
<tr class="memitem:ad2019f2c3b9f99fcfefe82ce4634563c" id="r_ad2019f2c3b9f99fcfefe82ce4634563c"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:ad2019f2c3b9f99fcfefe82ce4634563c template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2019f2c3b9f99fcfefe82ce4634563c">AddShort</a> (size_t szPos, const typename <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:ad2019f2c3b9f99fcfefe82ce4634563c"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置插入 Short 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:af22104927321d29d082fcf5f6e060049" id="r_af22104927321d29d082fcf5f6e060049"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:af22104927321d29d082fcf5f6e060049 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af22104927321d29d082fcf5f6e060049">AddShort</a> (size_t szPos, typename <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:af22104927321d29d082fcf5f6e060049"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置插入 Short 类型数据（移动）  <br /></td></tr>
<tr class="memitem:ad576e7aa0fb373058790fddf341fb036" id="r_ad576e7aa0fb373058790fddf341fb036"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:ad576e7aa0fb373058790fddf341fb036 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad576e7aa0fb373058790fddf341fb036">AddFrontShort</a> (const typename <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:ad576e7aa0fb373058790fddf341fb036"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入 Short 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:adf9c09a2a93d88cb37ddd685a839a623" id="r_adf9c09a2a93d88cb37ddd685a839a623"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:adf9c09a2a93d88cb37ddd685a839a623 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf9c09a2a93d88cb37ddd685a839a623">AddFrontShort</a> (typename <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:adf9c09a2a93d88cb37ddd685a839a623"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入 Short 类型数据（移动）  <br /></td></tr>
<tr class="memitem:a5ebc31a41875556dda82020c2690bc31" id="r_a5ebc31a41875556dda82020c2690bc31"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a5ebc31a41875556dda82020c2690bc31 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ebc31a41875556dda82020c2690bc31">AddBackShort</a> (const typename <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a5ebc31a41875556dda82020c2690bc31"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入 Short 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a27b6b528bc3a09717a8f28d794326137" id="r_a27b6b528bc3a09717a8f28d794326137"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a27b6b528bc3a09717a8f28d794326137 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27b6b528bc3a09717a8f28d794326137">AddBackShort</a> (typename <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a27b6b528bc3a09717a8f28d794326137"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入 Short 类型数据（移动）  <br /></td></tr>
<tr class="memitem:ab168d3ecc4365e69d977ec2918ef9c24" id="r_ab168d3ecc4365e69d977ec2918ef9c24"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:ab168d3ecc4365e69d977ec2918ef9c24 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab168d3ecc4365e69d977ec2918ef9c24">SetShort</a> (size_t szPos, const typename <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:ab168d3ecc4365e69d977ec2918ef9c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指定位置的 Short 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a4d93cacb64cc5deca37966986307eb2a" id="r_a4d93cacb64cc5deca37966986307eb2a"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a4d93cacb64cc5deca37966986307eb2a template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d93cacb64cc5deca37966986307eb2a">SetShort</a> (size_t szPos, typename <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a4d93cacb64cc5deca37966986307eb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指定位置的 Short 类型数据（移动）  <br /></td></tr>
<tr class="memitem:ae7373d98040308c69326a8672df9ec8b" id="r_ae7373d98040308c69326a8672df9ec8b"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:ae7373d98040308c69326a8672df9ec8b template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7373d98040308c69326a8672df9ec8b">AddInt</a> (size_t szPos, const typename <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:ae7373d98040308c69326a8672df9ec8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置插入 Int 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a5d786087774ef1c03835d9be8a0b59d3" id="r_a5d786087774ef1c03835d9be8a0b59d3"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a5d786087774ef1c03835d9be8a0b59d3 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d786087774ef1c03835d9be8a0b59d3">AddInt</a> (size_t szPos, typename <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a5d786087774ef1c03835d9be8a0b59d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置插入 Int 类型数据（移动）  <br /></td></tr>
<tr class="memitem:a8388bc89bb80bcad3d91a02743f0daf4" id="r_a8388bc89bb80bcad3d91a02743f0daf4"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a8388bc89bb80bcad3d91a02743f0daf4 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8388bc89bb80bcad3d91a02743f0daf4">AddFrontInt</a> (const typename <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a8388bc89bb80bcad3d91a02743f0daf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入 Int 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a70bd82293e2d465a71b4a03ef0c0fbd5" id="r_a70bd82293e2d465a71b4a03ef0c0fbd5"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a70bd82293e2d465a71b4a03ef0c0fbd5 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70bd82293e2d465a71b4a03ef0c0fbd5">AddFrontInt</a> (typename <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a70bd82293e2d465a71b4a03ef0c0fbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入 Int 类型数据（移动）  <br /></td></tr>
<tr class="memitem:ac46d564e8cac04dba1fb8005d15e297a" id="r_ac46d564e8cac04dba1fb8005d15e297a"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:ac46d564e8cac04dba1fb8005d15e297a template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac46d564e8cac04dba1fb8005d15e297a">AddBackInt</a> (const typename <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:ac46d564e8cac04dba1fb8005d15e297a"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入 Int 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:aa5a0cd9949603167d8bed8b619ef85f4" id="r_aa5a0cd9949603167d8bed8b619ef85f4"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:aa5a0cd9949603167d8bed8b619ef85f4 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5a0cd9949603167d8bed8b619ef85f4">AddBackInt</a> (typename <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:aa5a0cd9949603167d8bed8b619ef85f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入 Int 类型数据（移动）  <br /></td></tr>
<tr class="memitem:ae8e240f6f3586e09fd86ad0ddffd6cae" id="r_ae8e240f6f3586e09fd86ad0ddffd6cae"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:ae8e240f6f3586e09fd86ad0ddffd6cae template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8e240f6f3586e09fd86ad0ddffd6cae">SetInt</a> (size_t szPos, const typename <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:ae8e240f6f3586e09fd86ad0ddffd6cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指定位置的 Int 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a6c87c9055165bbecaddd98f5d466d6d9" id="r_a6c87c9055165bbecaddd98f5d466d6d9"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a6c87c9055165bbecaddd98f5d466d6d9 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c87c9055165bbecaddd98f5d466d6d9">SetInt</a> (size_t szPos, typename <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a6c87c9055165bbecaddd98f5d466d6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指定位置的 Int 类型数据（移动）  <br /></td></tr>
<tr class="memitem:a0ec2512410d447603e9613a190b95822" id="r_a0ec2512410d447603e9613a190b95822"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a0ec2512410d447603e9613a190b95822 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ec2512410d447603e9613a190b95822">AddLong</a> (size_t szPos, const typename <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a0ec2512410d447603e9613a190b95822"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置插入 Long 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a30269b398a932d3ab64e938cef72561f" id="r_a30269b398a932d3ab64e938cef72561f"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a30269b398a932d3ab64e938cef72561f template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30269b398a932d3ab64e938cef72561f">AddLong</a> (size_t szPos, typename <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a30269b398a932d3ab64e938cef72561f"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置插入 Long 类型数据（移动）  <br /></td></tr>
<tr class="memitem:aaa1274e21fe96bc8817c2c40c1f8d897" id="r_aaa1274e21fe96bc8817c2c40c1f8d897"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:aaa1274e21fe96bc8817c2c40c1f8d897 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa1274e21fe96bc8817c2c40c1f8d897">AddFrontLong</a> (const typename <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:aaa1274e21fe96bc8817c2c40c1f8d897"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入 Long 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:ac55f01d4c13e073e8345318c4d6d4ea8" id="r_ac55f01d4c13e073e8345318c4d6d4ea8"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:ac55f01d4c13e073e8345318c4d6d4ea8 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac55f01d4c13e073e8345318c4d6d4ea8">AddFrontLong</a> (typename <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:ac55f01d4c13e073e8345318c4d6d4ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入 Long 类型数据（移动）  <br /></td></tr>
<tr class="memitem:a2c439d7bea4fc13eca0cf15a83904802" id="r_a2c439d7bea4fc13eca0cf15a83904802"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a2c439d7bea4fc13eca0cf15a83904802 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c439d7bea4fc13eca0cf15a83904802">AddBackLong</a> (const typename <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a2c439d7bea4fc13eca0cf15a83904802"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入 Long 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a5df556c7894d684932170718a91afa5a" id="r_a5df556c7894d684932170718a91afa5a"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a5df556c7894d684932170718a91afa5a template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5df556c7894d684932170718a91afa5a">AddBackLong</a> (typename <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a5df556c7894d684932170718a91afa5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入 Long 类型数据（移动）  <br /></td></tr>
<tr class="memitem:ab2277215397ddd4fbeadd68498822b28" id="r_ab2277215397ddd4fbeadd68498822b28"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:ab2277215397ddd4fbeadd68498822b28 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2277215397ddd4fbeadd68498822b28">SetLong</a> (size_t szPos, const typename <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:ab2277215397ddd4fbeadd68498822b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指定位置的 Long 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:af712e0c608cc4d11769555a6c9080f3d" id="r_af712e0c608cc4d11769555a6c9080f3d"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:af712e0c608cc4d11769555a6c9080f3d template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af712e0c608cc4d11769555a6c9080f3d">SetLong</a> (size_t szPos, typename <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:af712e0c608cc4d11769555a6c9080f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指定位置的 Long 类型数据（移动）  <br /></td></tr>
<tr class="memitem:afdf3b02f937faae72e765cdc716dbe9a" id="r_afdf3b02f937faae72e765cdc716dbe9a"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:afdf3b02f937faae72e765cdc716dbe9a template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdf3b02f937faae72e765cdc716dbe9a">AddFloat</a> (size_t szPos, const typename <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:afdf3b02f937faae72e765cdc716dbe9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置插入 Float 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a513c4665da324b2392ac4899c71f6b32" id="r_a513c4665da324b2392ac4899c71f6b32"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a513c4665da324b2392ac4899c71f6b32 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a513c4665da324b2392ac4899c71f6b32">AddFloat</a> (size_t szPos, typename <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a513c4665da324b2392ac4899c71f6b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置插入 Float 类型数据（移动）  <br /></td></tr>
<tr class="memitem:a16712e50ffd34b4fdab297d82b021da1" id="r_a16712e50ffd34b4fdab297d82b021da1"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a16712e50ffd34b4fdab297d82b021da1 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16712e50ffd34b4fdab297d82b021da1">AddFrontFloat</a> (const typename <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a16712e50ffd34b4fdab297d82b021da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入 Float 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a8b697273d483c624bfa7f04cec6cca9b" id="r_a8b697273d483c624bfa7f04cec6cca9b"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a8b697273d483c624bfa7f04cec6cca9b template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b697273d483c624bfa7f04cec6cca9b">AddFrontFloat</a> (typename <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a8b697273d483c624bfa7f04cec6cca9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入 Float 类型数据（移动）  <br /></td></tr>
<tr class="memitem:a725b90c186e6fa616e07fd0e634737b3" id="r_a725b90c186e6fa616e07fd0e634737b3"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a725b90c186e6fa616e07fd0e634737b3 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a725b90c186e6fa616e07fd0e634737b3">AddBackFloat</a> (const typename <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a725b90c186e6fa616e07fd0e634737b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入 Float 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a3eb3f4abeea4e1e8ffdb0fe6c15e70b8" id="r_a3eb3f4abeea4e1e8ffdb0fe6c15e70b8"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a3eb3f4abeea4e1e8ffdb0fe6c15e70b8 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3eb3f4abeea4e1e8ffdb0fe6c15e70b8">AddBackFloat</a> (typename <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a3eb3f4abeea4e1e8ffdb0fe6c15e70b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入 Float 类型数据（移动）  <br /></td></tr>
<tr class="memitem:a6e7f836107cdded5fbaba486c96dd03f" id="r_a6e7f836107cdded5fbaba486c96dd03f"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a6e7f836107cdded5fbaba486c96dd03f template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e7f836107cdded5fbaba486c96dd03f">SetFloat</a> (size_t szPos, const typename <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a6e7f836107cdded5fbaba486c96dd03f"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指定位置的 Float 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:ab4d5fad51938e951929cd52c82e0bf65" id="r_ab4d5fad51938e951929cd52c82e0bf65"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:ab4d5fad51938e951929cd52c82e0bf65 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4d5fad51938e951929cd52c82e0bf65">SetFloat</a> (size_t szPos, typename <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:ab4d5fad51938e951929cd52c82e0bf65"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指定位置的 Float 类型数据（移动）  <br /></td></tr>
<tr class="memitem:a889d1cd3a48d6588310fae2e7578afcb" id="r_a889d1cd3a48d6588310fae2e7578afcb"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a889d1cd3a48d6588310fae2e7578afcb template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a889d1cd3a48d6588310fae2e7578afcb">AddDouble</a> (size_t szPos, const typename <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a889d1cd3a48d6588310fae2e7578afcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置插入 Double 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a48980d31466133f9a5874a622f3b6f37" id="r_a48980d31466133f9a5874a622f3b6f37"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a48980d31466133f9a5874a622f3b6f37 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48980d31466133f9a5874a622f3b6f37">AddDouble</a> (size_t szPos, typename <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a48980d31466133f9a5874a622f3b6f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置插入 Double 类型数据（移动）  <br /></td></tr>
<tr class="memitem:aa77865f7b93585ba89a0d84516279967" id="r_aa77865f7b93585ba89a0d84516279967"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:aa77865f7b93585ba89a0d84516279967 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa77865f7b93585ba89a0d84516279967">AddFrontDouble</a> (const typename <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:aa77865f7b93585ba89a0d84516279967"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入 Double 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a26620df77fb6fb93f5504ed310b1b62a" id="r_a26620df77fb6fb93f5504ed310b1b62a"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a26620df77fb6fb93f5504ed310b1b62a template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26620df77fb6fb93f5504ed310b1b62a">AddFrontDouble</a> (typename <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a26620df77fb6fb93f5504ed310b1b62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入 Double 类型数据（移动）  <br /></td></tr>
<tr class="memitem:ad1245cef733f65ee93d9e0c6c22bf397" id="r_ad1245cef733f65ee93d9e0c6c22bf397"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:ad1245cef733f65ee93d9e0c6c22bf397 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1245cef733f65ee93d9e0c6c22bf397">AddBackDouble</a> (const typename <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:ad1245cef733f65ee93d9e0c6c22bf397"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入 Double 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:af5aa72e60a2dd9d5e69125723d9aff7f" id="r_af5aa72e60a2dd9d5e69125723d9aff7f"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:af5aa72e60a2dd9d5e69125723d9aff7f template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5aa72e60a2dd9d5e69125723d9aff7f">AddBackDouble</a> (typename <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:af5aa72e60a2dd9d5e69125723d9aff7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入 Double 类型数据（移动）  <br /></td></tr>
<tr class="memitem:af2d5e39af0e10caa4b2bce489c3bfe2d" id="r_af2d5e39af0e10caa4b2bce489c3bfe2d"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:af2d5e39af0e10caa4b2bce489c3bfe2d template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2d5e39af0e10caa4b2bce489c3bfe2d">SetDouble</a> (size_t szPos, const typename <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:af2d5e39af0e10caa4b2bce489c3bfe2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指定位置的 Double 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a666ce9abb18f06fe01be72ccb6dbda67" id="r_a666ce9abb18f06fe01be72ccb6dbda67"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a666ce9abb18f06fe01be72ccb6dbda67 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a666ce9abb18f06fe01be72ccb6dbda67">SetDouble</a> (size_t szPos, typename <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a666ce9abb18f06fe01be72ccb6dbda67"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指定位置的 Double 类型数据（移动）  <br /></td></tr>
<tr class="memitem:ae2c49fda1d949d6edebd95d819e2dc55" id="r_ae2c49fda1d949d6edebd95d819e2dc55"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:ae2c49fda1d949d6edebd95d819e2dc55 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2c49fda1d949d6edebd95d819e2dc55">AddByteArray</a> (size_t szPos, const typename <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:ae2c49fda1d949d6edebd95d819e2dc55"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置插入 ByteArray 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a008e1c27cf09102a42808e62fba9fdbf" id="r_a008e1c27cf09102a42808e62fba9fdbf"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a008e1c27cf09102a42808e62fba9fdbf template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a008e1c27cf09102a42808e62fba9fdbf">AddByteArray</a> (size_t szPos, typename <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a008e1c27cf09102a42808e62fba9fdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置插入 ByteArray 类型数据（移动）  <br /></td></tr>
<tr class="memitem:add7134c3868d78303a4cfb1b2f90da4e" id="r_add7134c3868d78303a4cfb1b2f90da4e"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:add7134c3868d78303a4cfb1b2f90da4e template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add7134c3868d78303a4cfb1b2f90da4e">AddFrontByteArray</a> (const typename <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:add7134c3868d78303a4cfb1b2f90da4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入 ByteArray 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a16281e45c397853ae7d23ed00ab145a8" id="r_a16281e45c397853ae7d23ed00ab145a8"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a16281e45c397853ae7d23ed00ab145a8 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16281e45c397853ae7d23ed00ab145a8">AddFrontByteArray</a> (typename <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a16281e45c397853ae7d23ed00ab145a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入 ByteArray 类型数据（移动）  <br /></td></tr>
<tr class="memitem:a76e677cdf773090cb8b1f1c66d5b37b8" id="r_a76e677cdf773090cb8b1f1c66d5b37b8"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a76e677cdf773090cb8b1f1c66d5b37b8 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76e677cdf773090cb8b1f1c66d5b37b8">AddBackByteArray</a> (const typename <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a76e677cdf773090cb8b1f1c66d5b37b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入 ByteArray 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a81f088c3778c731b96bcd36e836cb295" id="r_a81f088c3778c731b96bcd36e836cb295"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a81f088c3778c731b96bcd36e836cb295 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81f088c3778c731b96bcd36e836cb295">AddBackByteArray</a> (typename <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a81f088c3778c731b96bcd36e836cb295"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入 ByteArray 类型数据（移动）  <br /></td></tr>
<tr class="memitem:abaefeea7158bbc10c00afd377ad2cf8d" id="r_abaefeea7158bbc10c00afd377ad2cf8d"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:abaefeea7158bbc10c00afd377ad2cf8d template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abaefeea7158bbc10c00afd377ad2cf8d">SetByteArray</a> (size_t szPos, const typename <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:abaefeea7158bbc10c00afd377ad2cf8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指定位置的 ByteArray 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:aca8e94ea2f5acfd2aba2339a66310279" id="r_aca8e94ea2f5acfd2aba2339a66310279"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:aca8e94ea2f5acfd2aba2339a66310279 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca8e94ea2f5acfd2aba2339a66310279">SetByteArray</a> (size_t szPos, typename <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:aca8e94ea2f5acfd2aba2339a66310279"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指定位置的 ByteArray 类型数据（移动）  <br /></td></tr>
<tr class="memitem:ab2ba3178b74df8c0f526d4b235e589bb" id="r_ab2ba3178b74df8c0f526d4b235e589bb"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:ab2ba3178b74df8c0f526d4b235e589bb template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2ba3178b74df8c0f526d4b235e589bb">AddIntArray</a> (size_t szPos, const typename <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:ab2ba3178b74df8c0f526d4b235e589bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置插入 IntArray 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a433152c97b29de197e5e78b498359f22" id="r_a433152c97b29de197e5e78b498359f22"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a433152c97b29de197e5e78b498359f22 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a433152c97b29de197e5e78b498359f22">AddIntArray</a> (size_t szPos, typename <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a433152c97b29de197e5e78b498359f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置插入 IntArray 类型数据（移动）  <br /></td></tr>
<tr class="memitem:a1057b95f4373e41e6513d72901ef6a9f" id="r_a1057b95f4373e41e6513d72901ef6a9f"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a1057b95f4373e41e6513d72901ef6a9f template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1057b95f4373e41e6513d72901ef6a9f">AddFrontIntArray</a> (const typename <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a1057b95f4373e41e6513d72901ef6a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入 IntArray 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:ab2ac42024aeb9a42e9564748f631b4bb" id="r_ab2ac42024aeb9a42e9564748f631b4bb"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:ab2ac42024aeb9a42e9564748f631b4bb template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2ac42024aeb9a42e9564748f631b4bb">AddFrontIntArray</a> (typename <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:ab2ac42024aeb9a42e9564748f631b4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入 IntArray 类型数据（移动）  <br /></td></tr>
<tr class="memitem:a679a5a4457f55388aaa9fe613028e3d4" id="r_a679a5a4457f55388aaa9fe613028e3d4"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a679a5a4457f55388aaa9fe613028e3d4 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a679a5a4457f55388aaa9fe613028e3d4">AddBackIntArray</a> (const typename <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a679a5a4457f55388aaa9fe613028e3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入 IntArray 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:aca8b74d65facbf4fadf7e3ff96b8ff9b" id="r_aca8b74d65facbf4fadf7e3ff96b8ff9b"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:aca8b74d65facbf4fadf7e3ff96b8ff9b template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca8b74d65facbf4fadf7e3ff96b8ff9b">AddBackIntArray</a> (typename <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:aca8b74d65facbf4fadf7e3ff96b8ff9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入 IntArray 类型数据（移动）  <br /></td></tr>
<tr class="memitem:a769d281e2ae37d4cbf4b760648a1fd41" id="r_a769d281e2ae37d4cbf4b760648a1fd41"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a769d281e2ae37d4cbf4b760648a1fd41 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a769d281e2ae37d4cbf4b760648a1fd41">SetIntArray</a> (size_t szPos, const typename <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a769d281e2ae37d4cbf4b760648a1fd41"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指定位置的 IntArray 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a21b8a08405ed5e5f996f810349062d27" id="r_a21b8a08405ed5e5f996f810349062d27"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a21b8a08405ed5e5f996f810349062d27 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21b8a08405ed5e5f996f810349062d27">SetIntArray</a> (size_t szPos, typename <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a21b8a08405ed5e5f996f810349062d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指定位置的 IntArray 类型数据（移动）  <br /></td></tr>
<tr class="memitem:a2730b73a7171385814ccf3d7e6b3ac27" id="r_a2730b73a7171385814ccf3d7e6b3ac27"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a2730b73a7171385814ccf3d7e6b3ac27 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2730b73a7171385814ccf3d7e6b3ac27">AddLongArray</a> (size_t szPos, const typename <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a2730b73a7171385814ccf3d7e6b3ac27"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置插入 LongArray 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:ac1b1bd1345afe3b0a5c010e012e86303" id="r_ac1b1bd1345afe3b0a5c010e012e86303"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:ac1b1bd1345afe3b0a5c010e012e86303 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1b1bd1345afe3b0a5c010e012e86303">AddLongArray</a> (size_t szPos, typename <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:ac1b1bd1345afe3b0a5c010e012e86303"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置插入 LongArray 类型数据（移动）  <br /></td></tr>
<tr class="memitem:a2726475a3dfec27ef2c27d44825c1592" id="r_a2726475a3dfec27ef2c27d44825c1592"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a2726475a3dfec27ef2c27d44825c1592 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2726475a3dfec27ef2c27d44825c1592">AddFrontLongArray</a> (const typename <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a2726475a3dfec27ef2c27d44825c1592"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入 LongArray 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:aca7b2002c540e479bd9dd4446030798d" id="r_aca7b2002c540e479bd9dd4446030798d"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:aca7b2002c540e479bd9dd4446030798d template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca7b2002c540e479bd9dd4446030798d">AddFrontLongArray</a> (typename <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:aca7b2002c540e479bd9dd4446030798d"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入 LongArray 类型数据（移动）  <br /></td></tr>
<tr class="memitem:ab386ac3785e69dcd154ff45f2409f8d1" id="r_ab386ac3785e69dcd154ff45f2409f8d1"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:ab386ac3785e69dcd154ff45f2409f8d1 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab386ac3785e69dcd154ff45f2409f8d1">AddBackLongArray</a> (const typename <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:ab386ac3785e69dcd154ff45f2409f8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入 LongArray 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:afe82a338eed6de16b150e48131306cfc" id="r_afe82a338eed6de16b150e48131306cfc"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:afe82a338eed6de16b150e48131306cfc template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe82a338eed6de16b150e48131306cfc">AddBackLongArray</a> (typename <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:afe82a338eed6de16b150e48131306cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入 LongArray 类型数据（移动）  <br /></td></tr>
<tr class="memitem:ac00114875cb9e475f8115f86c0ce1e6e" id="r_ac00114875cb9e475f8115f86c0ce1e6e"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:ac00114875cb9e475f8115f86c0ce1e6e template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac00114875cb9e475f8115f86c0ce1e6e">SetLongArray</a> (size_t szPos, const typename <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:ac00114875cb9e475f8115f86c0ce1e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指定位置的 LongArray 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a01866555ed433df3e6f2ba0fbc11cce1" id="r_a01866555ed433df3e6f2ba0fbc11cce1"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a01866555ed433df3e6f2ba0fbc11cce1 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01866555ed433df3e6f2ba0fbc11cce1">SetLongArray</a> (size_t szPos, typename <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a01866555ed433df3e6f2ba0fbc11cce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指定位置的 LongArray 类型数据（移动）  <br /></td></tr>
<tr class="memitem:a91de8e9c37e47379d8e574b34f5791c6" id="r_a91de8e9c37e47379d8e574b34f5791c6"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a91de8e9c37e47379d8e574b34f5791c6 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91de8e9c37e47379d8e574b34f5791c6">AddString</a> (size_t szPos, const typename <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a91de8e9c37e47379d8e574b34f5791c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置插入 String 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a2848abd925d8eef2408617ae186a51ef" id="r_a2848abd925d8eef2408617ae186a51ef"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a2848abd925d8eef2408617ae186a51ef template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2848abd925d8eef2408617ae186a51ef">AddString</a> (size_t szPos, typename <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a2848abd925d8eef2408617ae186a51ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置插入 String 类型数据（移动）  <br /></td></tr>
<tr class="memitem:a94812566be41a9865de994c296763a3f" id="r_a94812566be41a9865de994c296763a3f"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a94812566be41a9865de994c296763a3f template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94812566be41a9865de994c296763a3f">AddFrontString</a> (const typename <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a94812566be41a9865de994c296763a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入 String 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a3e8f6be8206b1a19a0d8938064919353" id="r_a3e8f6be8206b1a19a0d8938064919353"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a3e8f6be8206b1a19a0d8938064919353 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e8f6be8206b1a19a0d8938064919353">AddFrontString</a> (typename <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a3e8f6be8206b1a19a0d8938064919353"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入 String 类型数据（移动）  <br /></td></tr>
<tr class="memitem:a45b963430c0e304daec8d7d390cd07cc" id="r_a45b963430c0e304daec8d7d390cd07cc"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a45b963430c0e304daec8d7d390cd07cc template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45b963430c0e304daec8d7d390cd07cc">AddBackString</a> (const typename <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a45b963430c0e304daec8d7d390cd07cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入 String 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a4bfe05015d3cd694a8f7004e05739885" id="r_a4bfe05015d3cd694a8f7004e05739885"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a4bfe05015d3cd694a8f7004e05739885 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bfe05015d3cd694a8f7004e05739885">AddBackString</a> (typename <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a4bfe05015d3cd694a8f7004e05739885"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入 String 类型数据（移动）  <br /></td></tr>
<tr class="memitem:a1e0413a1dfbd45c6eb9a1e9ac495a970" id="r_a1e0413a1dfbd45c6eb9a1e9ac495a970"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a1e0413a1dfbd45c6eb9a1e9ac495a970 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e0413a1dfbd45c6eb9a1e9ac495a970">SetString</a> (size_t szPos, const typename <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a1e0413a1dfbd45c6eb9a1e9ac495a970"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指定位置的 String 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a0e47127c0714c1154d1eed9eb7f2e5aa" id="r_a0e47127c0714c1154d1eed9eb7f2e5aa"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a0e47127c0714c1154d1eed9eb7f2e5aa template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e47127c0714c1154d1eed9eb7f2e5aa">SetString</a> (size_t szPos, typename <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a0e47127c0714c1154d1eed9eb7f2e5aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指定位置的 String 类型数据（移动）  <br /></td></tr>
<tr class="memitem:a419438a888488815a737e849841335d0" id="r_a419438a888488815a737e849841335d0"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a419438a888488815a737e849841335d0 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a419438a888488815a737e849841335d0">AddList</a> (size_t szPos, const typename <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a419438a888488815a737e849841335d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置插入 List 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:abc0738f3ed1db9b0098a6c6e711b7ba1" id="r_abc0738f3ed1db9b0098a6c6e711b7ba1"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:abc0738f3ed1db9b0098a6c6e711b7ba1 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc0738f3ed1db9b0098a6c6e711b7ba1">AddList</a> (size_t szPos, typename <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:abc0738f3ed1db9b0098a6c6e711b7ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置插入 List 类型数据（移动）  <br /></td></tr>
<tr class="memitem:a286582ccd239379f88df82d05b4f4e99" id="r_a286582ccd239379f88df82d05b4f4e99"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a286582ccd239379f88df82d05b4f4e99 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a286582ccd239379f88df82d05b4f4e99">AddFrontList</a> (const typename <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a286582ccd239379f88df82d05b4f4e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入 List 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a4d796ee72470bf5c58bfd1d6e801eae7" id="r_a4d796ee72470bf5c58bfd1d6e801eae7"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a4d796ee72470bf5c58bfd1d6e801eae7 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d796ee72470bf5c58bfd1d6e801eae7">AddFrontList</a> (typename <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a4d796ee72470bf5c58bfd1d6e801eae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入 List 类型数据（移动）  <br /></td></tr>
<tr class="memitem:a79538f1b60b1340372961b3e4638dbe5" id="r_a79538f1b60b1340372961b3e4638dbe5"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a79538f1b60b1340372961b3e4638dbe5 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79538f1b60b1340372961b3e4638dbe5">AddBackList</a> (const typename <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a79538f1b60b1340372961b3e4638dbe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入 List 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:aec94ace9018e753d9ec5c9ff2c0d5301" id="r_aec94ace9018e753d9ec5c9ff2c0d5301"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:aec94ace9018e753d9ec5c9ff2c0d5301 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec94ace9018e753d9ec5c9ff2c0d5301">AddBackList</a> (typename <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:aec94ace9018e753d9ec5c9ff2c0d5301"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入 List 类型数据（移动）  <br /></td></tr>
<tr class="memitem:a8e932f410741dc22428a3bdd7553d722" id="r_a8e932f410741dc22428a3bdd7553d722"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a8e932f410741dc22428a3bdd7553d722 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e932f410741dc22428a3bdd7553d722">SetList</a> (size_t szPos, const typename <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a8e932f410741dc22428a3bdd7553d722"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指定位置的 List 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a6965c342e1485f3985b848153ed97d98" id="r_a6965c342e1485f3985b848153ed97d98"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a6965c342e1485f3985b848153ed97d98 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6965c342e1485f3985b848153ed97d98">SetList</a> (size_t szPos, typename <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a6965c342e1485f3985b848153ed97d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指定位置的 List 类型数据（移动）  <br /></td></tr>
<tr class="memitem:af65b31d1dbb3caf3a78dce6a508bcbc8" id="r_af65b31d1dbb3caf3a78dce6a508bcbc8"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:af65b31d1dbb3caf3a78dce6a508bcbc8 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af65b31d1dbb3caf3a78dce6a508bcbc8">AddCompound</a> (size_t szPos, const typename <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:af65b31d1dbb3caf3a78dce6a508bcbc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置插入 Compound 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a759de28b1aadede39edaa85708c29de7" id="r_a759de28b1aadede39edaa85708c29de7"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a759de28b1aadede39edaa85708c29de7 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a759de28b1aadede39edaa85708c29de7">AddCompound</a> (size_t szPos, typename <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a759de28b1aadede39edaa85708c29de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">在指定位置插入 Compound 类型数据（移动）  <br /></td></tr>
<tr class="memitem:a2df73d202bcb02a744996471660ac985" id="r_a2df73d202bcb02a744996471660ac985"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a2df73d202bcb02a744996471660ac985 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2df73d202bcb02a744996471660ac985">AddFrontCompound</a> (const typename <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a2df73d202bcb02a744996471660ac985"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入 Compound 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:abbdce0869d99cb120642f4b117923c6a" id="r_abbdce0869d99cb120642f4b117923c6a"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:abbdce0869d99cb120642f4b117923c6a template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbdce0869d99cb120642f4b117923c6a">AddFrontCompound</a> (typename <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:abbdce0869d99cb120642f4b117923c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表头部插入 Compound 类型数据（移动）  <br /></td></tr>
<tr class="memitem:ae8cb58fd9a5b03b5f35c09dc2c6aac05" id="r_ae8cb58fd9a5b03b5f35c09dc2c6aac05"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:ae8cb58fd9a5b03b5f35c09dc2c6aac05 template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8cb58fd9a5b03b5f35c09dc2c6aac05">AddBackCompound</a> (const typename <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:ae8cb58fd9a5b03b5f35c09dc2c6aac05"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入 Compound 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:a21c1d808a4600160d4afeeee3f65491a" id="r_a21c1d808a4600160d4afeeee3f65491a"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a21c1d808a4600160d4afeeee3f65491a template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21c1d808a4600160d4afeeee3f65491a">AddBackCompound</a> (typename <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a21c1d808a4600160d4afeeee3f65491a"><td class="mdescLeft">&#160;</td><td class="mdescRight">在列表末尾插入 Compound 类型数据（移动）  <br /></td></tr>
<tr class="memitem:a69488d281d9c0c6001e98960281444ec" id="r_a69488d281d9c0c6001e98960281444ec"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:a69488d281d9c0c6001e98960281444ec template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69488d281d9c0c6001e98960281444ec">SetCompound</a> (size_t szPos, const typename <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a69488d281d9c0c6001e98960281444ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指定位置的 Compound 类型数据（拷贝）  <br /></td></tr>
<tr class="memitem:adc8a2c9c8faf9a7c1a02bff399999aab" id="r_adc8a2c9c8faf9a7c1a02bff399999aab"><td class="memTemplParams" colspan="2">template&lt;bool bNoCheck = false&gt; </td></tr>
<tr class="memitem:adc8a2c9c8faf9a7c1a02bff399999aab template"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc8a2c9c8faf9a7c1a02bff399999aab">SetCompound</a> (size_t szPos, typename <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:adc8a2c9c8faf9a7c1a02bff399999aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指定位置的 Compound 类型数据（移动）  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
静态 Public 属性</h2></td></tr>
<tr class="memitem:a1df3a5d108843ddc77468ab6876b1fd2" id="r_a1df3a5d108843ddc77468ab6876b1fd2"><td class="memItemLeft" align="right" valign="top">static constexpr const <a class="el" href="structNBT__List_1_1NoCheck__T.html">NoCheck_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1df3a5d108843ddc77468ab6876b1fd2">NoCheck</a> {}</td></tr>
<tr class="memdesc:a1df3a5d108843ddc77468ab6876b1fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">提示性标签，用于取消构造函数对类型符合性的检测，类型检查要求列表中所有元素类型一致     <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-friends" class="groupheader"><a id="friends" name="friends"></a>
友元</h2></td></tr>
<tr class="memitem:a7bc260970fa83d84a5f90ce08fb18bad" id="r_a7bc260970fa83d84a5f90ce08fb18bad"><td class="memItemLeft" align="right" valign="top"><a id="a7bc260970fa83d84a5f90ce08fb18bad" name="a7bc260970fa83d84a5f90ce08fb18bad"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>NBT_Reader</b></td></tr>
<tr class="memitem:a228bee3eab89fadd3a563856e2983ec7" id="r_a228bee3eab89fadd3a563856e2983ec7"><td class="memItemLeft" align="right" valign="top"><a id="a228bee3eab89fadd3a563856e2983ec7" name="a228bee3eab89fadd3a563856e2983ec7"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>NBT_Writer</b></td></tr>
<tr class="memitem:a01c82892359b4eea5e23efb59810eb29" id="r_a01c82892359b4eea5e23efb59810eb29"><td class="memItemLeft" align="right" valign="top"><a id="a01c82892359b4eea5e23efb59810eb29" name="a01c82892359b4eea5e23efb59810eb29"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>NBT_Helper</b></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">详细描述</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename List&gt;<br />
class NBT_List&lt; List &gt;</div><p>继承自标准库容器的代理类，用于存储和管理NBT列表 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>继承的父类，也就是std::vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>用户不应自行实例化此类，请使用NBT_Type::List来访问此类实例化类型 </dd></dl>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">构造及析构函数说明</h2>
<a id="af6bd87a7f9227b66c1924c6913ae78c4" name="af6bd87a7f9227b66c1924c6913ae78c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6bd87a7f9227b66c1924c6913ae78c4">&#9670;&#160;</a></span>NBT_List() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::NBT_List </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="NBT__TAG_8hpp.html#ada3a2766daa185b5461d684c766b4a2e">NBT_TAG</a></td>          <td class="paramname"><span class="paramname"><em>_enElementTag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>构造函数 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>变长构造参数类型包 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_enElementTag</td><td>列表元素类型标签 </td></tr>
    <tr><td class="paramname">args</td><td>变长构造参数列表 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>列表元素类型设置为_enElementTag代表的类型，并进行类型检查， 如果构造的类型不匹配，则抛出std::invalid_argument异常 </dd></dl>

</div>
</div>
<a id="a63c724e51ab9db538a22cca06a4a1587" name="a63c724e51ab9db538a22cca06a4a1587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c724e51ab9db538a22cca06a4a1587">&#9670;&#160;</a></span>NBT_List() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::NBT_List </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNBT__List_1_1NoCheck__T.html">NoCheck_T</a></td>          <td class="paramname"><span class="paramname"><em>_NoCheck</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="NBT__TAG_8hpp.html#ada3a2766daa185b5461d684c766b4a2e">NBT_TAG</a></td>          <td class="paramname"><span class="paramname"><em>_enElementTag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>构造函数 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>变长构造参数类型包 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_NoCheck</td><td>取消检查标记 </td></tr>
    <tr><td class="paramname">_enElementTag</td><td>列表元素类型标签 </td></tr>
    <tr><td class="paramname">args</td><td>变长构造参数列表 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>不进行类型检查 </dd></dl>

</div>
</div>
<a id="a8d0616bbbefa1d2eb5bb5b0263d17f9c" name="a8d0616bbbefa1d2eb5bb5b0263d17f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0616bbbefa1d2eb5bb5b0263d17f9c">&#9670;&#160;</a></span>NBT_List() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::NBT_List </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>构造函数 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>变长构造参数类型包 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>变长构造参数列表 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>根据第一个元素的类型作为列表元素类型，并进行类型检查， 如果构造的类型不匹配，则抛出std::invalid_argument异常 </dd></dl>

</div>
</div>
<a id="a5cb5b0e0cf576606c80dacb63cb41a33" name="a5cb5b0e0cf576606c80dacb63cb41a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb5b0e0cf576606c80dacb63cb41a33">&#9670;&#160;</a></span>NBT_List() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::NBT_List </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNBT__List_1_1NoCheck__T.html">NoCheck_T</a></td>          <td class="paramname"><span class="paramname"><em>_NoCheck</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>构造函数 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>变长构造参数类型包 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_NoCheck</td><td>取消检查标记 </td></tr>
    <tr><td class="paramname">args</td><td>变长构造参数列表 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>不进行类型检查 </dd></dl>

</div>
</div>
<a id="af75b25a6eaaf9a79d7e18c47ef14f2f3" name="af75b25a6eaaf9a79d7e18c47ef14f2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af75b25a6eaaf9a79d7e18c47ef14f2f3">&#9670;&#160;</a></span>NBT_List() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::NBT_List </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="NBT__TAG_8hpp.html#ada3a2766daa185b5461d684c766b4a2e">NBT_TAG</a></td>          <td class="paramname"><span class="paramname"><em>_enElementTag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; typename List::value_type &gt;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>初始化列表构造函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_enElementTag</td><td>列表元素类型标签 </td></tr>
    <tr><td class="paramname">init</td><td>初始化列表 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>列表元素类型设置为_enElementTag代表的类型，并对进行类型检查， 如果构造的任一类型不匹配，则抛出std::invalid_argument异常 </dd></dl>

</div>
</div>
<a id="a0a5f22e336701c18afc8c5916f119085" name="a0a5f22e336701c18afc8c5916f119085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5f22e336701c18afc8c5916f119085">&#9670;&#160;</a></span>NBT_List() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::NBT_List </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNBT__List_1_1NoCheck__T.html">NoCheck_T</a></td>          <td class="paramname"><span class="paramname"><em>_NoCheck</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="NBT__TAG_8hpp.html#ada3a2766daa185b5461d684c766b4a2e">NBT_TAG</a></td>          <td class="paramname"><span class="paramname"><em>_enElementTag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; typename List::value_type &gt;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>初始化列表构造函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_NoCheck</td><td>取消检查标记 </td></tr>
    <tr><td class="paramname">_enElementTag</td><td>列表元素类型标签 </td></tr>
    <tr><td class="paramname">init</td><td>初始化列表 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>不进行类型检查 </dd></dl>

</div>
</div>
<a id="aa332cbd20b92bdc65800f85dfd0b62fa" name="aa332cbd20b92bdc65800f85dfd0b62fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa332cbd20b92bdc65800f85dfd0b62fa">&#9670;&#160;</a></span>NBT_List() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::NBT_List </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; typename List::value_type &gt;</td>          <td class="paramname"><span class="paramname"><em>init</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>初始化列表构造函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>初始化列表 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>根据第一个元素的类型作为列表元素类型，并进行类型检查， 如果构造的类型不匹配，则抛出std::invalid_argument异常 </dd></dl>

</div>
</div>
<a id="ab7fb485a0554f31f31b9fa79867025da" name="ab7fb485a0554f31f31b9fa79867025da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7fb485a0554f31f31b9fa79867025da">&#9670;&#160;</a></span>NBT_List() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::NBT_List </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNBT__List_1_1NoCheck__T.html">NoCheck_T</a></td>          <td class="paramname"><span class="paramname"><em>_NoCheck</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; typename List::value_type &gt;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>初始化列表构造函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_NoCheck</td><td>取消检查标记 </td></tr>
    <tr><td class="paramname">init</td><td>初始化列表 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>不进行类型检查 </dd></dl>

</div>
</div>
<a id="a239175779687a0bb0b9cb8159d9da3ce" name="a239175779687a0bb0b9cb8159d9da3ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239175779687a0bb0b9cb8159d9da3ce">&#9670;&#160;</a></span>NBT_List() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::NBT_List </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>_Move</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>移动构造函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Move</td><td>要移动的源对象 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f49150a869ceae816f4f7e68b9ca89e" name="a8f49150a869ceae816f4f7e68b9ca89e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f49150a869ceae816f4f7e68b9ca89e">&#9670;&#160;</a></span>NBT_List() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::NBT_List </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_Copy</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>拷贝构造函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Copy</td><td>要拷贝的源对象 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">成员函数说明</h2>
<a id="aba7d982ab17670afeebe1d37f9c106bd" name="aba7d982ab17670afeebe1d37f9c106bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba7d982ab17670afeebe1d37f9c106bd">&#9670;&#160;</a></span>Add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::Add </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置的前面插入元素 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同 </td></tr>
    <tr><td class="paramname">V</td><td>元素值类型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置 </td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含插入元素所在位置的迭代器和是否操作成功的bool值的pair，否则仅返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>在bNoCheck为false的情况下，当且仅当插入的类型与当前列表存储的类型一致，同时szPos在合法范围内，函数成功，否则失败， 如果bNoCheck为true则必然成功，所以函数仅返回迭代器 </dd>
<dd>
在bNoCheck为false的情况下，如果当前列表标签为空，则列表存储的类型自动变为当前元素类型， 如果bNoCheck为true，则列表不会设置当前元素类型，请使用SetTag来变更元素类型或放弃维护元素类型 </dd></dl>

</div>
</div>
<a id="af2cd15f196a11789f17c1660c592d5dd" name="af2cd15f196a11789f17c1660c592d5dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2cd15f196a11789f17c1660c592d5dd">&#9670;&#160;</a></span>AddBack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBack </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入元素 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同 </td></tr>
    <tr><td class="paramname">V</td><td>元素值类型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含插入元素所在位置的迭代器和是否操作成功的bool值的pair，否则仅返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>在bNoCheck为false的情况下，当且仅当插入的类型与当前列表存储的类型一致，同时szPos在合法范围内，函数成功，否则失败， 如果bNoCheck为true则必然成功，所以函数仅返回迭代器 </dd>
<dd>
在bNoCheck为false的情况下，如果当前列表标签为空，则列表存储的类型自动变为当前元素类型， 如果bNoCheck为true，则列表不会设置当前元素类型，请使用SetTag来变更元素类型或放弃维护元素类型 </dd></dl>

</div>
</div>
<a id="abcde763caf1ece013cd4193b2f8dc8b0" name="abcde763caf1ece013cd4193b2f8dc8b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcde763caf1ece013cd4193b2f8dc8b0">&#9670;&#160;</a></span>AddBackByte() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBackByte </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入 Byte 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Byte 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddBack的代理，具体行为参考AddBack函数的说明 </dd></dl>

</div>
</div>
<a id="a190c2f25b481703ea0e10ada1e7d234f" name="a190c2f25b481703ea0e10ada1e7d234f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a190c2f25b481703ea0e10ada1e7d234f">&#9670;&#160;</a></span>AddBackByte() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBackByte </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入 Byte 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Byte 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddBack的代理，具体行为参考AddBack函数的说明 </dd></dl>

</div>
</div>
<a id="a76e677cdf773090cb8b1f1c66d5b37b8" name="a76e677cdf773090cb8b1f1c66d5b37b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e677cdf773090cb8b1f1c66d5b37b8">&#9670;&#160;</a></span>AddBackByteArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBackByteArray </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入 ByteArray 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 ByteArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddBack的代理，具体行为参考AddBack函数的说明 </dd></dl>

</div>
</div>
<a id="a81f088c3778c731b96bcd36e836cb295" name="a81f088c3778c731b96bcd36e836cb295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f088c3778c731b96bcd36e836cb295">&#9670;&#160;</a></span>AddBackByteArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBackByteArray </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入 ByteArray 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 ByteArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddBack的代理，具体行为参考AddBack函数的说明 </dd></dl>

</div>
</div>
<a id="ae8cb58fd9a5b03b5f35c09dc2c6aac05" name="ae8cb58fd9a5b03b5f35c09dc2c6aac05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8cb58fd9a5b03b5f35c09dc2c6aac05">&#9670;&#160;</a></span>AddBackCompound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBackCompound </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入 Compound 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Compound 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddBack的代理，具体行为参考AddBack函数的说明 </dd></dl>

</div>
</div>
<a id="a21c1d808a4600160d4afeeee3f65491a" name="a21c1d808a4600160d4afeeee3f65491a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c1d808a4600160d4afeeee3f65491a">&#9670;&#160;</a></span>AddBackCompound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBackCompound </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入 Compound 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Compound 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddBack的代理，具体行为参考AddBack函数的说明 </dd></dl>

</div>
</div>
<a id="ad1245cef733f65ee93d9e0c6c22bf397" name="ad1245cef733f65ee93d9e0c6c22bf397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1245cef733f65ee93d9e0c6c22bf397">&#9670;&#160;</a></span>AddBackDouble() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBackDouble </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入 Double 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Double 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddBack的代理，具体行为参考AddBack函数的说明 </dd></dl>

</div>
</div>
<a id="af5aa72e60a2dd9d5e69125723d9aff7f" name="af5aa72e60a2dd9d5e69125723d9aff7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5aa72e60a2dd9d5e69125723d9aff7f">&#9670;&#160;</a></span>AddBackDouble() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBackDouble </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入 Double 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Double 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddBack的代理，具体行为参考AddBack函数的说明 </dd></dl>

</div>
</div>
<a id="af6b875f5662863b0de911e6a66b00712" name="af6b875f5662863b0de911e6a66b00712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b875f5662863b0de911e6a66b00712">&#9670;&#160;</a></span>AddBackEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBackEnd </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入 End 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 End 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddBack的代理，具体行为参考AddBack函数的说明 </dd></dl>

</div>
</div>
<a id="aa9c9f13c63ba7ff58879aedd773772e5" name="aa9c9f13c63ba7ff58879aedd773772e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c9f13c63ba7ff58879aedd773772e5">&#9670;&#160;</a></span>AddBackEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBackEnd </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入 End 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 End 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddBack的代理，具体行为参考AddBack函数的说明 </dd></dl>

</div>
</div>
<a id="a725b90c186e6fa616e07fd0e634737b3" name="a725b90c186e6fa616e07fd0e634737b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725b90c186e6fa616e07fd0e634737b3">&#9670;&#160;</a></span>AddBackFloat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBackFloat </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入 Float 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Float 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddBack的代理，具体行为参考AddBack函数的说明 </dd></dl>

</div>
</div>
<a id="a3eb3f4abeea4e1e8ffdb0fe6c15e70b8" name="a3eb3f4abeea4e1e8ffdb0fe6c15e70b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb3f4abeea4e1e8ffdb0fe6c15e70b8">&#9670;&#160;</a></span>AddBackFloat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBackFloat </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入 Float 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Float 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddBack的代理，具体行为参考AddBack函数的说明 </dd></dl>

</div>
</div>
<a id="ac46d564e8cac04dba1fb8005d15e297a" name="ac46d564e8cac04dba1fb8005d15e297a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac46d564e8cac04dba1fb8005d15e297a">&#9670;&#160;</a></span>AddBackInt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBackInt </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入 Int 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Int 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddBack的代理，具体行为参考AddBack函数的说明 </dd></dl>

</div>
</div>
<a id="aa5a0cd9949603167d8bed8b619ef85f4" name="aa5a0cd9949603167d8bed8b619ef85f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a0cd9949603167d8bed8b619ef85f4">&#9670;&#160;</a></span>AddBackInt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBackInt </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入 Int 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Int 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddBack的代理，具体行为参考AddBack函数的说明 </dd></dl>

</div>
</div>
<a id="a679a5a4457f55388aaa9fe613028e3d4" name="a679a5a4457f55388aaa9fe613028e3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679a5a4457f55388aaa9fe613028e3d4">&#9670;&#160;</a></span>AddBackIntArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBackIntArray </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入 IntArray 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 IntArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddBack的代理，具体行为参考AddBack函数的说明 </dd></dl>

</div>
</div>
<a id="aca8b74d65facbf4fadf7e3ff96b8ff9b" name="aca8b74d65facbf4fadf7e3ff96b8ff9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8b74d65facbf4fadf7e3ff96b8ff9b">&#9670;&#160;</a></span>AddBackIntArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBackIntArray </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入 IntArray 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 IntArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddBack的代理，具体行为参考AddBack函数的说明 </dd></dl>

</div>
</div>
<a id="a79538f1b60b1340372961b3e4638dbe5" name="a79538f1b60b1340372961b3e4638dbe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79538f1b60b1340372961b3e4638dbe5">&#9670;&#160;</a></span>AddBackList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBackList </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入 List 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 List 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddBack的代理，具体行为参考AddBack函数的说明 </dd></dl>

</div>
</div>
<a id="aec94ace9018e753d9ec5c9ff2c0d5301" name="aec94ace9018e753d9ec5c9ff2c0d5301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec94ace9018e753d9ec5c9ff2c0d5301">&#9670;&#160;</a></span>AddBackList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBackList </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入 List 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 List 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddBack的代理，具体行为参考AddBack函数的说明 </dd></dl>

</div>
</div>
<a id="a2c439d7bea4fc13eca0cf15a83904802" name="a2c439d7bea4fc13eca0cf15a83904802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c439d7bea4fc13eca0cf15a83904802">&#9670;&#160;</a></span>AddBackLong() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBackLong </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入 Long 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Long 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddBack的代理，具体行为参考AddBack函数的说明 </dd></dl>

</div>
</div>
<a id="a5df556c7894d684932170718a91afa5a" name="a5df556c7894d684932170718a91afa5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df556c7894d684932170718a91afa5a">&#9670;&#160;</a></span>AddBackLong() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBackLong </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入 Long 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Long 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddBack的代理，具体行为参考AddBack函数的说明 </dd></dl>

</div>
</div>
<a id="ab386ac3785e69dcd154ff45f2409f8d1" name="ab386ac3785e69dcd154ff45f2409f8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab386ac3785e69dcd154ff45f2409f8d1">&#9670;&#160;</a></span>AddBackLongArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBackLongArray </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入 LongArray 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 LongArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddBack的代理，具体行为参考AddBack函数的说明 </dd></dl>

</div>
</div>
<a id="afe82a338eed6de16b150e48131306cfc" name="afe82a338eed6de16b150e48131306cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe82a338eed6de16b150e48131306cfc">&#9670;&#160;</a></span>AddBackLongArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBackLongArray </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入 LongArray 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 LongArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddBack的代理，具体行为参考AddBack函数的说明 </dd></dl>

</div>
</div>
<a id="a5ebc31a41875556dda82020c2690bc31" name="a5ebc31a41875556dda82020c2690bc31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ebc31a41875556dda82020c2690bc31">&#9670;&#160;</a></span>AddBackShort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBackShort </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入 Short 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Short 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddBack的代理，具体行为参考AddBack函数的说明 </dd></dl>

</div>
</div>
<a id="a27b6b528bc3a09717a8f28d794326137" name="a27b6b528bc3a09717a8f28d794326137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b6b528bc3a09717a8f28d794326137">&#9670;&#160;</a></span>AddBackShort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBackShort </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入 Short 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Short 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddBack的代理，具体行为参考AddBack函数的说明 </dd></dl>

</div>
</div>
<a id="a45b963430c0e304daec8d7d390cd07cc" name="a45b963430c0e304daec8d7d390cd07cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b963430c0e304daec8d7d390cd07cc">&#9670;&#160;</a></span>AddBackString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBackString </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入 String 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 String 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddBack的代理，具体行为参考AddBack函数的说明 </dd></dl>

</div>
</div>
<a id="a4bfe05015d3cd694a8f7004e05739885" name="a4bfe05015d3cd694a8f7004e05739885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfe05015d3cd694a8f7004e05739885">&#9670;&#160;</a></span>AddBackString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddBackString </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表末尾插入 String 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 String 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddBack的代理，具体行为参考AddBack函数的说明 </dd></dl>

</div>
</div>
<a id="aad6a254428ae295846e69736555e4088" name="aad6a254428ae295846e69736555e4088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6a254428ae295846e69736555e4088">&#9670;&#160;</a></span>AddByte() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddByte </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置插入 Byte 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Byte 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Add的代理，具体行为参考Add函数的说明 </dd></dl>

</div>
</div>
<a id="aaaa2766198b1a61b0d3dd4682478c6e5" name="aaaa2766198b1a61b0d3dd4682478c6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa2766198b1a61b0d3dd4682478c6e5">&#9670;&#160;</a></span>AddByte() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddByte </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置插入 Byte 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Byte 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Add的代理，具体行为参考Add函数的说明 </dd></dl>

</div>
</div>
<a id="ae2c49fda1d949d6edebd95d819e2dc55" name="ae2c49fda1d949d6edebd95d819e2dc55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c49fda1d949d6edebd95d819e2dc55">&#9670;&#160;</a></span>AddByteArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddByteArray </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置插入 ByteArray 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 ByteArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Add的代理，具体行为参考Add函数的说明 </dd></dl>

</div>
</div>
<a id="a008e1c27cf09102a42808e62fba9fdbf" name="a008e1c27cf09102a42808e62fba9fdbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008e1c27cf09102a42808e62fba9fdbf">&#9670;&#160;</a></span>AddByteArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddByteArray </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置插入 ByteArray 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 ByteArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Add的代理，具体行为参考Add函数的说明 </dd></dl>

</div>
</div>
<a id="af65b31d1dbb3caf3a78dce6a508bcbc8" name="af65b31d1dbb3caf3a78dce6a508bcbc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65b31d1dbb3caf3a78dce6a508bcbc8">&#9670;&#160;</a></span>AddCompound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddCompound </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置插入 Compound 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Compound 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Add的代理，具体行为参考Add函数的说明 </dd></dl>

</div>
</div>
<a id="a759de28b1aadede39edaa85708c29de7" name="a759de28b1aadede39edaa85708c29de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759de28b1aadede39edaa85708c29de7">&#9670;&#160;</a></span>AddCompound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddCompound </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置插入 Compound 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Compound 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Add的代理，具体行为参考Add函数的说明 </dd></dl>

</div>
</div>
<a id="a889d1cd3a48d6588310fae2e7578afcb" name="a889d1cd3a48d6588310fae2e7578afcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889d1cd3a48d6588310fae2e7578afcb">&#9670;&#160;</a></span>AddDouble() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddDouble </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置插入 Double 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Double 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Add的代理，具体行为参考Add函数的说明 </dd></dl>

</div>
</div>
<a id="a48980d31466133f9a5874a622f3b6f37" name="a48980d31466133f9a5874a622f3b6f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48980d31466133f9a5874a622f3b6f37">&#9670;&#160;</a></span>AddDouble() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddDouble </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置插入 Double 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Double 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Add的代理，具体行为参考Add函数的说明 </dd></dl>

</div>
</div>
<a id="a730abf221fdf1a880ce0725cf85d3fc4" name="a730abf221fdf1a880ce0725cf85d3fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730abf221fdf1a880ce0725cf85d3fc4">&#9670;&#160;</a></span>AddEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddEnd </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置插入 End 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 End 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Add的代理，具体行为参考Add函数的说明 </dd></dl>

</div>
</div>
<a id="ae45d0b0c8d81ee7b8539190fa3f18d70" name="ae45d0b0c8d81ee7b8539190fa3f18d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45d0b0c8d81ee7b8539190fa3f18d70">&#9670;&#160;</a></span>AddEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddEnd </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置插入 End 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 End 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Add的代理，具体行为参考Add函数的说明 </dd></dl>

</div>
</div>
<a id="afdf3b02f937faae72e765cdc716dbe9a" name="afdf3b02f937faae72e765cdc716dbe9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf3b02f937faae72e765cdc716dbe9a">&#9670;&#160;</a></span>AddFloat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFloat </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置插入 Float 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Float 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Add的代理，具体行为参考Add函数的说明 </dd></dl>

</div>
</div>
<a id="a513c4665da324b2392ac4899c71f6b32" name="a513c4665da324b2392ac4899c71f6b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513c4665da324b2392ac4899c71f6b32">&#9670;&#160;</a></span>AddFloat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFloat </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置插入 Float 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Float 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Add的代理，具体行为参考Add函数的说明 </dd></dl>

</div>
</div>
<a id="ad8554eee64f0aadec16906e67e1ab2ee" name="ad8554eee64f0aadec16906e67e1ab2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8554eee64f0aadec16906e67e1ab2ee">&#9670;&#160;</a></span>AddFront()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFront </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入元素 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同 </td></tr>
    <tr><td class="paramname">V</td><td>元素值类型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含插入元素所在位置的迭代器和是否操作成功的bool值的pair，否则仅返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>在bNoCheck为false的情况下，当且仅当插入的类型与当前列表存储的类型一致，同时szPos在合法范围内，函数成功，否则失败， 如果bNoCheck为true则必然成功，所以函数仅返回迭代器 </dd>
<dd>
在bNoCheck为false的情况下，如果当前列表标签为空，则列表存储的类型自动变为当前元素类型， 如果bNoCheck为true，则列表不会设置当前元素类型，请使用SetTag来变更元素类型或放弃维护元素类型 </dd></dl>

</div>
</div>
<a id="a99185401ccff9c434da8841f5fd1c756" name="a99185401ccff9c434da8841f5fd1c756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99185401ccff9c434da8841f5fd1c756">&#9670;&#160;</a></span>AddFrontByte() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFrontByte </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入 Byte 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Byte 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddFront的代理，具体行为参考AddFront函数的说明 </dd></dl>

</div>
</div>
<a id="a8fdec2871bb9e230ba7ed1b531cf1924" name="a8fdec2871bb9e230ba7ed1b531cf1924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fdec2871bb9e230ba7ed1b531cf1924">&#9670;&#160;</a></span>AddFrontByte() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFrontByte </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入 Byte 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Byte 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddFront的代理，具体行为参考AddFront函数的说明 </dd></dl>

</div>
</div>
<a id="add7134c3868d78303a4cfb1b2f90da4e" name="add7134c3868d78303a4cfb1b2f90da4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7134c3868d78303a4cfb1b2f90da4e">&#9670;&#160;</a></span>AddFrontByteArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFrontByteArray </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入 ByteArray 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 ByteArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddFront的代理，具体行为参考AddFront函数的说明 </dd></dl>

</div>
</div>
<a id="a16281e45c397853ae7d23ed00ab145a8" name="a16281e45c397853ae7d23ed00ab145a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16281e45c397853ae7d23ed00ab145a8">&#9670;&#160;</a></span>AddFrontByteArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFrontByteArray </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入 ByteArray 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 ByteArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddFront的代理，具体行为参考AddFront函数的说明 </dd></dl>

</div>
</div>
<a id="a2df73d202bcb02a744996471660ac985" name="a2df73d202bcb02a744996471660ac985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df73d202bcb02a744996471660ac985">&#9670;&#160;</a></span>AddFrontCompound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFrontCompound </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入 Compound 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Compound 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddFront的代理，具体行为参考AddFront函数的说明 </dd></dl>

</div>
</div>
<a id="abbdce0869d99cb120642f4b117923c6a" name="abbdce0869d99cb120642f4b117923c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbdce0869d99cb120642f4b117923c6a">&#9670;&#160;</a></span>AddFrontCompound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFrontCompound </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入 Compound 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Compound 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddFront的代理，具体行为参考AddFront函数的说明 </dd></dl>

</div>
</div>
<a id="aa77865f7b93585ba89a0d84516279967" name="aa77865f7b93585ba89a0d84516279967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa77865f7b93585ba89a0d84516279967">&#9670;&#160;</a></span>AddFrontDouble() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFrontDouble </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入 Double 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Double 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddFront的代理，具体行为参考AddFront函数的说明 </dd></dl>

</div>
</div>
<a id="a26620df77fb6fb93f5504ed310b1b62a" name="a26620df77fb6fb93f5504ed310b1b62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26620df77fb6fb93f5504ed310b1b62a">&#9670;&#160;</a></span>AddFrontDouble() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFrontDouble </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入 Double 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Double 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddFront的代理，具体行为参考AddFront函数的说明 </dd></dl>

</div>
</div>
<a id="aebea6c67b50c0af1a893fd7ce9f7e1e8" name="aebea6c67b50c0af1a893fd7ce9f7e1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebea6c67b50c0af1a893fd7ce9f7e1e8">&#9670;&#160;</a></span>AddFrontEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFrontEnd </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入 End 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 End 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddFront的代理，具体行为参考AddFront函数的说明 </dd></dl>

</div>
</div>
<a id="aa1daa840857d32ad24b2f9dc55766dc9" name="aa1daa840857d32ad24b2f9dc55766dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1daa840857d32ad24b2f9dc55766dc9">&#9670;&#160;</a></span>AddFrontEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFrontEnd </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入 End 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 End 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddFront的代理，具体行为参考AddFront函数的说明 </dd></dl>

</div>
</div>
<a id="a16712e50ffd34b4fdab297d82b021da1" name="a16712e50ffd34b4fdab297d82b021da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16712e50ffd34b4fdab297d82b021da1">&#9670;&#160;</a></span>AddFrontFloat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFrontFloat </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入 Float 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Float 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddFront的代理，具体行为参考AddFront函数的说明 </dd></dl>

</div>
</div>
<a id="a8b697273d483c624bfa7f04cec6cca9b" name="a8b697273d483c624bfa7f04cec6cca9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b697273d483c624bfa7f04cec6cca9b">&#9670;&#160;</a></span>AddFrontFloat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFrontFloat </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入 Float 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Float 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddFront的代理，具体行为参考AddFront函数的说明 </dd></dl>

</div>
</div>
<a id="a8388bc89bb80bcad3d91a02743f0daf4" name="a8388bc89bb80bcad3d91a02743f0daf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8388bc89bb80bcad3d91a02743f0daf4">&#9670;&#160;</a></span>AddFrontInt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFrontInt </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入 Int 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Int 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddFront的代理，具体行为参考AddFront函数的说明 </dd></dl>

</div>
</div>
<a id="a70bd82293e2d465a71b4a03ef0c0fbd5" name="a70bd82293e2d465a71b4a03ef0c0fbd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70bd82293e2d465a71b4a03ef0c0fbd5">&#9670;&#160;</a></span>AddFrontInt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFrontInt </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入 Int 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Int 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddFront的代理，具体行为参考AddFront函数的说明 </dd></dl>

</div>
</div>
<a id="a1057b95f4373e41e6513d72901ef6a9f" name="a1057b95f4373e41e6513d72901ef6a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1057b95f4373e41e6513d72901ef6a9f">&#9670;&#160;</a></span>AddFrontIntArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFrontIntArray </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入 IntArray 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 IntArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddFront的代理，具体行为参考AddFront函数的说明 </dd></dl>

</div>
</div>
<a id="ab2ac42024aeb9a42e9564748f631b4bb" name="ab2ac42024aeb9a42e9564748f631b4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ac42024aeb9a42e9564748f631b4bb">&#9670;&#160;</a></span>AddFrontIntArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFrontIntArray </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入 IntArray 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 IntArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddFront的代理，具体行为参考AddFront函数的说明 </dd></dl>

</div>
</div>
<a id="a286582ccd239379f88df82d05b4f4e99" name="a286582ccd239379f88df82d05b4f4e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286582ccd239379f88df82d05b4f4e99">&#9670;&#160;</a></span>AddFrontList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFrontList </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入 List 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 List 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddFront的代理，具体行为参考AddFront函数的说明 </dd></dl>

</div>
</div>
<a id="a4d796ee72470bf5c58bfd1d6e801eae7" name="a4d796ee72470bf5c58bfd1d6e801eae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d796ee72470bf5c58bfd1d6e801eae7">&#9670;&#160;</a></span>AddFrontList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFrontList </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入 List 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 List 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddFront的代理，具体行为参考AddFront函数的说明 </dd></dl>

</div>
</div>
<a id="aaa1274e21fe96bc8817c2c40c1f8d897" name="aaa1274e21fe96bc8817c2c40c1f8d897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa1274e21fe96bc8817c2c40c1f8d897">&#9670;&#160;</a></span>AddFrontLong() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFrontLong </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入 Long 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Long 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddFront的代理，具体行为参考AddFront函数的说明 </dd></dl>

</div>
</div>
<a id="ac55f01d4c13e073e8345318c4d6d4ea8" name="ac55f01d4c13e073e8345318c4d6d4ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac55f01d4c13e073e8345318c4d6d4ea8">&#9670;&#160;</a></span>AddFrontLong() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFrontLong </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入 Long 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Long 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddFront的代理，具体行为参考AddFront函数的说明 </dd></dl>

</div>
</div>
<a id="a2726475a3dfec27ef2c27d44825c1592" name="a2726475a3dfec27ef2c27d44825c1592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2726475a3dfec27ef2c27d44825c1592">&#9670;&#160;</a></span>AddFrontLongArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFrontLongArray </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入 LongArray 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 LongArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddFront的代理，具体行为参考AddFront函数的说明 </dd></dl>

</div>
</div>
<a id="aca7b2002c540e479bd9dd4446030798d" name="aca7b2002c540e479bd9dd4446030798d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7b2002c540e479bd9dd4446030798d">&#9670;&#160;</a></span>AddFrontLongArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFrontLongArray </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入 LongArray 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 LongArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddFront的代理，具体行为参考AddFront函数的说明 </dd></dl>

</div>
</div>
<a id="ad576e7aa0fb373058790fddf341fb036" name="ad576e7aa0fb373058790fddf341fb036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad576e7aa0fb373058790fddf341fb036">&#9670;&#160;</a></span>AddFrontShort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFrontShort </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入 Short 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Short 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddFront的代理，具体行为参考AddFront函数的说明 </dd></dl>

</div>
</div>
<a id="adf9c09a2a93d88cb37ddd685a839a623" name="adf9c09a2a93d88cb37ddd685a839a623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9c09a2a93d88cb37ddd685a839a623">&#9670;&#160;</a></span>AddFrontShort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFrontShort </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入 Short 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 Short 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddFront的代理，具体行为参考AddFront函数的说明 </dd></dl>

</div>
</div>
<a id="a94812566be41a9865de994c296763a3f" name="a94812566be41a9865de994c296763a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94812566be41a9865de994c296763a3f">&#9670;&#160;</a></span>AddFrontString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFrontString </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入 String 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 String 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddFront的代理，具体行为参考AddFront函数的说明 </dd></dl>

</div>
</div>
<a id="a3e8f6be8206b1a19a0d8938064919353" name="a3e8f6be8206b1a19a0d8938064919353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e8f6be8206b1a19a0d8938064919353">&#9670;&#160;</a></span>AddFrontString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddFrontString </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在列表头部插入 String 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">vTagVal</td><td>要插入的 String 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数AddFront的代理，具体行为参考AddFront函数的说明 </dd></dl>

</div>
</div>
<a id="ae7373d98040308c69326a8672df9ec8b" name="ae7373d98040308c69326a8672df9ec8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7373d98040308c69326a8672df9ec8b">&#9670;&#160;</a></span>AddInt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddInt </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置插入 Int 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Int 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Add的代理，具体行为参考Add函数的说明 </dd></dl>

</div>
</div>
<a id="a5d786087774ef1c03835d9be8a0b59d3" name="a5d786087774ef1c03835d9be8a0b59d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d786087774ef1c03835d9be8a0b59d3">&#9670;&#160;</a></span>AddInt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddInt </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置插入 Int 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Int 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Add的代理，具体行为参考Add函数的说明 </dd></dl>

</div>
</div>
<a id="ab2ba3178b74df8c0f526d4b235e589bb" name="ab2ba3178b74df8c0f526d4b235e589bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ba3178b74df8c0f526d4b235e589bb">&#9670;&#160;</a></span>AddIntArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddIntArray </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置插入 IntArray 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 IntArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Add的代理，具体行为参考Add函数的说明 </dd></dl>

</div>
</div>
<a id="a433152c97b29de197e5e78b498359f22" name="a433152c97b29de197e5e78b498359f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a433152c97b29de197e5e78b498359f22">&#9670;&#160;</a></span>AddIntArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddIntArray </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置插入 IntArray 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 IntArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Add的代理，具体行为参考Add函数的说明 </dd></dl>

</div>
</div>
<a id="a419438a888488815a737e849841335d0" name="a419438a888488815a737e849841335d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419438a888488815a737e849841335d0">&#9670;&#160;</a></span>AddList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddList </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置插入 List 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 List 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Add的代理，具体行为参考Add函数的说明 </dd></dl>

</div>
</div>
<a id="abc0738f3ed1db9b0098a6c6e711b7ba1" name="abc0738f3ed1db9b0098a6c6e711b7ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc0738f3ed1db9b0098a6c6e711b7ba1">&#9670;&#160;</a></span>AddList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddList </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置插入 List 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 List 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Add的代理，具体行为参考Add函数的说明 </dd></dl>

</div>
</div>
<a id="a0ec2512410d447603e9613a190b95822" name="a0ec2512410d447603e9613a190b95822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec2512410d447603e9613a190b95822">&#9670;&#160;</a></span>AddLong() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddLong </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置插入 Long 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Long 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Add的代理，具体行为参考Add函数的说明 </dd></dl>

</div>
</div>
<a id="a30269b398a932d3ab64e938cef72561f" name="a30269b398a932d3ab64e938cef72561f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30269b398a932d3ab64e938cef72561f">&#9670;&#160;</a></span>AddLong() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddLong </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置插入 Long 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Long 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Add的代理，具体行为参考Add函数的说明 </dd></dl>

</div>
</div>
<a id="a2730b73a7171385814ccf3d7e6b3ac27" name="a2730b73a7171385814ccf3d7e6b3ac27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2730b73a7171385814ccf3d7e6b3ac27">&#9670;&#160;</a></span>AddLongArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddLongArray </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置插入 LongArray 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 LongArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Add的代理，具体行为参考Add函数的说明 </dd></dl>

</div>
</div>
<a id="ac1b1bd1345afe3b0a5c010e012e86303" name="ac1b1bd1345afe3b0a5c010e012e86303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b1bd1345afe3b0a5c010e012e86303">&#9670;&#160;</a></span>AddLongArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddLongArray </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置插入 LongArray 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 LongArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Add的代理，具体行为参考Add函数的说明 </dd></dl>

</div>
</div>
<a id="ad2019f2c3b9f99fcfefe82ce4634563c" name="ad2019f2c3b9f99fcfefe82ce4634563c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2019f2c3b9f99fcfefe82ce4634563c">&#9670;&#160;</a></span>AddShort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddShort </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置插入 Short 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Short 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Add的代理，具体行为参考Add函数的说明 </dd></dl>

</div>
</div>
<a id="af22104927321d29d082fcf5f6e060049" name="af22104927321d29d082fcf5f6e060049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22104927321d29d082fcf5f6e060049">&#9670;&#160;</a></span>AddShort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddShort </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置插入 Short 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Short 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Add的代理，具体行为参考Add函数的说明 </dd></dl>

</div>
</div>
<a id="a91de8e9c37e47379d8e574b34f5791c6" name="a91de8e9c37e47379d8e574b34f5791c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91de8e9c37e47379d8e574b34f5791c6">&#9670;&#160;</a></span>AddString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddString </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置插入 String 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 String 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Add的代理，具体行为参考Add函数的说明 </dd></dl>

</div>
</div>
<a id="a2848abd925d8eef2408617ae186a51ef" name="a2848abd925d8eef2408617ae186a51ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2848abd925d8eef2408617ae186a51ef">&#9670;&#160;</a></span>AddString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::AddString </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>在指定位置插入 String 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>插入位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 String 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Add的代理，具体行为参考Add函数的说明 </dd></dl>

</div>
</div>
<a id="a3a63bc1ee772758f149d9b418fbda13b" name="a3a63bc1ee772758f149d9b418fbda13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a63bc1ee772758f149d9b418fbda13b">&#9670;&#160;</a></span>Back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const List::value_type &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::Back </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后的元素 </p>
<dl class="section return"><dt>返回</dt><dd>最后的元素的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果当前列表为空，行为未定义，请参考std::vector对于back的描述 </dd></dl>

</div>
</div>
<a id="a91cb4f977562650046b99d727c223970" name="a91cb4f977562650046b99d727c223970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cb4f977562650046b99d727c223970">&#9670;&#160;</a></span>Back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">List::value_type &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::Back </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后的元素 </p>
<dl class="section return"><dt>返回</dt><dd>最后的元素的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果当前列表为空，行为未定义，请参考std::vector对于back的描述 </dd></dl>

</div>
</div>
<a id="aa4741feb1fb63d461b48d4f54ea2d76e" name="aa4741feb1fb63d461b48d4f54ea2d76e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4741feb1fb63d461b48d4f54ea2d76e">&#9670;&#160;</a></span>BackByte() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::BackByte </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后一个 Byte 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Byte 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于back的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="adfbb3fd24f2c105bc69e9d241b2773dc" name="adfbb3fd24f2c105bc69e9d241b2773dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfbb3fd24f2c105bc69e9d241b2773dc">&#9670;&#160;</a></span>BackByte() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::BackByte </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后一个 Byte 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Byte 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于back的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a1d73d014ec6efd2191820e6cb88feef5" name="a1d73d014ec6efd2191820e6cb88feef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d73d014ec6efd2191820e6cb88feef5">&#9670;&#160;</a></span>BackByteArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::BackByteArray </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后一个 ByteArray 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>ByteArray 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于back的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a2f25fbfd543caa08e8285e28f1c63b67" name="a2f25fbfd543caa08e8285e28f1c63b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f25fbfd543caa08e8285e28f1c63b67">&#9670;&#160;</a></span>BackByteArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::BackByteArray </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后一个 ByteArray 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>ByteArray 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于back的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a9aa75768fee5124f5fb0f92346f3f383" name="a9aa75768fee5124f5fb0f92346f3f383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aa75768fee5124f5fb0f92346f3f383">&#9670;&#160;</a></span>BackCompound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::BackCompound </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后一个 Compound 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Compound 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于back的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a09068d3a8b8875cd12ccfaa5db82cf88" name="a09068d3a8b8875cd12ccfaa5db82cf88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09068d3a8b8875cd12ccfaa5db82cf88">&#9670;&#160;</a></span>BackCompound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::BackCompound </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后一个 Compound 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Compound 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于back的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="ae421ede17891982b0a802ae61a559093" name="ae421ede17891982b0a802ae61a559093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae421ede17891982b0a802ae61a559093">&#9670;&#160;</a></span>BackDouble() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::BackDouble </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后一个 Double 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Double 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于back的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a6ce2e43b13e77cfe11553adf80e0c679" name="a6ce2e43b13e77cfe11553adf80e0c679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce2e43b13e77cfe11553adf80e0c679">&#9670;&#160;</a></span>BackDouble() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::BackDouble </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后一个 Double 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Double 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于back的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a1b96bfcfdef5e380c4886f6b18ff4de0" name="a1b96bfcfdef5e380c4886f6b18ff4de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b96bfcfdef5e380c4886f6b18ff4de0">&#9670;&#160;</a></span>BackEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::BackEnd </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后一个 End 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>End 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于back的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a738bdbf24c60e1ab72a84d0da6b284a7" name="a738bdbf24c60e1ab72a84d0da6b284a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a738bdbf24c60e1ab72a84d0da6b284a7">&#9670;&#160;</a></span>BackEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::BackEnd </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后一个 End 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>End 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于back的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a8bbd027166ecd724dbd2001aaeb2218a" name="a8bbd027166ecd724dbd2001aaeb2218a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bbd027166ecd724dbd2001aaeb2218a">&#9670;&#160;</a></span>BackFloat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::BackFloat </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后一个 Float 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Float 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于back的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a7bb1ac7dbafa4023dcb32e6ab46f64e4" name="a7bb1ac7dbafa4023dcb32e6ab46f64e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb1ac7dbafa4023dcb32e6ab46f64e4">&#9670;&#160;</a></span>BackFloat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::BackFloat </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后一个 Float 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Float 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于back的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="aaafef9953442e883ce3a898040401018" name="aaafef9953442e883ce3a898040401018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaafef9953442e883ce3a898040401018">&#9670;&#160;</a></span>BackInt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::BackInt </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后一个 Int 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Int 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于back的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a734599a4a05b95cdf4d96b8c72946b22" name="a734599a4a05b95cdf4d96b8c72946b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734599a4a05b95cdf4d96b8c72946b22">&#9670;&#160;</a></span>BackInt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::BackInt </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后一个 Int 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Int 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于back的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="ad79dbba6510361a6af9fef2467b3c8b1" name="ad79dbba6510361a6af9fef2467b3c8b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79dbba6510361a6af9fef2467b3c8b1">&#9670;&#160;</a></span>BackIntArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::BackIntArray </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后一个 IntArray 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>IntArray 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于back的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a783bf0891343e5fd3fe43bfc19a7c84d" name="a783bf0891343e5fd3fe43bfc19a7c84d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783bf0891343e5fd3fe43bfc19a7c84d">&#9670;&#160;</a></span>BackIntArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::BackIntArray </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后一个 IntArray 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>IntArray 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于back的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="afb41e3311127d23ccd5005301609bbdf" name="afb41e3311127d23ccd5005301609bbdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb41e3311127d23ccd5005301609bbdf">&#9670;&#160;</a></span>BackList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::BackList </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后一个 List 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>List 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于back的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a86108f837132723b207401fbb68ee643" name="a86108f837132723b207401fbb68ee643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86108f837132723b207401fbb68ee643">&#9670;&#160;</a></span>BackList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::BackList </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后一个 List 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>List 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于back的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a2ec95f92f2a8bd0410eefe5bdde6d9a8" name="a2ec95f92f2a8bd0410eefe5bdde6d9a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec95f92f2a8bd0410eefe5bdde6d9a8">&#9670;&#160;</a></span>BackLong() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::BackLong </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后一个 Long 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Long 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于back的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a04f4e190b5da30d35656846b91bf2bfe" name="a04f4e190b5da30d35656846b91bf2bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f4e190b5da30d35656846b91bf2bfe">&#9670;&#160;</a></span>BackLong() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::BackLong </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后一个 Long 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Long 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于back的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a607f2066a7e198d87044d4f539874da4" name="a607f2066a7e198d87044d4f539874da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607f2066a7e198d87044d4f539874da4">&#9670;&#160;</a></span>BackLongArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::BackLongArray </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后一个 LongArray 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>LongArray 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于back的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="ad9ae79518d8d70bbecd81b18e2a11252" name="ad9ae79518d8d70bbecd81b18e2a11252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ae79518d8d70bbecd81b18e2a11252">&#9670;&#160;</a></span>BackLongArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::BackLongArray </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后一个 LongArray 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>LongArray 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于back的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a762e4d37d2cf357de4dbec6cc8cc6d31" name="a762e4d37d2cf357de4dbec6cc8cc6d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762e4d37d2cf357de4dbec6cc8cc6d31">&#9670;&#160;</a></span>BackShort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::BackShort </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后一个 Short 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Short 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于back的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="aac36fac7dc70f865f142008a1d2f60ec" name="aac36fac7dc70f865f142008a1d2f60ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac36fac7dc70f865f142008a1d2f60ec">&#9670;&#160;</a></span>BackShort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::BackShort </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后一个 Short 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Short 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于back的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="affd46b6a866f1e29d5d68cebf96ff392" name="affd46b6a866f1e29d5d68cebf96ff392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd46b6a866f1e29d5d68cebf96ff392">&#9670;&#160;</a></span>BackString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::BackString </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后一个 String 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>String 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于back的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a7482809de9d8d5e02078230018f450b6" name="a7482809de9d8d5e02078230018f450b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7482809de9d8d5e02078230018f450b6">&#9670;&#160;</a></span>BackString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::BackString </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表最后一个 String 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>String 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于back的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a7096884de61f70ec185883f4012f6298" name="a7096884de61f70ec185883f4012f6298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7096884de61f70ec185883f4012f6298">&#9670;&#160;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::Clear </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>清空所有元素 </p>
<dl class="section note"><dt>注解</dt><dd>元素清空后，列表允许直接插入任意类型的元素 </dd></dl>

</div>
</div>
<a id="a4043ffc0168fd0d771e13ba13cf5abdf" name="a4043ffc0168fd0d771e13ba13cf5abdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4043ffc0168fd0d771e13ba13cf5abdf">&#9670;&#160;</a></span>Contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::Contains </td>
          <td>(</td>
          <td class="paramtype">const typename List::value_type &amp;</td>          <td class="paramname"><span class="paramname"><em>tValue</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>检查是否包含指定元素 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">tValue</td><td>要检查的元素 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果包含指定元素返回true，否则返回false </dd></dl>
<dl class="section note"><dt>注解</dt><dd>与NBT_Compound进行哈希查找不同，这里是通过遍历实现的，请注意开销 </dd></dl>

</div>
</div>
<a id="ae23aa4a70a9ead0f4ea61bb65f5b9c54" name="ae23aa4a70a9ead0f4ea61bb65f5b9c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23aa4a70a9ead0f4ea61bb65f5b9c54">&#9670;&#160;</a></span>ContainsIf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;typename Predicate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::ContainsIf </td>
          <td>(</td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>pred</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>使用谓词检查是否存在满足条件的元素 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>谓词仿函数类型，需要接受value_type并返回bool </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>谓词仿函数对象 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在满足条件的元素返回true，否则返回false </dd></dl>
<dl class="section note"><dt>注解</dt><dd>与NBT_Compound进行哈希查找不同，这里是通过遍历实现的，请注意开销 </dd></dl>

</div>
</div>
<a id="a1360a1e15ef94b44711422085cfdf715" name="a1360a1e15ef94b44711422085cfdf715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1360a1e15ef94b44711422085cfdf715">&#9670;&#160;</a></span>Empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::Empty </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>检查容器是否为空 </p>
<dl class="section return"><dt>返回</dt><dd>如果容器为空返回true，否则返回false </dd></dl>

</div>
</div>
<a id="a6bad24d55e5194e978bef573296294ca" name="a6bad24d55e5194e978bef573296294ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bad24d55e5194e978bef573296294ca">&#9670;&#160;</a></span>Front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const List::value_type &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::Front </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表开头的元素 </p>
<dl class="section return"><dt>返回</dt><dd>开头的元素的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果当前列表为空，行为未定义，请参考std::vector对于front的描述 </dd></dl>

</div>
</div>
<a id="aa9374edc7e1d1460f8a3bfbf80534315" name="aa9374edc7e1d1460f8a3bfbf80534315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9374edc7e1d1460f8a3bfbf80534315">&#9670;&#160;</a></span>Front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">List::value_type &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::Front </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表开头的元素 </p>
<dl class="section return"><dt>返回</dt><dd>开头的元素的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果当前列表为空，行为未定义，请参考std::vector对于front的描述 </dd></dl>

</div>
</div>
<a id="a42997c41c8530a37777406a2d1a3b2aa" name="a42997c41c8530a37777406a2d1a3b2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42997c41c8530a37777406a2d1a3b2aa">&#9670;&#160;</a></span>FrontByte() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::FrontByte </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表第一个 Byte 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Byte 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于front的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="ab5d0c57d7a9e30dd4fdc008c5a73b9d4" name="ab5d0c57d7a9e30dd4fdc008c5a73b9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d0c57d7a9e30dd4fdc008c5a73b9d4">&#9670;&#160;</a></span>FrontByte() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::FrontByte </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表第一个 Byte 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Byte 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于front的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="ae9ae8598dd714f21cb246eff6a3bde23" name="ae9ae8598dd714f21cb246eff6a3bde23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ae8598dd714f21cb246eff6a3bde23">&#9670;&#160;</a></span>FrontByteArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::FrontByteArray </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表第一个 ByteArray 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>ByteArray 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于front的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a6c3a0bc37533c7962ab34ae01c696b7d" name="a6c3a0bc37533c7962ab34ae01c696b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3a0bc37533c7962ab34ae01c696b7d">&#9670;&#160;</a></span>FrontByteArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::FrontByteArray </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表第一个 ByteArray 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>ByteArray 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于front的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="ae13f10a6eeabb8700de84cd8d3df3b99" name="ae13f10a6eeabb8700de84cd8d3df3b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13f10a6eeabb8700de84cd8d3df3b99">&#9670;&#160;</a></span>FrontCompound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::FrontCompound </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表第一个 Compound 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Compound 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于front的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a025ab42547a78b0493667afc8c86bc73" name="a025ab42547a78b0493667afc8c86bc73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a025ab42547a78b0493667afc8c86bc73">&#9670;&#160;</a></span>FrontCompound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::FrontCompound </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表第一个 Compound 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Compound 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于front的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a10b1c68fb2c9a71a8aa0649110f595ba" name="a10b1c68fb2c9a71a8aa0649110f595ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b1c68fb2c9a71a8aa0649110f595ba">&#9670;&#160;</a></span>FrontDouble() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::FrontDouble </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表第一个 Double 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Double 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于front的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a53c4584fbaf427c862a2bd8709797df2" name="a53c4584fbaf427c862a2bd8709797df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c4584fbaf427c862a2bd8709797df2">&#9670;&#160;</a></span>FrontDouble() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::FrontDouble </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表第一个 Double 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Double 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于front的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a80508b785fb2702300a153e56772e374" name="a80508b785fb2702300a153e56772e374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80508b785fb2702300a153e56772e374">&#9670;&#160;</a></span>FrontEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::FrontEnd </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表第一个 End 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>End 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于front的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a3b2c6ffc6a3a7929cf6d592779e9ab6e" name="a3b2c6ffc6a3a7929cf6d592779e9ab6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2c6ffc6a3a7929cf6d592779e9ab6e">&#9670;&#160;</a></span>FrontEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::FrontEnd </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表第一个 End 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>End 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于front的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a279536fa8442390f61773802ca9e3c33" name="a279536fa8442390f61773802ca9e3c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a279536fa8442390f61773802ca9e3c33">&#9670;&#160;</a></span>FrontFloat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::FrontFloat </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表第一个 Float 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Float 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于front的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a78ef7b5ea688936da07a76f8f70f3e95" name="a78ef7b5ea688936da07a76f8f70f3e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ef7b5ea688936da07a76f8f70f3e95">&#9670;&#160;</a></span>FrontFloat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::FrontFloat </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表第一个 Float 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Float 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于front的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a3ced3d12eacd744ccee23aa12f85c28d" name="a3ced3d12eacd744ccee23aa12f85c28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ced3d12eacd744ccee23aa12f85c28d">&#9670;&#160;</a></span>FrontInt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::FrontInt </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表第一个 Int 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Int 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于front的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a7e67e5cd91784e348a57038eb365b1ad" name="a7e67e5cd91784e348a57038eb365b1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e67e5cd91784e348a57038eb365b1ad">&#9670;&#160;</a></span>FrontInt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::FrontInt </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表第一个 Int 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Int 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于front的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="ae657d5365d88c1adad6576a3a17e875a" name="ae657d5365d88c1adad6576a3a17e875a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae657d5365d88c1adad6576a3a17e875a">&#9670;&#160;</a></span>FrontIntArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::FrontIntArray </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表第一个 IntArray 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>IntArray 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于front的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a513f1685f2807c31062248ca20d3bab8" name="a513f1685f2807c31062248ca20d3bab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513f1685f2807c31062248ca20d3bab8">&#9670;&#160;</a></span>FrontIntArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::FrontIntArray </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表第一个 IntArray 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>IntArray 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于front的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a601850a5e99fb85915db0f687f813668" name="a601850a5e99fb85915db0f687f813668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601850a5e99fb85915db0f687f813668">&#9670;&#160;</a></span>FrontList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::FrontList </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表第一个 List 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>List 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于front的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a8ee5eceed2bd5f49541efc91c1c21bf3" name="a8ee5eceed2bd5f49541efc91c1c21bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee5eceed2bd5f49541efc91c1c21bf3">&#9670;&#160;</a></span>FrontList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::FrontList </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表第一个 List 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>List 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于front的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="ac68d606bb44101413218c4c2093cbfa1" name="ac68d606bb44101413218c4c2093cbfa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68d606bb44101413218c4c2093cbfa1">&#9670;&#160;</a></span>FrontLong() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::FrontLong </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表第一个 Long 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Long 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于front的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a24811a2f88874bfbd6de17bd6f584937" name="a24811a2f88874bfbd6de17bd6f584937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24811a2f88874bfbd6de17bd6f584937">&#9670;&#160;</a></span>FrontLong() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::FrontLong </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表第一个 Long 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Long 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于front的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a639720276cd5188385f5c007cced97b0" name="a639720276cd5188385f5c007cced97b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a639720276cd5188385f5c007cced97b0">&#9670;&#160;</a></span>FrontLongArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::FrontLongArray </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表第一个 LongArray 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>LongArray 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于front的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="adcf1a6b30ba3d7c65bc4284ba58494f1" name="adcf1a6b30ba3d7c65bc4284ba58494f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf1a6b30ba3d7c65bc4284ba58494f1">&#9670;&#160;</a></span>FrontLongArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::FrontLongArray </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表第一个 LongArray 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>LongArray 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于front的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a372700f778f2515d09bf92d386ae0eea" name="a372700f778f2515d09bf92d386ae0eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372700f778f2515d09bf92d386ae0eea">&#9670;&#160;</a></span>FrontShort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::FrontShort </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表第一个 Short 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Short 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于front的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a2f44a296b497922e210e4330df802444" name="a2f44a296b497922e210e4330df802444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f44a296b497922e210e4330df802444">&#9670;&#160;</a></span>FrontShort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::FrontShort </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表第一个 Short 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>Short 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于front的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="ada5c71f83095374e718e576a7324048e" name="ada5c71f83095374e718e576a7324048e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5c71f83095374e718e576a7324048e">&#9670;&#160;</a></span>FrontString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::FrontString </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表第一个 String 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>String 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于front的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="aa88006d80991ab9ec7998f0f2d25eb25" name="aa88006d80991ab9ec7998f0f2d25eb25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88006d80991ab9ec7998f0f2d25eb25">&#9670;&#160;</a></span>FrontString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::FrontString </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表第一个 String 类型数据 </p>
<dl class="section return"><dt>返回</dt><dd>String 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果列表为空或类型不匹配则抛出异常， 具体请参考std::vector关于front的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a3501ef3c21061818d95ad6e95d367bb7" name="a3501ef3c21061818d95ad6e95d367bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3501ef3c21061818d95ad6e95d367bb7">&#9670;&#160;</a></span>Get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">List::value_type &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::Get </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>根据位置获取值 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要查找的位置 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>位置对应的值的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在则抛出异常，请参考std::vector对于at的描述 </dd></dl>

</div>
</div>
<a id="aeb7ec88c2ad30e87f6a848beaeb7f16d" name="aeb7ec88c2ad30e87f6a848beaeb7f16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7ec88c2ad30e87f6a848beaeb7f16d">&#9670;&#160;</a></span>Get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const List::value_type &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::Get </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>根据位置获取值 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要查找的位置 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>位置对应的值的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在则抛出异常，请参考std::vector对于at的描述 </dd></dl>

</div>
</div>
<a id="a5612154508f7f97e25f811ac77b2f8f3" name="a5612154508f7f97e25f811ac77b2f8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5612154508f7f97e25f811ac77b2f8f3">&#9670;&#160;</a></span>GetByte() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetByte </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定位置的 Byte 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>位置索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Byte 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在或类型不匹配则抛出异常， 具体请参考std::vector关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a18a22e21bdfd72af85763149cd3dad4c" name="a18a22e21bdfd72af85763149cd3dad4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a22e21bdfd72af85763149cd3dad4c">&#9670;&#160;</a></span>GetByte() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetByte </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定位置的 Byte 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>位置索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Byte 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在或类型不匹配则抛出异常， 具体请参考std::vector关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="ade469517baffb5656d30dd736e7d7680" name="ade469517baffb5656d30dd736e7d7680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade469517baffb5656d30dd736e7d7680">&#9670;&#160;</a></span>GetByteArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetByteArray </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定位置的 ByteArray 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>位置索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>ByteArray 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在或类型不匹配则抛出异常， 具体请参考std::vector关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a054086d23ad47e960d31bb45426b05c3" name="a054086d23ad47e960d31bb45426b05c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054086d23ad47e960d31bb45426b05c3">&#9670;&#160;</a></span>GetByteArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetByteArray </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定位置的 ByteArray 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>位置索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>ByteArray 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在或类型不匹配则抛出异常， 具体请参考std::vector关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="affbd47cfb0a9f7df632f5df56e1f6204" name="affbd47cfb0a9f7df632f5df56e1f6204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affbd47cfb0a9f7df632f5df56e1f6204">&#9670;&#160;</a></span>GetCompound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetCompound </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定位置的 Compound 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>位置索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Compound 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在或类型不匹配则抛出异常， 具体请参考std::vector关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a33e2acdb1d5b309a59995f956072a9ce" name="a33e2acdb1d5b309a59995f956072a9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e2acdb1d5b309a59995f956072a9ce">&#9670;&#160;</a></span>GetCompound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetCompound </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定位置的 Compound 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>位置索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Compound 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在或类型不匹配则抛出异常， 具体请参考std::vector关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a25e00aaf9a73e10ee50015dfb0db9a3d" name="a25e00aaf9a73e10ee50015dfb0db9a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e00aaf9a73e10ee50015dfb0db9a3d">&#9670;&#160;</a></span>GetData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const List &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetData </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取底层容器数据的常量引用 </p>
<dl class="section return"><dt>返回</dt><dd>底层容器数据的常量引用 </dd></dl>

</div>
</div>
<a id="aea609b3edea68f5e06952ce030e60c31" name="aea609b3edea68f5e06952ce030e60c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea609b3edea68f5e06952ce030e60c31">&#9670;&#160;</a></span>GetDouble() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetDouble </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定位置的 Double 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>位置索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Double 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在或类型不匹配则抛出异常， 具体请参考std::vector关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="ab7fb4dba81f97182f262aa7195068a23" name="ab7fb4dba81f97182f262aa7195068a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7fb4dba81f97182f262aa7195068a23">&#9670;&#160;</a></span>GetDouble() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetDouble </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定位置的 Double 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>位置索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Double 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在或类型不匹配则抛出异常， 具体请参考std::vector关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a9233fc78a51841aa441dfb7cb4053b05" name="a9233fc78a51841aa441dfb7cb4053b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9233fc78a51841aa441dfb7cb4053b05">&#9670;&#160;</a></span>GetEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetEnd </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定位置的 End 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>位置索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>End 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在或类型不匹配则抛出异常， 具体请参考std::vector关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a786560be056be2304e56157027bd5b9b" name="a786560be056be2304e56157027bd5b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786560be056be2304e56157027bd5b9b">&#9670;&#160;</a></span>GetEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetEnd </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定位置的 End 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>位置索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>End 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在或类型不匹配则抛出异常， 具体请参考std::vector关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a507dbde600395082315d9a8265be9eb7" name="a507dbde600395082315d9a8265be9eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507dbde600395082315d9a8265be9eb7">&#9670;&#160;</a></span>GetFloat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetFloat </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定位置的 Float 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>位置索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Float 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在或类型不匹配则抛出异常， 具体请参考std::vector关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a2739186fa374e41e5e472c77b2f05e80" name="a2739186fa374e41e5e472c77b2f05e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2739186fa374e41e5e472c77b2f05e80">&#9670;&#160;</a></span>GetFloat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetFloat </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定位置的 Float 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>位置索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Float 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在或类型不匹配则抛出异常， 具体请参考std::vector关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a6ca48f901e3b389bd5bd0a5b3db90816" name="a6ca48f901e3b389bd5bd0a5b3db90816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca48f901e3b389bd5bd0a5b3db90816">&#9670;&#160;</a></span>GetInt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetInt </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定位置的 Int 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>位置索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Int 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在或类型不匹配则抛出异常， 具体请参考std::vector关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a7361c8851911c9db2fc38a819de77cd8" name="a7361c8851911c9db2fc38a819de77cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7361c8851911c9db2fc38a819de77cd8">&#9670;&#160;</a></span>GetInt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetInt </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定位置的 Int 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>位置索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Int 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在或类型不匹配则抛出异常， 具体请参考std::vector关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a2499e845602b75380e1c4dab8d1bf123" name="a2499e845602b75380e1c4dab8d1bf123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2499e845602b75380e1c4dab8d1bf123">&#9670;&#160;</a></span>GetIntArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetIntArray </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定位置的 IntArray 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>位置索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>IntArray 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在或类型不匹配则抛出异常， 具体请参考std::vector关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a75b438d38a78a2628bc543a3a5a076c6" name="a75b438d38a78a2628bc543a3a5a076c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b438d38a78a2628bc543a3a5a076c6">&#9670;&#160;</a></span>GetIntArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetIntArray </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定位置的 IntArray 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>位置索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>IntArray 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在或类型不匹配则抛出异常， 具体请参考std::vector关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a8b198553f931211b046d668f542810d1" name="a8b198553f931211b046d668f542810d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b198553f931211b046d668f542810d1">&#9670;&#160;</a></span>GetList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetList </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定位置的 List 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>位置索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>List 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在或类型不匹配则抛出异常， 具体请参考std::vector关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a9d0200e874f1a892e6beb8176c9f51fa" name="a9d0200e874f1a892e6beb8176c9f51fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0200e874f1a892e6beb8176c9f51fa">&#9670;&#160;</a></span>GetList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetList </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定位置的 List 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>位置索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>List 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在或类型不匹配则抛出异常， 具体请参考std::vector关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a2a18666ca33e3a1f495233edf16cfc4b" name="a2a18666ca33e3a1f495233edf16cfc4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a18666ca33e3a1f495233edf16cfc4b">&#9670;&#160;</a></span>GetLong() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetLong </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定位置的 Long 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>位置索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Long 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在或类型不匹配则抛出异常， 具体请参考std::vector关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="ae034ae01360e74bd983868ac340eba13" name="ae034ae01360e74bd983868ac340eba13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae034ae01360e74bd983868ac340eba13">&#9670;&#160;</a></span>GetLong() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetLong </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定位置的 Long 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>位置索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Long 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在或类型不匹配则抛出异常， 具体请参考std::vector关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a66425e8dd69f523fbdf29def1c999b8e" name="a66425e8dd69f523fbdf29def1c999b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66425e8dd69f523fbdf29def1c999b8e">&#9670;&#160;</a></span>GetLongArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetLongArray </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定位置的 LongArray 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>位置索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>LongArray 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在或类型不匹配则抛出异常， 具体请参考std::vector关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="af41afd1296f60af65a371322223302e5" name="af41afd1296f60af65a371322223302e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af41afd1296f60af65a371322223302e5">&#9670;&#160;</a></span>GetLongArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetLongArray </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定位置的 LongArray 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>位置索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>LongArray 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在或类型不匹配则抛出异常， 具体请参考std::vector关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="ad6d645db1759d193fd318905a78f90f2" name="ad6d645db1759d193fd318905a78f90f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d645db1759d193fd318905a78f90f2">&#9670;&#160;</a></span>GetShort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetShort </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定位置的 Short 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>位置索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Short 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在或类型不匹配则抛出异常， 具体请参考std::vector关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="addfe7c457d40de475e6a20fb4b40b779" name="addfe7c457d40de475e6a20fb4b40b779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfe7c457d40de475e6a20fb4b40b779">&#9670;&#160;</a></span>GetShort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetShort </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定位置的 Short 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>位置索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Short 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在或类型不匹配则抛出异常， 具体请参考std::vector关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a344e70687c926836000ce737edcd0026" name="a344e70687c926836000ce737edcd0026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a344e70687c926836000ce737edcd0026">&#9670;&#160;</a></span>GetString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetString </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定位置的 String 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>位置索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>String 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在或类型不匹配则抛出异常， 具体请参考std::vector关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a5d5d29783e19906cec144c8cd1bdc366" name="a5d5d29783e19906cec144c8cd1bdc366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5d29783e19906cec144c8cd1bdc366">&#9670;&#160;</a></span>GetString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetString </td>
          <td>(</td>
          <td class="paramtype">const typename List::size_type &amp;</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定位置的 String 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>位置索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>String 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果位置不存在或类型不匹配则抛出异常， 具体请参考std::vector关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="af281716463eaf9a843a8b2ec4932747b" name="af281716463eaf9a843a8b2ec4932747b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af281716463eaf9a843a8b2ec4932747b">&#9670;&#160;</a></span>GetTag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="NBT__TAG_8hpp.html#ada3a2766daa185b5461d684c766b4a2e">NBT_TAG</a> <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::GetTag </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取列表存储的元素类型 </p>
<dl class="section return"><dt>返回</dt><dd>当前列表存储的元素类型 </dd></dl>

</div>
</div>
<a id="a44139650112584d40a6aba71ec9fe2e7" name="a44139650112584d40a6aba71ec9fe2e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44139650112584d40a6aba71ec9fe2e7">&#9670;&#160;</a></span>Merge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, void, bool &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::Merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_Copy</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>拷贝合并另一个NBT_List的内容 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过另一个列表中的类型检查 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Copy</td><td>要合并的源对象 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回合并是否成功；否则返回void </dd></dl>
<dl class="section note"><dt>注解</dt><dd>在bNoCheck为false的情况下，只要任一列表标签为空或两个列表元素类型相同，则成功，否则失败， 如果bNoCheck为true，则必然成功，所以函数返回void </dd>
<dd>
在bNoCheck为false的情况下，如果当前列表标签为空，则列表存储的类型自动变为当前元素类型， 如果bNoCheck为true，则列表不会设置当前元素类型，请使用SetTag来变更元素类型或放弃维护元素类型 </dd></dl>

</div>
</div>
<a id="a059fe5bd8f1b608e3cd95f715c9ed06c" name="a059fe5bd8f1b608e3cd95f715c9ed06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059fe5bd8f1b608e3cd95f715c9ed06c">&#9670;&#160;</a></span>Merge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, void, bool &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::Merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>_Move</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>移动合并另一个NBT_List的内容 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过另一个列表中的类型检查 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Move</td><td>要合并的源对象 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回合并是否成功；否则返回void </dd></dl>
<dl class="section note"><dt>注解</dt><dd>在bNoCheck为false的情况下，只要任一列表标签为空或两个列表元素类型相同，则成功，否则失败， 如果bNoCheck为true，则必然成功，所以函数返回void </dd>
<dd>
在bNoCheck为false的情况下，如果当前列表标签为空，则列表存储的类型自动变为当前元素类型， 如果bNoCheck为true，则列表不会设置当前元素类型，请使用SetTag来变更元素类型或放弃维护元素类型 </dd>
<dd>
如果函数失败，不会进行移动 </dd></dl>

</div>
</div>
<a id="acf5a296aea4f101b24807d7a351f3474" name="acf5a296aea4f101b24807d7a351f3474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5a296aea4f101b24807d7a351f3474">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_Right</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>不等比较运算符 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Right</td><td>要比较的右操作数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>是否不相等 </dd></dl>

</div>
</div>
<a id="a6a52ad85258d584cbdf392ddf039d177" name="a6a52ad85258d584cbdf392ddf039d177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a52ad85258d584cbdf392ddf039d177">&#9670;&#160;</a></span>operator&lt;=&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::partial_ordering <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_Right</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>三路比较运算符 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Right</td><td>要比较的右操作数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>比较结果，通过std::partial_ordering返回 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>列表会首先比较当前存储的类型是否与目标一致，不一致则返回Tag顺序的比较结果， 否则返回列表元素顺序的比较结果 </dd></dl>

</div>
</div>
<a id="ad930fb96a7e2669c7b9b41ec5f273579" name="ad930fb96a7e2669c7b9b41ec5f273579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad930fb96a7e2669c7b9b41ec5f273579">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__List.html">NBT_List</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_Copy</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>拷贝赋值运算符 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Copy</td><td>要拷贝的源对象 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>当前对象的引用 </dd></dl>

</div>
</div>
<a id="af3df4c5ad24a803298ea08945f98ecf4" name="af3df4c5ad24a803298ea08945f98ecf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3df4c5ad24a803298ea08945f98ecf4">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__List.html">NBT_List</a> &amp; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>_Move</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>移动赋值运算符 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Move</td><td>要移动的源对象 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>当前对象的引用 </dd></dl>

</div>
</div>
<a id="a4d0ea5289652b19875b60db4cb2bafe7" name="a4d0ea5289652b19875b60db4cb2bafe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0ea5289652b19875b60db4cb2bafe7">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_Right</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>相等比较运算符 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Right</td><td>要比较的右操作数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>是否相等 </dd></dl>

</div>
</div>
<a id="a76a5a5b81b2112475e4cfad466c79520" name="a76a5a5b81b2112475e4cfad466c79520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a5a5b81b2112475e4cfad466c79520">&#9670;&#160;</a></span>Remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, void, bool &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::Remove </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>删除指定位置的元素 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过索引检查 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要删除的位置 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回删除是否成功，否则直接返回void </dd></dl>
<dl class="section note"><dt>注解</dt><dd>bNoCheck为true则用户需保证szPos索引范围安全 </dd></dl>

</div>
</div>
<a id="a37e987122627aa6ed7b9f13d7db9da52" name="a37e987122627aa6ed7b9f13d7db9da52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e987122627aa6ed7b9f13d7db9da52">&#9670;&#160;</a></span>Reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::Reserve </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szNewCap</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>预留存储空间 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szNewCap</td><td>新的容量大小 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d7d9cb615745f30b38ee9c3d5d03082" name="a8d7d9cb615745f30b38ee9c3d5d03082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7d9cb615745f30b38ee9c3d5d03082">&#9670;&#160;</a></span>Resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::Resize </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szNewSize</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>调整容器大小 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szNewSize</td><td>新的容器大小 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add90f3046175135ca380d11f12ee4856" name="add90f3046175135ca380d11f12ee4856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add90f3046175135ca380d11f12ee4856">&#9670;&#160;</a></span>Set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::Set </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置（替换）指定位置的元素 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同 </td></tr>
    <tr><td class="paramname">V</td><td>元素值类型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置 </td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含插入元素所在位置的迭代器和是否操作成功的bool值的pair，否则仅返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>在bNoCheck为false的情况下，当且仅当插入的类型与当前列表存储的类型一致同时szPos在合法范围内，函数成功，否则失败， 如果bNoCheck为true则必然成功，所以函数仅返回迭代器 </dd>
<dd>
在bNoCheck为false的情况下，如果当前列表标签为空，，则列表存储的类型自动变为当前元素类型， 如果bNoCheck为true，则列表不会设置当前元素类型，请使用SetTag来变更元素类型或放弃维护元素类型 </dd></dl>

</div>
</div>
<a id="a3cc82fba3592f11d3f296563408616a3" name="a3cc82fba3592f11d3f296563408616a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc82fba3592f11d3f296563408616a3">&#9670;&#160;</a></span>SetByte() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetByte </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指定位置的 Byte 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的 Byte 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Set的代理，具体行为参考Set函数的说明 </dd></dl>

</div>
</div>
<a id="ac6f247856e667d0630ccb89d9798a9d4" name="ac6f247856e667d0630ccb89d9798a9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f247856e667d0630ccb89d9798a9d4">&#9670;&#160;</a></span>SetByte() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetByte </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指定位置的 Byte 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的 Byte 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Set的代理，具体行为参考Set函数的说明 </dd></dl>

</div>
</div>
<a id="abaefeea7158bbc10c00afd377ad2cf8d" name="abaefeea7158bbc10c00afd377ad2cf8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaefeea7158bbc10c00afd377ad2cf8d">&#9670;&#160;</a></span>SetByteArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetByteArray </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指定位置的 ByteArray 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的 ByteArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Set的代理，具体行为参考Set函数的说明 </dd></dl>

</div>
</div>
<a id="aca8e94ea2f5acfd2aba2339a66310279" name="aca8e94ea2f5acfd2aba2339a66310279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8e94ea2f5acfd2aba2339a66310279">&#9670;&#160;</a></span>SetByteArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetByteArray </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指定位置的 ByteArray 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的 ByteArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Set的代理，具体行为参考Set函数的说明 </dd></dl>

</div>
</div>
<a id="a69488d281d9c0c6001e98960281444ec" name="a69488d281d9c0c6001e98960281444ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69488d281d9c0c6001e98960281444ec">&#9670;&#160;</a></span>SetCompound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetCompound </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指定位置的 Compound 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的 Compound 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Set的代理，具体行为参考Set函数的说明 </dd></dl>

</div>
</div>
<a id="adc8a2c9c8faf9a7c1a02bff399999aab" name="adc8a2c9c8faf9a7c1a02bff399999aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8a2c9c8faf9a7c1a02bff399999aab">&#9670;&#160;</a></span>SetCompound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetCompound </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指定位置的 Compound 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的 Compound 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Set的代理，具体行为参考Set函数的说明 </dd></dl>

</div>
</div>
<a id="af2d5e39af0e10caa4b2bce489c3bfe2d" name="af2d5e39af0e10caa4b2bce489c3bfe2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d5e39af0e10caa4b2bce489c3bfe2d">&#9670;&#160;</a></span>SetDouble() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetDouble </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指定位置的 Double 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的 Double 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Set的代理，具体行为参考Set函数的说明 </dd></dl>

</div>
</div>
<a id="a666ce9abb18f06fe01be72ccb6dbda67" name="a666ce9abb18f06fe01be72ccb6dbda67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666ce9abb18f06fe01be72ccb6dbda67">&#9670;&#160;</a></span>SetDouble() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetDouble </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指定位置的 Double 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的 Double 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Set的代理，具体行为参考Set函数的说明 </dd></dl>

</div>
</div>
<a id="acd3fcc314939825229d63144c1934028" name="acd3fcc314939825229d63144c1934028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3fcc314939825229d63144c1934028">&#9670;&#160;</a></span>SetEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetEnd </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指定位置的 End 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的 End 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Set的代理，具体行为参考Set函数的说明 </dd></dl>

</div>
</div>
<a id="a57109329800542886fd5b1556a6a1bcc" name="a57109329800542886fd5b1556a6a1bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57109329800542886fd5b1556a6a1bcc">&#9670;&#160;</a></span>SetEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetEnd </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指定位置的 End 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的 End 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Set的代理，具体行为参考Set函数的说明 </dd></dl>

</div>
</div>
<a id="a6e7f836107cdded5fbaba486c96dd03f" name="a6e7f836107cdded5fbaba486c96dd03f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7f836107cdded5fbaba486c96dd03f">&#9670;&#160;</a></span>SetFloat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetFloat </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指定位置的 Float 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的 Float 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Set的代理，具体行为参考Set函数的说明 </dd></dl>

</div>
</div>
<a id="ab4d5fad51938e951929cd52c82e0bf65" name="ab4d5fad51938e951929cd52c82e0bf65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d5fad51938e951929cd52c82e0bf65">&#9670;&#160;</a></span>SetFloat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetFloat </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指定位置的 Float 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的 Float 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Set的代理，具体行为参考Set函数的说明 </dd></dl>

</div>
</div>
<a id="ae8e240f6f3586e09fd86ad0ddffd6cae" name="ae8e240f6f3586e09fd86ad0ddffd6cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e240f6f3586e09fd86ad0ddffd6cae">&#9670;&#160;</a></span>SetInt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetInt </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指定位置的 Int 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的 Int 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Set的代理，具体行为参考Set函数的说明 </dd></dl>

</div>
</div>
<a id="a6c87c9055165bbecaddd98f5d466d6d9" name="a6c87c9055165bbecaddd98f5d466d6d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c87c9055165bbecaddd98f5d466d6d9">&#9670;&#160;</a></span>SetInt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetInt </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指定位置的 Int 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的 Int 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Set的代理，具体行为参考Set函数的说明 </dd></dl>

</div>
</div>
<a id="a769d281e2ae37d4cbf4b760648a1fd41" name="a769d281e2ae37d4cbf4b760648a1fd41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a769d281e2ae37d4cbf4b760648a1fd41">&#9670;&#160;</a></span>SetIntArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetIntArray </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指定位置的 IntArray 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的 IntArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Set的代理，具体行为参考Set函数的说明 </dd></dl>

</div>
</div>
<a id="a21b8a08405ed5e5f996f810349062d27" name="a21b8a08405ed5e5f996f810349062d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b8a08405ed5e5f996f810349062d27">&#9670;&#160;</a></span>SetIntArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetIntArray </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指定位置的 IntArray 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的 IntArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Set的代理，具体行为参考Set函数的说明 </dd></dl>

</div>
</div>
<a id="a8e932f410741dc22428a3bdd7553d722" name="a8e932f410741dc22428a3bdd7553d722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e932f410741dc22428a3bdd7553d722">&#9670;&#160;</a></span>SetList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetList </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指定位置的 List 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的 List 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Set的代理，具体行为参考Set函数的说明 </dd></dl>

</div>
</div>
<a id="a6965c342e1485f3985b848153ed97d98" name="a6965c342e1485f3985b848153ed97d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6965c342e1485f3985b848153ed97d98">&#9670;&#160;</a></span>SetList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetList </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指定位置的 List 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的 List 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Set的代理，具体行为参考Set函数的说明 </dd></dl>

</div>
</div>
<a id="ab2277215397ddd4fbeadd68498822b28" name="ab2277215397ddd4fbeadd68498822b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2277215397ddd4fbeadd68498822b28">&#9670;&#160;</a></span>SetLong() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetLong </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指定位置的 Long 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的 Long 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Set的代理，具体行为参考Set函数的说明 </dd></dl>

</div>
</div>
<a id="af712e0c608cc4d11769555a6c9080f3d" name="af712e0c608cc4d11769555a6c9080f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af712e0c608cc4d11769555a6c9080f3d">&#9670;&#160;</a></span>SetLong() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetLong </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指定位置的 Long 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的 Long 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Set的代理，具体行为参考Set函数的说明 </dd></dl>

</div>
</div>
<a id="ac00114875cb9e475f8115f86c0ce1e6e" name="ac00114875cb9e475f8115f86c0ce1e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00114875cb9e475f8115f86c0ce1e6e">&#9670;&#160;</a></span>SetLongArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetLongArray </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指定位置的 LongArray 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的 LongArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Set的代理，具体行为参考Set函数的说明 </dd></dl>

</div>
</div>
<a id="a01866555ed433df3e6f2ba0fbc11cce1" name="a01866555ed433df3e6f2ba0fbc11cce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01866555ed433df3e6f2ba0fbc11cce1">&#9670;&#160;</a></span>SetLongArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetLongArray </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指定位置的 LongArray 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的 LongArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Set的代理，具体行为参考Set函数的说明 </dd></dl>

</div>
</div>
<a id="ab168d3ecc4365e69d977ec2918ef9c24" name="ab168d3ecc4365e69d977ec2918ef9c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab168d3ecc4365e69d977ec2918ef9c24">&#9670;&#160;</a></span>SetShort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetShort </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指定位置的 Short 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的 Short 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Set的代理，具体行为参考Set函数的说明 </dd></dl>

</div>
</div>
<a id="a4d93cacb64cc5deca37966986307eb2a" name="a4d93cacb64cc5deca37966986307eb2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d93cacb64cc5deca37966986307eb2a">&#9670;&#160;</a></span>SetShort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetShort </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指定位置的 Short 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的 Short 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Set的代理，具体行为参考Set函数的说明 </dd></dl>

</div>
</div>
<a id="a1e0413a1dfbd45c6eb9a1e9ac495a970" name="a1e0413a1dfbd45c6eb9a1e9ac495a970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e0413a1dfbd45c6eb9a1e9ac495a970">&#9670;&#160;</a></span>SetString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetString </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指定位置的 String 类型数据（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的 String 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Set的代理，具体行为参考Set函数的说明 </dd></dl>

</div>
</div>
<a id="a0e47127c0714c1154d1eed9eb7f2e5aa" name="a0e47127c0714c1154d1eed9eb7f2e5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e47127c0714c1154d1eed9eb7f2e5aa">&#9670;&#160;</a></span>SetString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, typename List::iterator, std::pair&lt; typename List::iterator, bool &gt; &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetString </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指定位置的 String 类型数据（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过类型检查，作用与NoCheck_T相同</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szPos</td><td>要设置的位置</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要设置的 String 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回包含迭代器和bool值的pair；否则返回迭代器 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>通用类型函数Set的代理，具体行为参考Set函数的说明 </dd></dl>

</div>
</div>
<a id="a00a65dd7575931753fc8a88b8dff34ad" name="a00a65dd7575931753fc8a88b8dff34ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a65dd7575931753fc8a88b8dff34ad">&#9670;&#160;</a></span>SetTag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<div class="memtemplate">
template&lt;bool bNoCheck = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; bNoCheck, void, bool &gt; <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::SetTag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="NBT__TAG_8hpp.html#ada3a2766daa185b5461d684c766b4a2e">NBT_TAG</a></td>          <td class="paramname"><span class="paramname"><em>tagNewValue</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置列表元素类型 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">bNoCheck</td><td>是否跳过检查，作用与NoCheck_T相同 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">tagNewValue</td><td>新的元素类型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果bNoCheck为false，返回设置是否成功，否则返回void </dd></dl>
<dl class="section note"><dt>注解</dt><dd>在bNoCheck为false的情况下，当且仅当list为空函数才能成功，否则修改失败， 如果bNoCheck为true则必然成功，所以函数返回void，则用于强制修改列表元素类型 </dd></dl>

</div>
</div>
<a id="a23c3ca65d44c65a8d4d08b70ad07248a" name="a23c3ca65d44c65a8d4d08b70ad07248a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23c3ca65d44c65a8d4d08b70ad07248a">&#9670;&#160;</a></span>Size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::Size </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取容器中元素的数量 </p>
<dl class="section return"><dt>返回</dt><dd>容器中元素的数量 </dd></dl>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">类成员变量说明</h2>
<a id="a1df3a5d108843ddc77468ab6876b1fd2" name="a1df3a5d108843ddc77468ab6876b1fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df3a5d108843ddc77468ab6876b1fd2">&#9670;&#160;</a></span>NoCheck</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structNBT__List_1_1NoCheck__T.html">NoCheck_T</a> <a class="el" href="classNBT__List.html">NBT_List</a>&lt; List &gt;::NoCheck {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>提示性标签，用于取消构造函数对类型符合性的检测，类型检查要求列表中所有元素类型一致    </p>
<dl class="section note"><dt>注解</dt><dd>仅用于性能敏感场景，用户需保证类型一致性，否则在NBT_Write进行写出时将产生错误    </dd></dl>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li><a class="el" href="NBT__List_8hpp_source.html">NBT_List.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="classNBT__List.html">NBT_List</a></li>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
