<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>chenjunfu2-nbt-cpp: NBT_Compound&lt; Compound &gt; 模板类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">chenjunfu2-nbt-cpp<span id="projectnumber">&#160;v1.0.3</span>
   </div>
   <div id="projectbrief">一个基于CPP20的NBT(Named Binary Tag)库</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','搜索',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classNBT__Compound.html','','classNBT__Compound-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">NBT_Compound&lt; Compound &gt; 模板类 参考</div></div>
</div><!--header-->
<div class="contents">

<p>继承自标准库std::unordered_map的代理类，用于存储和管理NBT键值对  
 <a href="#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="NBT__Compound_8hpp_source.html">NBT_Compound.hpp</a>&gt;</code></p>
<div class="dynheader">
类 NBT_Compound&lt; Compound &gt; 继承关系图:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classNBT__Compound.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:ab80af5d24c856b4226dd3bcae02b5027" id="r_ab80af5d24c856b4226dd3bcae02b5027"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ab80af5d24c856b4226dd3bcae02b5027 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab80af5d24c856b4226dd3bcae02b5027">NBT_Compound</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab80af5d24c856b4226dd3bcae02b5027"><td class="mdescLeft">&#160;</td><td class="mdescRight">完美转发构造函数  <br /></td></tr>
<tr class="memitem:a0275838da82fb155c2ece6bd313d5779" id="r_a0275838da82fb155c2ece6bd313d5779"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0275838da82fb155c2ece6bd313d5779">NBT_Compound</a> (std::initializer_list&lt; typename Compound::value_type &gt; init)</td></tr>
<tr class="memdesc:a0275838da82fb155c2ece6bd313d5779"><td class="mdescLeft">&#160;</td><td class="mdescRight">初始化列表构造函数  <br /></td></tr>
<tr class="memitem:a15616987b38411976c8dfcf637b26fd2" id="r_a15616987b38411976c8dfcf637b26fd2"><td class="memItemLeft" align="right" valign="top"><a id="a15616987b38411976c8dfcf637b26fd2" name="a15616987b38411976c8dfcf637b26fd2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NBT_Compound</b> (void)=default</td></tr>
<tr class="memdesc:a15616987b38411976c8dfcf637b26fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">默认构造函数 <br /></td></tr>
<tr class="memitem:abde89144c5554eb06271c8d01f620bd6" id="r_abde89144c5554eb06271c8d01f620bd6"><td class="memItemLeft" align="right" valign="top"><a id="abde89144c5554eb06271c8d01f620bd6" name="abde89144c5554eb06271c8d01f620bd6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~NBT_Compound</b> (void)=default</td></tr>
<tr class="memdesc:abde89144c5554eb06271c8d01f620bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">默认析构函数 <br /></td></tr>
<tr class="memitem:a1c1e53eda849634f51a87b409eae667c" id="r_a1c1e53eda849634f51a87b409eae667c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c1e53eda849634f51a87b409eae667c">NBT_Compound</a> (<a class="el" href="classNBT__Compound.html">NBT_Compound</a> &amp;&amp;_Move) noexcept</td></tr>
<tr class="memdesc:a1c1e53eda849634f51a87b409eae667c"><td class="mdescLeft">&#160;</td><td class="mdescRight">移动构造函数  <br /></td></tr>
<tr class="memitem:ab3a27427095b89f44f384e0a4969e23e" id="r_ab3a27427095b89f44f384e0a4969e23e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3a27427095b89f44f384e0a4969e23e">NBT_Compound</a> (const <a class="el" href="classNBT__Compound.html">NBT_Compound</a> &amp;_Copy) noexcept</td></tr>
<tr class="memdesc:ab3a27427095b89f44f384e0a4969e23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">拷贝构造函数  <br /></td></tr>
<tr class="memitem:a2ba93a31d028e00c25220151e56cfbb2" id="r_a2ba93a31d028e00c25220151e56cfbb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Compound.html">NBT_Compound</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ba93a31d028e00c25220151e56cfbb2">operator=</a> (<a class="el" href="classNBT__Compound.html">NBT_Compound</a> &amp;&amp;_Move) noexcept</td></tr>
<tr class="memdesc:a2ba93a31d028e00c25220151e56cfbb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">移动赋值运算符  <br /></td></tr>
<tr class="memitem:a20ac9ea08a74b07827910c5d7aed3652" id="r_a20ac9ea08a74b07827910c5d7aed3652"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Compound.html">NBT_Compound</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20ac9ea08a74b07827910c5d7aed3652">operator=</a> (const <a class="el" href="classNBT__Compound.html">NBT_Compound</a> &amp;_Copy)</td></tr>
<tr class="memdesc:a20ac9ea08a74b07827910c5d7aed3652"><td class="mdescLeft">&#160;</td><td class="mdescRight">拷贝赋值运算符  <br /></td></tr>
<tr class="memitem:a5179c66852b9e8d22fe3ba4c279f45b5" id="r_a5179c66852b9e8d22fe3ba4c279f45b5"><td class="memItemLeft" align="right" valign="top">const Compound &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5179c66852b9e8d22fe3ba4c279f45b5">GetData</a> (void) const noexcept</td></tr>
<tr class="memdesc:a5179c66852b9e8d22fe3ba4c279f45b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取底层容器数据的常量引用  <br /></td></tr>
<tr class="memitem:ab3b6761149366721f803b7490b71c453" id="r_ab3b6761149366721f803b7490b71c453"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3b6761149366721f803b7490b71c453">operator==</a> (const <a class="el" href="classNBT__Compound.html">NBT_Compound</a> &amp;_Right) const noexcept</td></tr>
<tr class="memdesc:ab3b6761149366721f803b7490b71c453"><td class="mdescLeft">&#160;</td><td class="mdescRight">相等比较运算符  <br /></td></tr>
<tr class="memitem:a14298a425fd7d608cb5dfdc7af8f7964" id="r_a14298a425fd7d608cb5dfdc7af8f7964"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14298a425fd7d608cb5dfdc7af8f7964">operator!=</a> (const <a class="el" href="classNBT__Compound.html">NBT_Compound</a> &amp;_Right) const noexcept</td></tr>
<tr class="memdesc:a14298a425fd7d608cb5dfdc7af8f7964"><td class="mdescLeft">&#160;</td><td class="mdescRight">不等比较运算符  <br /></td></tr>
<tr class="memitem:a0fa486d01bcc56c5688fa1ec04b80088" id="r_a0fa486d01bcc56c5688fa1ec04b80088"><td class="memItemLeft" align="right" valign="top">std::partial_ordering&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fa486d01bcc56c5688fa1ec04b80088">operator&lt;=&gt;</a> (const <a class="el" href="classNBT__Compound.html">NBT_Compound</a> &amp;_Right) const noexcept</td></tr>
<tr class="memdesc:a0fa486d01bcc56c5688fa1ec04b80088"><td class="mdescLeft">&#160;</td><td class="mdescRight">三路比较运算符  <br /></td></tr>
<tr class="memitem:a3d5ecf8fcdc474f3daef41aeb131ccef" id="r_a3d5ecf8fcdc474f3daef41aeb131ccef"><td class="memItemLeft" align="right" valign="top">Compound::mapped_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d5ecf8fcdc474f3daef41aeb131ccef">Get</a> (const typename Compound::key_type &amp;sTagName)</td></tr>
<tr class="memdesc:a3d5ecf8fcdc474f3daef41aeb131ccef"><td class="mdescLeft">&#160;</td><td class="mdescRight">根据标签名获取对应的NBT值  <br /></td></tr>
<tr class="memitem:a6b1029565d717d63724dccb698721703" id="r_a6b1029565d717d63724dccb698721703"><td class="memItemLeft" align="right" valign="top">const Compound::mapped_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b1029565d717d63724dccb698721703">Get</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:a6b1029565d717d63724dccb698721703"><td class="mdescLeft">&#160;</td><td class="mdescRight">根据标签名获取对应的NBT值（常量版本）  <br /></td></tr>
<tr class="memitem:ac05d337c1c881ded7408bd9674079f5f" id="r_ac05d337c1c881ded7408bd9674079f5f"><td class="memItemLeft" align="right" valign="top">Compound::mapped_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac05d337c1c881ded7408bd9674079f5f">Has</a> (const typename Compound::key_type &amp;sTagName) noexcept</td></tr>
<tr class="memdesc:ac05d337c1c881ded7408bd9674079f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">搜索标签是否存在  <br /></td></tr>
<tr class="memitem:a619c60233d9f9bf1613e082d4db0b888" id="r_a619c60233d9f9bf1613e082d4db0b888"><td class="memItemLeft" align="right" valign="top">const Compound::mapped_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a619c60233d9f9bf1613e082d4db0b888">Has</a> (const typename Compound::key_type &amp;sTagName) const noexcept</td></tr>
<tr class="memdesc:a619c60233d9f9bf1613e082d4db0b888"><td class="mdescLeft">&#160;</td><td class="mdescRight">搜索标签是否存在（常量版本）  <br /></td></tr>
<tr class="memitem:a3f853b4f1ffd45ea41e8671b1e8f18bc" id="r_a3f853b4f1ffd45ea41e8671b1e8f18bc"><td class="memTemplParams" colspan="2">template&lt;typename K, typename V&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt; &amp;&amp;std::constructible_from&lt;typename Compound::mapped_type, V &amp;&amp;&gt;</td></tr>
<tr class="memitem:a3f853b4f1ffd45ea41e8671b1e8f18bc template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f853b4f1ffd45ea41e8671b1e8f18bc">Put</a> (K &amp;&amp;sTagName, V &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a3f853b4f1ffd45ea41e8671b1e8f18bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换键值对  <br /></td></tr>
<tr class="memitem:a3b9392db95dee4f687be620a5be32b4b" id="r_a3b9392db95dee4f687be620a5be32b4b"><td class="memTemplParams" colspan="2">template&lt;typename K, typename V&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt; &amp;&amp;std::constructible_from&lt;typename Compound::mapped_type, V &amp;&amp;&gt;</td></tr>
<tr class="memitem:a3b9392db95dee4f687be620a5be32b4b template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b9392db95dee4f687be620a5be32b4b">TryPut</a> (K &amp;&amp;sTagName, V &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a3b9392db95dee4f687be620a5be32b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">原位构造键值对  <br /></td></tr>
<tr class="memitem:af55b9238e41a777d8971a58de3134877" id="r_af55b9238e41a777d8971a58de3134877"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af55b9238e41a777d8971a58de3134877">Remove</a> (const typename Compound::key_type &amp;sTagName)</td></tr>
<tr class="memdesc:af55b9238e41a777d8971a58de3134877"><td class="mdescLeft">&#160;</td><td class="mdescRight">删除指定标签  <br /></td></tr>
<tr class="memitem:a11ae318e17ba5b0a5a0a075701f27b44" id="r_a11ae318e17ba5b0a5a0a075701f27b44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11ae318e17ba5b0a5a0a075701f27b44">Clear</a> (void)</td></tr>
<tr class="memdesc:a11ae318e17ba5b0a5a0a075701f27b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">清空所有标签  <br /></td></tr>
<tr class="memitem:a8056943fb5c10dea13e72f8e82532567" id="r_a8056943fb5c10dea13e72f8e82532567"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8056943fb5c10dea13e72f8e82532567">Empty</a> (void) const noexcept</td></tr>
<tr class="memdesc:a8056943fb5c10dea13e72f8e82532567"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查容器是否为空  <br /></td></tr>
<tr class="memitem:a5449c52e28ba84e4e5ab7e207784cf2b" id="r_a5449c52e28ba84e4e5ab7e207784cf2b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5449c52e28ba84e4e5ab7e207784cf2b">Size</a> (void) const noexcept</td></tr>
<tr class="memdesc:a5449c52e28ba84e4e5ab7e207784cf2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取容器中元素的数量  <br /></td></tr>
<tr class="memitem:ae6adf10c9807a2b2bfb46f6caeafad35" id="r_ae6adf10c9807a2b2bfb46f6caeafad35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6adf10c9807a2b2bfb46f6caeafad35">Merge</a> (const <a class="el" href="classNBT__Compound.html">NBT_Compound</a> &amp;_Copy)</td></tr>
<tr class="memdesc:ae6adf10c9807a2b2bfb46f6caeafad35"><td class="mdescLeft">&#160;</td><td class="mdescRight">合并另一个NBT_Compound的内容（拷贝）  <br /></td></tr>
<tr class="memitem:a40fc8cef70215966cc8c52216cd8dfad" id="r_a40fc8cef70215966cc8c52216cd8dfad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40fc8cef70215966cc8c52216cd8dfad">Merge</a> (<a class="el" href="classNBT__Compound.html">NBT_Compound</a> &amp;&amp;_Move)</td></tr>
<tr class="memdesc:a40fc8cef70215966cc8c52216cd8dfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">合并另一个NBT_Compound的内容（移动）  <br /></td></tr>
<tr class="memitem:a8d29e5604d49149e5851bc1308abc475" id="r_a8d29e5604d49149e5851bc1308abc475"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d29e5604d49149e5851bc1308abc475">Contains</a> (const typename Compound::key_type &amp;sTagName) const noexcept</td></tr>
<tr class="memdesc:a8d29e5604d49149e5851bc1308abc475"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查是否包含指定标签  <br /></td></tr>
<tr class="memitem:ac1608a0c58243e1547981933e2686cb2" id="r_ac1608a0c58243e1547981933e2686cb2"><td class="memTemplParams" colspan="2">template&lt;typename Predicate&gt; </td></tr>
<tr class="memitem:ac1608a0c58243e1547981933e2686cb2 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1608a0c58243e1547981933e2686cb2">ContainsIf</a> (Predicate pred) const noexcept</td></tr>
<tr class="memdesc:ac1608a0c58243e1547981933e2686cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">使用谓词检查是否存在满足条件的元素  <br /></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">针对每种类型提供一个方便使用的函数，由宏批量生成</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>具体作用说明：</p>
<ul>
<li>Get开头+类型名的函数：直接获取指定标签名且对应类型的引用，异常由std::unordered_map的at与std::get具体实现决定</li>
<li>Has开头 + 类型名的函数：判断指定标签名是否存在，且标签名对应的类型是否是指定类型，都符合则返回对应指针，否则返回NULL指针 </li>
</ul>
</div></td></tr>
<tr class="memitem:a7ff7630c736028eb5aa9faa65a957741" id="r_a7ff7630c736028eb5aa9faa65a957741"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ff7630c736028eb5aa9faa65a957741">ContainsEnd</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:a7ff7630c736028eb5aa9faa65a957741"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查是否包含指定标签名的 End 类型数据  <br /></td></tr>
<tr class="memitem:a4b607f16656439ccbb9af7cdf42f43f5" id="r_a4b607f16656439ccbb9af7cdf42f43f5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b607f16656439ccbb9af7cdf42f43f5">GetEnd</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:a4b607f16656439ccbb9af7cdf42f43f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定标签名的 End 类型数据（常量版本）  <br /></td></tr>
<tr class="memitem:a34cd55b3acf913109857785cdfdc7521" id="r_a34cd55b3acf913109857785cdfdc7521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34cd55b3acf913109857785cdfdc7521">GetEnd</a> (const typename Compound::key_type &amp;sTagName)</td></tr>
<tr class="memdesc:a34cd55b3acf913109857785cdfdc7521"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定标签名的 End 类型数据  <br /></td></tr>
<tr class="memitem:af6afeaa148af3f71021811b5491adada" id="r_af6afeaa148af3f71021811b5491adada"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6afeaa148af3f71021811b5491adada">HasEnd</a> (const typename Compound::key_type &amp;sTagName) const noexcept</td></tr>
<tr class="memdesc:af6afeaa148af3f71021811b5491adada"><td class="mdescLeft">&#160;</td><td class="mdescRight">安全检查并获取指定标签名的 End 类型数据（常量版本）  <br /></td></tr>
<tr class="memitem:a57fe08c9964314989a3df362d314a3f1" id="r_a57fe08c9964314989a3df362d314a3f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57fe08c9964314989a3df362d314a3f1">HasEnd</a> (const typename Compound::key_type &amp;sTagName) noexcept</td></tr>
<tr class="memdesc:a57fe08c9964314989a3df362d314a3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">安全检查并获取指定标签名的 End 类型数据  <br /></td></tr>
<tr class="memitem:ad82bbbe37a468c4dcec5e1cd4171299c" id="r_ad82bbbe37a468c4dcec5e1cd4171299c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad82bbbe37a468c4dcec5e1cd4171299c">ContainsByte</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:ad82bbbe37a468c4dcec5e1cd4171299c"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查是否包含指定标签名的 Byte 类型数据  <br /></td></tr>
<tr class="memitem:a1340562ba1f06c37698e5eb82574034a" id="r_a1340562ba1f06c37698e5eb82574034a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1340562ba1f06c37698e5eb82574034a">GetByte</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:a1340562ba1f06c37698e5eb82574034a"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定标签名的 Byte 类型数据（常量版本）  <br /></td></tr>
<tr class="memitem:a4c220fc7f535a194a9cf4279443b4d79" id="r_a4c220fc7f535a194a9cf4279443b4d79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c220fc7f535a194a9cf4279443b4d79">GetByte</a> (const typename Compound::key_type &amp;sTagName)</td></tr>
<tr class="memdesc:a4c220fc7f535a194a9cf4279443b4d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定标签名的 Byte 类型数据  <br /></td></tr>
<tr class="memitem:aefc770a8bb79829088acf2f43931aa53" id="r_aefc770a8bb79829088acf2f43931aa53"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefc770a8bb79829088acf2f43931aa53">HasByte</a> (const typename Compound::key_type &amp;sTagName) const noexcept</td></tr>
<tr class="memdesc:aefc770a8bb79829088acf2f43931aa53"><td class="mdescLeft">&#160;</td><td class="mdescRight">安全检查并获取指定标签名的 Byte 类型数据（常量版本）  <br /></td></tr>
<tr class="memitem:a5ad8b84b40dab1fb04f659d7bc8e5b13" id="r_a5ad8b84b40dab1fb04f659d7bc8e5b13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ad8b84b40dab1fb04f659d7bc8e5b13">HasByte</a> (const typename Compound::key_type &amp;sTagName) noexcept</td></tr>
<tr class="memdesc:a5ad8b84b40dab1fb04f659d7bc8e5b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">安全检查并获取指定标签名的 Byte 类型数据  <br /></td></tr>
<tr class="memitem:ad1fafccf3fbe8b6444f29e9673577be9" id="r_ad1fafccf3fbe8b6444f29e9673577be9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1fafccf3fbe8b6444f29e9673577be9">ContainsShort</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:ad1fafccf3fbe8b6444f29e9673577be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查是否包含指定标签名的 Short 类型数据  <br /></td></tr>
<tr class="memitem:adc831c120e205d07feb99d01777dfc17" id="r_adc831c120e205d07feb99d01777dfc17"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc831c120e205d07feb99d01777dfc17">GetShort</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:adc831c120e205d07feb99d01777dfc17"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定标签名的 Short 类型数据（常量版本）  <br /></td></tr>
<tr class="memitem:a272c02b2c776db56c9d5ed6d6879ee98" id="r_a272c02b2c776db56c9d5ed6d6879ee98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a272c02b2c776db56c9d5ed6d6879ee98">GetShort</a> (const typename Compound::key_type &amp;sTagName)</td></tr>
<tr class="memdesc:a272c02b2c776db56c9d5ed6d6879ee98"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定标签名的 Short 类型数据  <br /></td></tr>
<tr class="memitem:a147b560514e009feed6817e8a5482dea" id="r_a147b560514e009feed6817e8a5482dea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a147b560514e009feed6817e8a5482dea">HasShort</a> (const typename Compound::key_type &amp;sTagName) const noexcept</td></tr>
<tr class="memdesc:a147b560514e009feed6817e8a5482dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">安全检查并获取指定标签名的 Short 类型数据（常量版本）  <br /></td></tr>
<tr class="memitem:af657c9b622ef53d17696b37db132d63f" id="r_af657c9b622ef53d17696b37db132d63f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af657c9b622ef53d17696b37db132d63f">HasShort</a> (const typename Compound::key_type &amp;sTagName) noexcept</td></tr>
<tr class="memdesc:af657c9b622ef53d17696b37db132d63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">安全检查并获取指定标签名的 Short 类型数据  <br /></td></tr>
<tr class="memitem:a5d87587b61f5bb94d9464be4535d6afc" id="r_a5d87587b61f5bb94d9464be4535d6afc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d87587b61f5bb94d9464be4535d6afc">ContainsInt</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:a5d87587b61f5bb94d9464be4535d6afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查是否包含指定标签名的 Int 类型数据  <br /></td></tr>
<tr class="memitem:a30d30c93be7e93a0386688730025f088" id="r_a30d30c93be7e93a0386688730025f088"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30d30c93be7e93a0386688730025f088">GetInt</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:a30d30c93be7e93a0386688730025f088"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定标签名的 Int 类型数据（常量版本）  <br /></td></tr>
<tr class="memitem:ad89d2c200b1eb50c247ce5e85dbce873" id="r_ad89d2c200b1eb50c247ce5e85dbce873"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad89d2c200b1eb50c247ce5e85dbce873">GetInt</a> (const typename Compound::key_type &amp;sTagName)</td></tr>
<tr class="memdesc:ad89d2c200b1eb50c247ce5e85dbce873"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定标签名的 Int 类型数据  <br /></td></tr>
<tr class="memitem:a7c7d979feb1f0e49476b517f20daee58" id="r_a7c7d979feb1f0e49476b517f20daee58"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c7d979feb1f0e49476b517f20daee58">HasInt</a> (const typename Compound::key_type &amp;sTagName) const noexcept</td></tr>
<tr class="memdesc:a7c7d979feb1f0e49476b517f20daee58"><td class="mdescLeft">&#160;</td><td class="mdescRight">安全检查并获取指定标签名的 Int 类型数据（常量版本）  <br /></td></tr>
<tr class="memitem:abde90b8c5155e34166e02ded6c82f1f7" id="r_abde90b8c5155e34166e02ded6c82f1f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abde90b8c5155e34166e02ded6c82f1f7">HasInt</a> (const typename Compound::key_type &amp;sTagName) noexcept</td></tr>
<tr class="memdesc:abde90b8c5155e34166e02ded6c82f1f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">安全检查并获取指定标签名的 Int 类型数据  <br /></td></tr>
<tr class="memitem:a3e9eea1d0ce975e9889812630f9d003a" id="r_a3e9eea1d0ce975e9889812630f9d003a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e9eea1d0ce975e9889812630f9d003a">ContainsLong</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:a3e9eea1d0ce975e9889812630f9d003a"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查是否包含指定标签名的 Long 类型数据  <br /></td></tr>
<tr class="memitem:a454381e6cfbba688e4e3317c76c514fd" id="r_a454381e6cfbba688e4e3317c76c514fd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a454381e6cfbba688e4e3317c76c514fd">GetLong</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:a454381e6cfbba688e4e3317c76c514fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定标签名的 Long 类型数据（常量版本）  <br /></td></tr>
<tr class="memitem:aef80b3a8d9c9f23e22033d9a740d4804" id="r_aef80b3a8d9c9f23e22033d9a740d4804"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef80b3a8d9c9f23e22033d9a740d4804">GetLong</a> (const typename Compound::key_type &amp;sTagName)</td></tr>
<tr class="memdesc:aef80b3a8d9c9f23e22033d9a740d4804"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定标签名的 Long 类型数据  <br /></td></tr>
<tr class="memitem:a753c71c95442129b12006e2e96f552d6" id="r_a753c71c95442129b12006e2e96f552d6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a753c71c95442129b12006e2e96f552d6">HasLong</a> (const typename Compound::key_type &amp;sTagName) const noexcept</td></tr>
<tr class="memdesc:a753c71c95442129b12006e2e96f552d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">安全检查并获取指定标签名的 Long 类型数据（常量版本）  <br /></td></tr>
<tr class="memitem:ac62f5bd0da9290fa5a9bb453501fc2eb" id="r_ac62f5bd0da9290fa5a9bb453501fc2eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac62f5bd0da9290fa5a9bb453501fc2eb">HasLong</a> (const typename Compound::key_type &amp;sTagName) noexcept</td></tr>
<tr class="memdesc:ac62f5bd0da9290fa5a9bb453501fc2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">安全检查并获取指定标签名的 Long 类型数据  <br /></td></tr>
<tr class="memitem:a922762a3648ef7932c990fe1176531d9" id="r_a922762a3648ef7932c990fe1176531d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a922762a3648ef7932c990fe1176531d9">ContainsFloat</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:a922762a3648ef7932c990fe1176531d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查是否包含指定标签名的 Float 类型数据  <br /></td></tr>
<tr class="memitem:a022759a06da04f74f905871cf72a9659" id="r_a022759a06da04f74f905871cf72a9659"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a022759a06da04f74f905871cf72a9659">GetFloat</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:a022759a06da04f74f905871cf72a9659"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定标签名的 Float 类型数据（常量版本）  <br /></td></tr>
<tr class="memitem:a0a5f7bf33c381a5b542236c005c4c887" id="r_a0a5f7bf33c381a5b542236c005c4c887"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a5f7bf33c381a5b542236c005c4c887">GetFloat</a> (const typename Compound::key_type &amp;sTagName)</td></tr>
<tr class="memdesc:a0a5f7bf33c381a5b542236c005c4c887"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定标签名的 Float 类型数据  <br /></td></tr>
<tr class="memitem:a94ca4c28230badd8136c1ba5f08fe565" id="r_a94ca4c28230badd8136c1ba5f08fe565"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94ca4c28230badd8136c1ba5f08fe565">HasFloat</a> (const typename Compound::key_type &amp;sTagName) const noexcept</td></tr>
<tr class="memdesc:a94ca4c28230badd8136c1ba5f08fe565"><td class="mdescLeft">&#160;</td><td class="mdescRight">安全检查并获取指定标签名的 Float 类型数据（常量版本）  <br /></td></tr>
<tr class="memitem:a3882a91c268a5b98a279d28ed906d459" id="r_a3882a91c268a5b98a279d28ed906d459"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3882a91c268a5b98a279d28ed906d459">HasFloat</a> (const typename Compound::key_type &amp;sTagName) noexcept</td></tr>
<tr class="memdesc:a3882a91c268a5b98a279d28ed906d459"><td class="mdescLeft">&#160;</td><td class="mdescRight">安全检查并获取指定标签名的 Float 类型数据  <br /></td></tr>
<tr class="memitem:a7c793dcf540ddad9abdf20129ce1010a" id="r_a7c793dcf540ddad9abdf20129ce1010a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c793dcf540ddad9abdf20129ce1010a">ContainsDouble</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:a7c793dcf540ddad9abdf20129ce1010a"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查是否包含指定标签名的 Double 类型数据  <br /></td></tr>
<tr class="memitem:a9964a36ab631181300397edba81f7d1f" id="r_a9964a36ab631181300397edba81f7d1f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9964a36ab631181300397edba81f7d1f">GetDouble</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:a9964a36ab631181300397edba81f7d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定标签名的 Double 类型数据（常量版本）  <br /></td></tr>
<tr class="memitem:a7fda7a7d85f93e964dd272e8142577fc" id="r_a7fda7a7d85f93e964dd272e8142577fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fda7a7d85f93e964dd272e8142577fc">GetDouble</a> (const typename Compound::key_type &amp;sTagName)</td></tr>
<tr class="memdesc:a7fda7a7d85f93e964dd272e8142577fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定标签名的 Double 类型数据  <br /></td></tr>
<tr class="memitem:a071345c7c1c07635870d4cd2d5e935ff" id="r_a071345c7c1c07635870d4cd2d5e935ff"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a071345c7c1c07635870d4cd2d5e935ff">HasDouble</a> (const typename Compound::key_type &amp;sTagName) const noexcept</td></tr>
<tr class="memdesc:a071345c7c1c07635870d4cd2d5e935ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">安全检查并获取指定标签名的 Double 类型数据（常量版本）  <br /></td></tr>
<tr class="memitem:a681de2649c31566b417851f45414b041" id="r_a681de2649c31566b417851f45414b041"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a681de2649c31566b417851f45414b041">HasDouble</a> (const typename Compound::key_type &amp;sTagName) noexcept</td></tr>
<tr class="memdesc:a681de2649c31566b417851f45414b041"><td class="mdescLeft">&#160;</td><td class="mdescRight">安全检查并获取指定标签名的 Double 类型数据  <br /></td></tr>
<tr class="memitem:ae9682760f3960b6b58333a8662c41338" id="r_ae9682760f3960b6b58333a8662c41338"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9682760f3960b6b58333a8662c41338">ContainsByteArray</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:ae9682760f3960b6b58333a8662c41338"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查是否包含指定标签名的 ByteArray 类型数据  <br /></td></tr>
<tr class="memitem:ada8ef2e474dbcb17459ef4e1438b40e1" id="r_ada8ef2e474dbcb17459ef4e1438b40e1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada8ef2e474dbcb17459ef4e1438b40e1">GetByteArray</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:ada8ef2e474dbcb17459ef4e1438b40e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定标签名的 ByteArray 类型数据（常量版本）  <br /></td></tr>
<tr class="memitem:aa7dbdcbd98d17c99e4532ff43540eafc" id="r_aa7dbdcbd98d17c99e4532ff43540eafc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7dbdcbd98d17c99e4532ff43540eafc">GetByteArray</a> (const typename Compound::key_type &amp;sTagName)</td></tr>
<tr class="memdesc:aa7dbdcbd98d17c99e4532ff43540eafc"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定标签名的 ByteArray 类型数据  <br /></td></tr>
<tr class="memitem:a762477feeeb655e3015b63f50704beef" id="r_a762477feeeb655e3015b63f50704beef"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a762477feeeb655e3015b63f50704beef">HasByteArray</a> (const typename Compound::key_type &amp;sTagName) const noexcept</td></tr>
<tr class="memdesc:a762477feeeb655e3015b63f50704beef"><td class="mdescLeft">&#160;</td><td class="mdescRight">安全检查并获取指定标签名的 ByteArray 类型数据（常量版本）  <br /></td></tr>
<tr class="memitem:a16545c6d6bef0aa2fb90305aebc88df5" id="r_a16545c6d6bef0aa2fb90305aebc88df5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16545c6d6bef0aa2fb90305aebc88df5">HasByteArray</a> (const typename Compound::key_type &amp;sTagName) noexcept</td></tr>
<tr class="memdesc:a16545c6d6bef0aa2fb90305aebc88df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">安全检查并获取指定标签名的 ByteArray 类型数据  <br /></td></tr>
<tr class="memitem:ab1fb82edbe7a54bb94dcd2e064941930" id="r_ab1fb82edbe7a54bb94dcd2e064941930"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1fb82edbe7a54bb94dcd2e064941930">ContainsIntArray</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:ab1fb82edbe7a54bb94dcd2e064941930"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查是否包含指定标签名的 IntArray 类型数据  <br /></td></tr>
<tr class="memitem:a6662d2e9fe4fd2419c027ea65d92ce34" id="r_a6662d2e9fe4fd2419c027ea65d92ce34"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6662d2e9fe4fd2419c027ea65d92ce34">GetIntArray</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:a6662d2e9fe4fd2419c027ea65d92ce34"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定标签名的 IntArray 类型数据（常量版本）  <br /></td></tr>
<tr class="memitem:a64c4e4c5e171e9d578e7f65667e65f31" id="r_a64c4e4c5e171e9d578e7f65667e65f31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64c4e4c5e171e9d578e7f65667e65f31">GetIntArray</a> (const typename Compound::key_type &amp;sTagName)</td></tr>
<tr class="memdesc:a64c4e4c5e171e9d578e7f65667e65f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定标签名的 IntArray 类型数据  <br /></td></tr>
<tr class="memitem:a64cc86ea1b7d789528c507b1ea7b3df7" id="r_a64cc86ea1b7d789528c507b1ea7b3df7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64cc86ea1b7d789528c507b1ea7b3df7">HasIntArray</a> (const typename Compound::key_type &amp;sTagName) const noexcept</td></tr>
<tr class="memdesc:a64cc86ea1b7d789528c507b1ea7b3df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">安全检查并获取指定标签名的 IntArray 类型数据（常量版本）  <br /></td></tr>
<tr class="memitem:af333f033a8b14e15caeec99af6328fd2" id="r_af333f033a8b14e15caeec99af6328fd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af333f033a8b14e15caeec99af6328fd2">HasIntArray</a> (const typename Compound::key_type &amp;sTagName) noexcept</td></tr>
<tr class="memdesc:af333f033a8b14e15caeec99af6328fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">安全检查并获取指定标签名的 IntArray 类型数据  <br /></td></tr>
<tr class="memitem:a366840540d4b75d3f632979fdc1844bc" id="r_a366840540d4b75d3f632979fdc1844bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a366840540d4b75d3f632979fdc1844bc">ContainsLongArray</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:a366840540d4b75d3f632979fdc1844bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查是否包含指定标签名的 LongArray 类型数据  <br /></td></tr>
<tr class="memitem:aa286c9a9caf4cad0bc7b1fc98ca3e806" id="r_aa286c9a9caf4cad0bc7b1fc98ca3e806"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa286c9a9caf4cad0bc7b1fc98ca3e806">GetLongArray</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:aa286c9a9caf4cad0bc7b1fc98ca3e806"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定标签名的 LongArray 类型数据（常量版本）  <br /></td></tr>
<tr class="memitem:a6fd25d1a0f1cee93cd583ff20dbc2f82" id="r_a6fd25d1a0f1cee93cd583ff20dbc2f82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fd25d1a0f1cee93cd583ff20dbc2f82">GetLongArray</a> (const typename Compound::key_type &amp;sTagName)</td></tr>
<tr class="memdesc:a6fd25d1a0f1cee93cd583ff20dbc2f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定标签名的 LongArray 类型数据  <br /></td></tr>
<tr class="memitem:af5a9a362debc8fc7436e71c97d7df1fd" id="r_af5a9a362debc8fc7436e71c97d7df1fd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5a9a362debc8fc7436e71c97d7df1fd">HasLongArray</a> (const typename Compound::key_type &amp;sTagName) const noexcept</td></tr>
<tr class="memdesc:af5a9a362debc8fc7436e71c97d7df1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">安全检查并获取指定标签名的 LongArray 类型数据（常量版本）  <br /></td></tr>
<tr class="memitem:ab3699d1549f430ff83e31cd5d3d03fbe" id="r_ab3699d1549f430ff83e31cd5d3d03fbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3699d1549f430ff83e31cd5d3d03fbe">HasLongArray</a> (const typename Compound::key_type &amp;sTagName) noexcept</td></tr>
<tr class="memdesc:ab3699d1549f430ff83e31cd5d3d03fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">安全检查并获取指定标签名的 LongArray 类型数据  <br /></td></tr>
<tr class="memitem:a46713493383299a8bebafa53983f8867" id="r_a46713493383299a8bebafa53983f8867"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46713493383299a8bebafa53983f8867">ContainsString</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:a46713493383299a8bebafa53983f8867"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查是否包含指定标签名的 String 类型数据  <br /></td></tr>
<tr class="memitem:ab324e609f0ac98617df6e0953082eaa3" id="r_ab324e609f0ac98617df6e0953082eaa3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab324e609f0ac98617df6e0953082eaa3">GetString</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:ab324e609f0ac98617df6e0953082eaa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定标签名的 String 类型数据（常量版本）  <br /></td></tr>
<tr class="memitem:a0a337d6cf1fc13b895b4aa4c764c3a3a" id="r_a0a337d6cf1fc13b895b4aa4c764c3a3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a337d6cf1fc13b895b4aa4c764c3a3a">GetString</a> (const typename Compound::key_type &amp;sTagName)</td></tr>
<tr class="memdesc:a0a337d6cf1fc13b895b4aa4c764c3a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定标签名的 String 类型数据  <br /></td></tr>
<tr class="memitem:a67ba8e12d8455a86cd98a73392eb67bd" id="r_a67ba8e12d8455a86cd98a73392eb67bd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67ba8e12d8455a86cd98a73392eb67bd">HasString</a> (const typename Compound::key_type &amp;sTagName) const noexcept</td></tr>
<tr class="memdesc:a67ba8e12d8455a86cd98a73392eb67bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">安全检查并获取指定标签名的 String 类型数据（常量版本）  <br /></td></tr>
<tr class="memitem:ada9902fea1e06ef14f54c993edf17486" id="r_ada9902fea1e06ef14f54c993edf17486"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada9902fea1e06ef14f54c993edf17486">HasString</a> (const typename Compound::key_type &amp;sTagName) noexcept</td></tr>
<tr class="memdesc:ada9902fea1e06ef14f54c993edf17486"><td class="mdescLeft">&#160;</td><td class="mdescRight">安全检查并获取指定标签名的 String 类型数据  <br /></td></tr>
<tr class="memitem:a0e8b8074fb4b014948dd8134f1ff47b6" id="r_a0e8b8074fb4b014948dd8134f1ff47b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e8b8074fb4b014948dd8134f1ff47b6">ContainsList</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:a0e8b8074fb4b014948dd8134f1ff47b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查是否包含指定标签名的 List 类型数据  <br /></td></tr>
<tr class="memitem:ae942fd3fdfc441ed35485a62da0ed31a" id="r_ae942fd3fdfc441ed35485a62da0ed31a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae942fd3fdfc441ed35485a62da0ed31a">GetList</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:ae942fd3fdfc441ed35485a62da0ed31a"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定标签名的 List 类型数据（常量版本）  <br /></td></tr>
<tr class="memitem:afcbb0dd0a9c7700c392110f5dc75d297" id="r_afcbb0dd0a9c7700c392110f5dc75d297"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcbb0dd0a9c7700c392110f5dc75d297">GetList</a> (const typename Compound::key_type &amp;sTagName)</td></tr>
<tr class="memdesc:afcbb0dd0a9c7700c392110f5dc75d297"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定标签名的 List 类型数据  <br /></td></tr>
<tr class="memitem:a136f72bac8aa5468ef31eddb111e56c1" id="r_a136f72bac8aa5468ef31eddb111e56c1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a136f72bac8aa5468ef31eddb111e56c1">HasList</a> (const typename Compound::key_type &amp;sTagName) const noexcept</td></tr>
<tr class="memdesc:a136f72bac8aa5468ef31eddb111e56c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">安全检查并获取指定标签名的 List 类型数据（常量版本）  <br /></td></tr>
<tr class="memitem:a6a5d16eeadc7f9baca20b3848a47bac0" id="r_a6a5d16eeadc7f9baca20b3848a47bac0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a5d16eeadc7f9baca20b3848a47bac0">HasList</a> (const typename Compound::key_type &amp;sTagName) noexcept</td></tr>
<tr class="memdesc:a6a5d16eeadc7f9baca20b3848a47bac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">安全检查并获取指定标签名的 List 类型数据  <br /></td></tr>
<tr class="memitem:acae2fa7f8ada6aa0605e66e388825287" id="r_acae2fa7f8ada6aa0605e66e388825287"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acae2fa7f8ada6aa0605e66e388825287">ContainsCompound</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:acae2fa7f8ada6aa0605e66e388825287"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查是否包含指定标签名的 Compound 类型数据  <br /></td></tr>
<tr class="memitem:a4c5e37a80b8b29f4036dd6106cee77e2" id="r_a4c5e37a80b8b29f4036dd6106cee77e2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c5e37a80b8b29f4036dd6106cee77e2">GetCompound</a> (const typename Compound::key_type &amp;sTagName) const</td></tr>
<tr class="memdesc:a4c5e37a80b8b29f4036dd6106cee77e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定标签名的 Compound 类型数据（常量版本）  <br /></td></tr>
<tr class="memitem:ade2437d0ff0a8864e77b5dc526d58d10" id="r_ade2437d0ff0a8864e77b5dc526d58d10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade2437d0ff0a8864e77b5dc526d58d10">GetCompound</a> (const typename Compound::key_type &amp;sTagName)</td></tr>
<tr class="memdesc:ade2437d0ff0a8864e77b5dc526d58d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定标签名的 Compound 类型数据  <br /></td></tr>
<tr class="memitem:afc2f65dd527a94103fd5c4a7c9d41f25" id="r_afc2f65dd527a94103fd5c4a7c9d41f25"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc2f65dd527a94103fd5c4a7c9d41f25">HasCompound</a> (const typename Compound::key_type &amp;sTagName) const noexcept</td></tr>
<tr class="memdesc:afc2f65dd527a94103fd5c4a7c9d41f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">安全检查并获取指定标签名的 Compound 类型数据（常量版本）  <br /></td></tr>
<tr class="memitem:a5bafc7cd170841c1f6d763918487f584" id="r_a5bafc7cd170841c1f6d763918487f584"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bafc7cd170841c1f6d763918487f584">HasCompound</a> (const typename Compound::key_type &amp;sTagName) noexcept</td></tr>
<tr class="memdesc:a5bafc7cd170841c1f6d763918487f584"><td class="mdescLeft">&#160;</td><td class="mdescRight">安全检查并获取指定标签名的 Compound 类型数据  <br /></td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">针对每种类型提供插入函数，由宏批量生成</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>具体作用说明：</p>
<ul>
<li>Put开头+类型名的函数：插入指定类型的数据到指定标签名 </li>
</ul>
</div></td></tr>
<tr class="memitem:a28d29885f0087dab56362a70831d16a1" id="r_a28d29885f0087dab56362a70831d16a1"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a28d29885f0087dab56362a70831d16a1 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28d29885f0087dab56362a70831d16a1">PutEnd</a> (K &amp;&amp;sTagName, const typename <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a28d29885f0087dab56362a70831d16a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换 End 类型的键值对（拷贝）  <br /></td></tr>
<tr class="memitem:abcfbb33dbb8f4de25271161b180eba6a" id="r_abcfbb33dbb8f4de25271161b180eba6a"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:abcfbb33dbb8f4de25271161b180eba6a template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcfbb33dbb8f4de25271161b180eba6a">PutEnd</a> (K &amp;&amp;sTagName, typename <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:abcfbb33dbb8f4de25271161b180eba6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换 End 类型的键值对（移动）  <br /></td></tr>
<tr class="memitem:a7556e3513fd0c16329d18137d75ee100" id="r_a7556e3513fd0c16329d18137d75ee100"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a7556e3513fd0c16329d18137d75ee100 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7556e3513fd0c16329d18137d75ee100">TryPutEnd</a> (K &amp;&amp;sTagName, const typename <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a7556e3513fd0c16329d18137d75ee100"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试插入 End 类型的键值对（拷贝）  <br /></td></tr>
<tr class="memitem:a360f96856632f15542c54d5b89cece9c" id="r_a360f96856632f15542c54d5b89cece9c"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a360f96856632f15542c54d5b89cece9c template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a360f96856632f15542c54d5b89cece9c">TryPutEnd</a> (K &amp;&amp;sTagName, typename <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a360f96856632f15542c54d5b89cece9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试插入 End 类型的键值对（移动）  <br /></td></tr>
<tr class="memitem:a9b7c2ab2dd2a970bb95ca8647eb8fc81" id="r_a9b7c2ab2dd2a970bb95ca8647eb8fc81"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a9b7c2ab2dd2a970bb95ca8647eb8fc81 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b7c2ab2dd2a970bb95ca8647eb8fc81">PutByte</a> (K &amp;&amp;sTagName, const typename <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a9b7c2ab2dd2a970bb95ca8647eb8fc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换 Byte 类型的键值对（拷贝）  <br /></td></tr>
<tr class="memitem:a26e58c7716cd0490e7757a8aa71ed76b" id="r_a26e58c7716cd0490e7757a8aa71ed76b"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a26e58c7716cd0490e7757a8aa71ed76b template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26e58c7716cd0490e7757a8aa71ed76b">PutByte</a> (K &amp;&amp;sTagName, typename <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a26e58c7716cd0490e7757a8aa71ed76b"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换 Byte 类型的键值对（移动）  <br /></td></tr>
<tr class="memitem:ae587071b04f7b132bade6d6593833af9" id="r_ae587071b04f7b132bade6d6593833af9"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:ae587071b04f7b132bade6d6593833af9 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae587071b04f7b132bade6d6593833af9">TryPutByte</a> (K &amp;&amp;sTagName, const typename <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:ae587071b04f7b132bade6d6593833af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试插入 Byte 类型的键值对（拷贝）  <br /></td></tr>
<tr class="memitem:affa8bdbbcc1ea6052c29477c873add0a" id="r_affa8bdbbcc1ea6052c29477c873add0a"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:affa8bdbbcc1ea6052c29477c873add0a template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affa8bdbbcc1ea6052c29477c873add0a">TryPutByte</a> (K &amp;&amp;sTagName, typename <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:affa8bdbbcc1ea6052c29477c873add0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试插入 Byte 类型的键值对（移动）  <br /></td></tr>
<tr class="memitem:aa3eb7bb7094a1c772badc492d7a2a3cd" id="r_aa3eb7bb7094a1c772badc492d7a2a3cd"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:aa3eb7bb7094a1c772badc492d7a2a3cd template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3eb7bb7094a1c772badc492d7a2a3cd">PutShort</a> (K &amp;&amp;sTagName, const typename <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:aa3eb7bb7094a1c772badc492d7a2a3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换 Short 类型的键值对（拷贝）  <br /></td></tr>
<tr class="memitem:abc119c7a1239f422a4644916b1847eaf" id="r_abc119c7a1239f422a4644916b1847eaf"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:abc119c7a1239f422a4644916b1847eaf template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc119c7a1239f422a4644916b1847eaf">PutShort</a> (K &amp;&amp;sTagName, typename <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:abc119c7a1239f422a4644916b1847eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换 Short 类型的键值对（移动）  <br /></td></tr>
<tr class="memitem:a9aab20d0d2f83848e377d11a5f521e55" id="r_a9aab20d0d2f83848e377d11a5f521e55"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a9aab20d0d2f83848e377d11a5f521e55 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9aab20d0d2f83848e377d11a5f521e55">TryPutShort</a> (K &amp;&amp;sTagName, const typename <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a9aab20d0d2f83848e377d11a5f521e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试插入 Short 类型的键值对（拷贝）  <br /></td></tr>
<tr class="memitem:a425d319fb6d02cedd2fb2d1d97e2fbfe" id="r_a425d319fb6d02cedd2fb2d1d97e2fbfe"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a425d319fb6d02cedd2fb2d1d97e2fbfe template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a425d319fb6d02cedd2fb2d1d97e2fbfe">TryPutShort</a> (K &amp;&amp;sTagName, typename <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a425d319fb6d02cedd2fb2d1d97e2fbfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试插入 Short 类型的键值对（移动）  <br /></td></tr>
<tr class="memitem:ac002adf0d3f48399cd3b54cd013c50a5" id="r_ac002adf0d3f48399cd3b54cd013c50a5"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:ac002adf0d3f48399cd3b54cd013c50a5 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac002adf0d3f48399cd3b54cd013c50a5">PutInt</a> (K &amp;&amp;sTagName, const typename <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:ac002adf0d3f48399cd3b54cd013c50a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换 Int 类型的键值对（拷贝）  <br /></td></tr>
<tr class="memitem:a1e02ecd14b37c5712382ea25e2b0c36a" id="r_a1e02ecd14b37c5712382ea25e2b0c36a"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a1e02ecd14b37c5712382ea25e2b0c36a template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e02ecd14b37c5712382ea25e2b0c36a">PutInt</a> (K &amp;&amp;sTagName, typename <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a1e02ecd14b37c5712382ea25e2b0c36a"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换 Int 类型的键值对（移动）  <br /></td></tr>
<tr class="memitem:a1d23f9d50c080c67e163ed6c9d82869e" id="r_a1d23f9d50c080c67e163ed6c9d82869e"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a1d23f9d50c080c67e163ed6c9d82869e template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d23f9d50c080c67e163ed6c9d82869e">TryPutInt</a> (K &amp;&amp;sTagName, const typename <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a1d23f9d50c080c67e163ed6c9d82869e"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试插入 Int 类型的键值对（拷贝）  <br /></td></tr>
<tr class="memitem:ab51d912c6c5e23830e020107ea982235" id="r_ab51d912c6c5e23830e020107ea982235"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:ab51d912c6c5e23830e020107ea982235 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab51d912c6c5e23830e020107ea982235">TryPutInt</a> (K &amp;&amp;sTagName, typename <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:ab51d912c6c5e23830e020107ea982235"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试插入 Int 类型的键值对（移动）  <br /></td></tr>
<tr class="memitem:a4e247528fd98728a841a2463a6b3862e" id="r_a4e247528fd98728a841a2463a6b3862e"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a4e247528fd98728a841a2463a6b3862e template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e247528fd98728a841a2463a6b3862e">PutLong</a> (K &amp;&amp;sTagName, const typename <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a4e247528fd98728a841a2463a6b3862e"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换 Long 类型的键值对（拷贝）  <br /></td></tr>
<tr class="memitem:a98951c4f0e9039327c84d770bcb41293" id="r_a98951c4f0e9039327c84d770bcb41293"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a98951c4f0e9039327c84d770bcb41293 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98951c4f0e9039327c84d770bcb41293">PutLong</a> (K &amp;&amp;sTagName, typename <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a98951c4f0e9039327c84d770bcb41293"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换 Long 类型的键值对（移动）  <br /></td></tr>
<tr class="memitem:a2c6e344f78f20e9301cef220594af15d" id="r_a2c6e344f78f20e9301cef220594af15d"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a2c6e344f78f20e9301cef220594af15d template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c6e344f78f20e9301cef220594af15d">TryPutLong</a> (K &amp;&amp;sTagName, const typename <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a2c6e344f78f20e9301cef220594af15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试插入 Long 类型的键值对（拷贝）  <br /></td></tr>
<tr class="memitem:a4a9781f7ecbf5d6d977ff81ddd84a529" id="r_a4a9781f7ecbf5d6d977ff81ddd84a529"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a4a9781f7ecbf5d6d977ff81ddd84a529 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a9781f7ecbf5d6d977ff81ddd84a529">TryPutLong</a> (K &amp;&amp;sTagName, typename <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a4a9781f7ecbf5d6d977ff81ddd84a529"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试插入 Long 类型的键值对（移动）  <br /></td></tr>
<tr class="memitem:a7421c014cb72d5ee627082e7eb74eadb" id="r_a7421c014cb72d5ee627082e7eb74eadb"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a7421c014cb72d5ee627082e7eb74eadb template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7421c014cb72d5ee627082e7eb74eadb">PutFloat</a> (K &amp;&amp;sTagName, const typename <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a7421c014cb72d5ee627082e7eb74eadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换 Float 类型的键值对（拷贝）  <br /></td></tr>
<tr class="memitem:aa31f13d663e6fcbbaaebb707406164dd" id="r_aa31f13d663e6fcbbaaebb707406164dd"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:aa31f13d663e6fcbbaaebb707406164dd template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa31f13d663e6fcbbaaebb707406164dd">PutFloat</a> (K &amp;&amp;sTagName, typename <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:aa31f13d663e6fcbbaaebb707406164dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换 Float 类型的键值对（移动）  <br /></td></tr>
<tr class="memitem:ac23cfc1046dbe4d1b520c3eedcfca7b5" id="r_ac23cfc1046dbe4d1b520c3eedcfca7b5"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:ac23cfc1046dbe4d1b520c3eedcfca7b5 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac23cfc1046dbe4d1b520c3eedcfca7b5">TryPutFloat</a> (K &amp;&amp;sTagName, const typename <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:ac23cfc1046dbe4d1b520c3eedcfca7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试插入 Float 类型的键值对（拷贝）  <br /></td></tr>
<tr class="memitem:a043ffbf8ed0e18ccbeca5a02b7b6854d" id="r_a043ffbf8ed0e18ccbeca5a02b7b6854d"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a043ffbf8ed0e18ccbeca5a02b7b6854d template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a043ffbf8ed0e18ccbeca5a02b7b6854d">TryPutFloat</a> (K &amp;&amp;sTagName, typename <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a043ffbf8ed0e18ccbeca5a02b7b6854d"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试插入 Float 类型的键值对（移动）  <br /></td></tr>
<tr class="memitem:a5295257da9bb2598920e1cb2cf42a8fa" id="r_a5295257da9bb2598920e1cb2cf42a8fa"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a5295257da9bb2598920e1cb2cf42a8fa template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5295257da9bb2598920e1cb2cf42a8fa">PutDouble</a> (K &amp;&amp;sTagName, const typename <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a5295257da9bb2598920e1cb2cf42a8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换 Double 类型的键值对（拷贝）  <br /></td></tr>
<tr class="memitem:a3a11881d712bd23063f12d32673cbdcc" id="r_a3a11881d712bd23063f12d32673cbdcc"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a3a11881d712bd23063f12d32673cbdcc template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a11881d712bd23063f12d32673cbdcc">PutDouble</a> (K &amp;&amp;sTagName, typename <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a3a11881d712bd23063f12d32673cbdcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换 Double 类型的键值对（移动）  <br /></td></tr>
<tr class="memitem:af5d0d462f2a4ef1834c7a33a01935a50" id="r_af5d0d462f2a4ef1834c7a33a01935a50"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:af5d0d462f2a4ef1834c7a33a01935a50 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5d0d462f2a4ef1834c7a33a01935a50">TryPutDouble</a> (K &amp;&amp;sTagName, const typename <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:af5d0d462f2a4ef1834c7a33a01935a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试插入 Double 类型的键值对（拷贝）  <br /></td></tr>
<tr class="memitem:af583d8cd286b024767ad635ab3b74eeb" id="r_af583d8cd286b024767ad635ab3b74eeb"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:af583d8cd286b024767ad635ab3b74eeb template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af583d8cd286b024767ad635ab3b74eeb">TryPutDouble</a> (K &amp;&amp;sTagName, typename <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:af583d8cd286b024767ad635ab3b74eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试插入 Double 类型的键值对（移动）  <br /></td></tr>
<tr class="memitem:a279e52e1788c3fcc5d18c6e368ee1ff6" id="r_a279e52e1788c3fcc5d18c6e368ee1ff6"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a279e52e1788c3fcc5d18c6e368ee1ff6 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a279e52e1788c3fcc5d18c6e368ee1ff6">PutByteArray</a> (K &amp;&amp;sTagName, const typename <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a279e52e1788c3fcc5d18c6e368ee1ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换 ByteArray 类型的键值对（拷贝）  <br /></td></tr>
<tr class="memitem:aa10a25e2efab9ea6e70aa0ad6b04ce26" id="r_aa10a25e2efab9ea6e70aa0ad6b04ce26"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:aa10a25e2efab9ea6e70aa0ad6b04ce26 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa10a25e2efab9ea6e70aa0ad6b04ce26">PutByteArray</a> (K &amp;&amp;sTagName, typename <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:aa10a25e2efab9ea6e70aa0ad6b04ce26"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换 ByteArray 类型的键值对（移动）  <br /></td></tr>
<tr class="memitem:a3763c25398295ccf8825b4912ef1e354" id="r_a3763c25398295ccf8825b4912ef1e354"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a3763c25398295ccf8825b4912ef1e354 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3763c25398295ccf8825b4912ef1e354">TryPutByteArray</a> (K &amp;&amp;sTagName, const typename <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a3763c25398295ccf8825b4912ef1e354"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试插入 ByteArray 类型的键值对（拷贝）  <br /></td></tr>
<tr class="memitem:aa6668692f487712461263cc682d73c0a" id="r_aa6668692f487712461263cc682d73c0a"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:aa6668692f487712461263cc682d73c0a template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6668692f487712461263cc682d73c0a">TryPutByteArray</a> (K &amp;&amp;sTagName, typename <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:aa6668692f487712461263cc682d73c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试插入 ByteArray 类型的键值对（移动）  <br /></td></tr>
<tr class="memitem:ab3c12add9be12cbb685498c26d6686b9" id="r_ab3c12add9be12cbb685498c26d6686b9"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:ab3c12add9be12cbb685498c26d6686b9 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3c12add9be12cbb685498c26d6686b9">PutIntArray</a> (K &amp;&amp;sTagName, const typename <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:ab3c12add9be12cbb685498c26d6686b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换 IntArray 类型的键值对（拷贝）  <br /></td></tr>
<tr class="memitem:aca8bc30d19336f5ac0812bdc6386b346" id="r_aca8bc30d19336f5ac0812bdc6386b346"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:aca8bc30d19336f5ac0812bdc6386b346 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca8bc30d19336f5ac0812bdc6386b346">PutIntArray</a> (K &amp;&amp;sTagName, typename <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:aca8bc30d19336f5ac0812bdc6386b346"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换 IntArray 类型的键值对（移动）  <br /></td></tr>
<tr class="memitem:aeda096fe05df1c07895b0946bf254915" id="r_aeda096fe05df1c07895b0946bf254915"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:aeda096fe05df1c07895b0946bf254915 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeda096fe05df1c07895b0946bf254915">TryPutIntArray</a> (K &amp;&amp;sTagName, const typename <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:aeda096fe05df1c07895b0946bf254915"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试插入 IntArray 类型的键值对（拷贝）  <br /></td></tr>
<tr class="memitem:a0dd63d5f482f8176e20b88c88a0ce78b" id="r_a0dd63d5f482f8176e20b88c88a0ce78b"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a0dd63d5f482f8176e20b88c88a0ce78b template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0dd63d5f482f8176e20b88c88a0ce78b">TryPutIntArray</a> (K &amp;&amp;sTagName, typename <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a0dd63d5f482f8176e20b88c88a0ce78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试插入 IntArray 类型的键值对（移动）  <br /></td></tr>
<tr class="memitem:a7a11ab17f7bdbd6633a72f32910b3dc2" id="r_a7a11ab17f7bdbd6633a72f32910b3dc2"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a7a11ab17f7bdbd6633a72f32910b3dc2 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a11ab17f7bdbd6633a72f32910b3dc2">PutLongArray</a> (K &amp;&amp;sTagName, const typename <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a7a11ab17f7bdbd6633a72f32910b3dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换 LongArray 类型的键值对（拷贝）  <br /></td></tr>
<tr class="memitem:aaf7e994ea21ec09f2b4e2b19d1ee53f9" id="r_aaf7e994ea21ec09f2b4e2b19d1ee53f9"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:aaf7e994ea21ec09f2b4e2b19d1ee53f9 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf7e994ea21ec09f2b4e2b19d1ee53f9">PutLongArray</a> (K &amp;&amp;sTagName, typename <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:aaf7e994ea21ec09f2b4e2b19d1ee53f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换 LongArray 类型的键值对（移动）  <br /></td></tr>
<tr class="memitem:a9ce2c49f7bfcb592f1be5cde66ad2add" id="r_a9ce2c49f7bfcb592f1be5cde66ad2add"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a9ce2c49f7bfcb592f1be5cde66ad2add template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ce2c49f7bfcb592f1be5cde66ad2add">TryPutLongArray</a> (K &amp;&amp;sTagName, const typename <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a9ce2c49f7bfcb592f1be5cde66ad2add"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试插入 LongArray 类型的键值对（拷贝）  <br /></td></tr>
<tr class="memitem:a5c753db05f49bca291588003558eef4e" id="r_a5c753db05f49bca291588003558eef4e"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a5c753db05f49bca291588003558eef4e template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c753db05f49bca291588003558eef4e">TryPutLongArray</a> (K &amp;&amp;sTagName, typename <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a5c753db05f49bca291588003558eef4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试插入 LongArray 类型的键值对（移动）  <br /></td></tr>
<tr class="memitem:a100531ab11aad918b852977fbfd37808" id="r_a100531ab11aad918b852977fbfd37808"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a100531ab11aad918b852977fbfd37808 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a100531ab11aad918b852977fbfd37808">PutString</a> (K &amp;&amp;sTagName, const typename <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a100531ab11aad918b852977fbfd37808"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换 String 类型的键值对（拷贝）  <br /></td></tr>
<tr class="memitem:a006acc33e043248f771161af74a4b8c6" id="r_a006acc33e043248f771161af74a4b8c6"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a006acc33e043248f771161af74a4b8c6 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a006acc33e043248f771161af74a4b8c6">PutString</a> (K &amp;&amp;sTagName, typename <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a006acc33e043248f771161af74a4b8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换 String 类型的键值对（移动）  <br /></td></tr>
<tr class="memitem:aa63e7ce495c39ac232b34048f3793b53" id="r_aa63e7ce495c39ac232b34048f3793b53"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:aa63e7ce495c39ac232b34048f3793b53 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa63e7ce495c39ac232b34048f3793b53">TryPutString</a> (K &amp;&amp;sTagName, const typename <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:aa63e7ce495c39ac232b34048f3793b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试插入 String 类型的键值对（拷贝）  <br /></td></tr>
<tr class="memitem:ae982961528a1f3d222fd6bcedced6860" id="r_ae982961528a1f3d222fd6bcedced6860"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:ae982961528a1f3d222fd6bcedced6860 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae982961528a1f3d222fd6bcedced6860">TryPutString</a> (K &amp;&amp;sTagName, typename <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:ae982961528a1f3d222fd6bcedced6860"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试插入 String 类型的键值对（移动）  <br /></td></tr>
<tr class="memitem:ab2bd20e56c3011c87993ed11243661f5" id="r_ab2bd20e56c3011c87993ed11243661f5"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:ab2bd20e56c3011c87993ed11243661f5 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2bd20e56c3011c87993ed11243661f5">PutList</a> (K &amp;&amp;sTagName, const typename <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:ab2bd20e56c3011c87993ed11243661f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换 List 类型的键值对（拷贝）  <br /></td></tr>
<tr class="memitem:a78e4b7574c8fa18745b85dcfddaa72e8" id="r_a78e4b7574c8fa18745b85dcfddaa72e8"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a78e4b7574c8fa18745b85dcfddaa72e8 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78e4b7574c8fa18745b85dcfddaa72e8">PutList</a> (K &amp;&amp;sTagName, typename <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a78e4b7574c8fa18745b85dcfddaa72e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换 List 类型的键值对（移动）  <br /></td></tr>
<tr class="memitem:a8e63d0ded95262538acff8ea7f6a01d1" id="r_a8e63d0ded95262538acff8ea7f6a01d1"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a8e63d0ded95262538acff8ea7f6a01d1 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e63d0ded95262538acff8ea7f6a01d1">TryPutList</a> (K &amp;&amp;sTagName, const typename <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a8e63d0ded95262538acff8ea7f6a01d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试插入 List 类型的键值对（拷贝）  <br /></td></tr>
<tr class="memitem:a0c03308bd7e380460e4057777e64f093" id="r_a0c03308bd7e380460e4057777e64f093"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a0c03308bd7e380460e4057777e64f093 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c03308bd7e380460e4057777e64f093">TryPutList</a> (K &amp;&amp;sTagName, typename <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a0c03308bd7e380460e4057777e64f093"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试插入 List 类型的键值对（移动）  <br /></td></tr>
<tr class="memitem:a8efadcf2bd59f76694e46c3e0ab86faf" id="r_a8efadcf2bd59f76694e46c3e0ab86faf"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a8efadcf2bd59f76694e46c3e0ab86faf template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8efadcf2bd59f76694e46c3e0ab86faf">PutCompound</a> (K &amp;&amp;sTagName, const typename <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a8efadcf2bd59f76694e46c3e0ab86faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换 Compound 类型的键值对（拷贝）  <br /></td></tr>
<tr class="memitem:ac7ea63ca63f7d4a7edbdf5fb95995886" id="r_ac7ea63ca63f7d4a7edbdf5fb95995886"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:ac7ea63ca63f7d4a7edbdf5fb95995886 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7ea63ca63f7d4a7edbdf5fb95995886">PutCompound</a> (K &amp;&amp;sTagName, typename <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:ac7ea63ca63f7d4a7edbdf5fb95995886"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入或替换 Compound 类型的键值对（移动）  <br /></td></tr>
<tr class="memitem:a46f9ed192c2297471a8c9d4fdd497393" id="r_a46f9ed192c2297471a8c9d4fdd497393"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a46f9ed192c2297471a8c9d4fdd497393 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46f9ed192c2297471a8c9d4fdd497393">TryPutCompound</a> (K &amp;&amp;sTagName, const typename <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;vTagVal)</td></tr>
<tr class="memdesc:a46f9ed192c2297471a8c9d4fdd497393"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试插入 Compound 类型的键值对（拷贝）  <br /></td></tr>
<tr class="memitem:a0d862516526c2c2f5b0e272aff135b7b" id="r_a0d862516526c2c2f5b0e272aff135b7b"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</td></tr>
<tr class="memitem:a0d862516526c2c2f5b0e272aff135b7b template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename Compound::iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d862516526c2c2f5b0e272aff135b7b">TryPutCompound</a> (K &amp;&amp;sTagName, typename <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;&amp;vTagVal)</td></tr>
<tr class="memdesc:a0d862516526c2c2f5b0e272aff135b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试插入 Compound 类型的键值对（移动）  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-friends" class="groupheader"><a id="friends" name="friends"></a>
友元</h2></td></tr>
<tr class="memitem:a7bc260970fa83d84a5f90ce08fb18bad" id="r_a7bc260970fa83d84a5f90ce08fb18bad"><td class="memItemLeft" align="right" valign="top"><a id="a7bc260970fa83d84a5f90ce08fb18bad" name="a7bc260970fa83d84a5f90ce08fb18bad"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>NBT_Reader</b></td></tr>
<tr class="memitem:a228bee3eab89fadd3a563856e2983ec7" id="r_a228bee3eab89fadd3a563856e2983ec7"><td class="memItemLeft" align="right" valign="top"><a id="a228bee3eab89fadd3a563856e2983ec7" name="a228bee3eab89fadd3a563856e2983ec7"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>NBT_Writer</b></td></tr>
<tr class="memitem:a01c82892359b4eea5e23efb59810eb29" id="r_a01c82892359b4eea5e23efb59810eb29"><td class="memItemLeft" align="right" valign="top"><a id="a01c82892359b4eea5e23efb59810eb29" name="a01c82892359b4eea5e23efb59810eb29"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>NBT_Helper</b></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">详细描述</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Compound&gt;<br />
class NBT_Compound&lt; Compound &gt;</div><p>继承自标准库std::unordered_map的代理类，用于存储和管理NBT键值对 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Compound</td><td>继承的父类，也就是std::unordered_map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>用户不应自行实例化此类，请使用NBT_Type::Compound来访问此类实例化类型 </dd></dl>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">构造及析构函数说明</h2>
<a id="ab80af5d24c856b4226dd3bcae02b5027" name="ab80af5d24c856b4226dd3bcae02b5027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80af5d24c856b4226dd3bcae02b5027">&#9670;&#160;</a></span>NBT_Compound() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::NBT_Compound </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>完美转发构造函数 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>构造参数类型包 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>构造参数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>将参数完美转发给底层容器进行构造 </dd></dl>

</div>
</div>
<a id="a0275838da82fb155c2ece6bd313d5779" name="a0275838da82fb155c2ece6bd313d5779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0275838da82fb155c2ece6bd313d5779">&#9670;&#160;</a></span>NBT_Compound() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::NBT_Compound </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; typename Compound::value_type &gt;</td>          <td class="paramname"><span class="paramname"><em>init</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>初始化列表构造函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>初始化列表，包含要初始化的键值对 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>使用初始化列表直接构造底层容器 </dd></dl>

</div>
</div>
<a id="a1c1e53eda849634f51a87b409eae667c" name="a1c1e53eda849634f51a87b409eae667c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1e53eda849634f51a87b409eae667c">&#9670;&#160;</a></span>NBT_Compound() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::NBT_Compound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>_Move</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>移动构造函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Move</td><td>要移动的源对象 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3a27427095b89f44f384e0a4969e23e" name="ab3a27427095b89f44f384e0a4969e23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a27427095b89f44f384e0a4969e23e">&#9670;&#160;</a></span>NBT_Compound() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::NBT_Compound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_Copy</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>拷贝构造函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Copy</td><td>要拷贝的源对象 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">成员函数说明</h2>
<a id="a11ae318e17ba5b0a5a0a075701f27b44" name="a11ae318e17ba5b0a5a0a075701f27b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ae318e17ba5b0a5a0a075701f27b44">&#9670;&#160;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::Clear </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>清空所有标签 </p>
<dl class="section note"><dt>注解</dt><dd>移除容器中的所有键值对，容器大小变为0 </dd></dl>

</div>
</div>
<a id="a8d29e5604d49149e5851bc1308abc475" name="a8d29e5604d49149e5851bc1308abc475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d29e5604d49149e5851bc1308abc475">&#9670;&#160;</a></span>Contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::Contains </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>检查是否包含指定标签 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>要检查的标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果包含指定标签返回true，否则返回false </dd></dl>

</div>
</div>
<a id="ad82bbbe37a468c4dcec5e1cd4171299c" name="ad82bbbe37a468c4dcec5e1cd4171299c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82bbbe37a468c4dcec5e1cd4171299c">&#9670;&#160;</a></span>ContainsByte()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::ContainsByte </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>检查是否包含指定标签名的 Byte 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>要检查的标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果包含指定标签名，且对应的值的类型匹配，则返回true，否则返回false </dd></dl>
<dl class="section note"><dt>注解</dt><dd>同时检查标签存在性和值类型 </dd></dl>

</div>
</div>
<a id="ae9682760f3960b6b58333a8662c41338" name="ae9682760f3960b6b58333a8662c41338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9682760f3960b6b58333a8662c41338">&#9670;&#160;</a></span>ContainsByteArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::ContainsByteArray </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>检查是否包含指定标签名的 ByteArray 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>要检查的标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果包含指定标签名，且对应的值的类型匹配，则返回true，否则返回false </dd></dl>
<dl class="section note"><dt>注解</dt><dd>同时检查标签存在性和值类型 </dd></dl>

</div>
</div>
<a id="acae2fa7f8ada6aa0605e66e388825287" name="acae2fa7f8ada6aa0605e66e388825287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae2fa7f8ada6aa0605e66e388825287">&#9670;&#160;</a></span>ContainsCompound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::ContainsCompound </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>检查是否包含指定标签名的 Compound 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>要检查的标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果包含指定标签名，且对应的值的类型匹配，则返回true，否则返回false </dd></dl>
<dl class="section note"><dt>注解</dt><dd>同时检查标签存在性和值类型 </dd></dl>

</div>
</div>
<a id="a7c793dcf540ddad9abdf20129ce1010a" name="a7c793dcf540ddad9abdf20129ce1010a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c793dcf540ddad9abdf20129ce1010a">&#9670;&#160;</a></span>ContainsDouble()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::ContainsDouble </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>检查是否包含指定标签名的 Double 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>要检查的标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果包含指定标签名，且对应的值的类型匹配，则返回true，否则返回false </dd></dl>
<dl class="section note"><dt>注解</dt><dd>同时检查标签存在性和值类型 </dd></dl>

</div>
</div>
<a id="a7ff7630c736028eb5aa9faa65a957741" name="a7ff7630c736028eb5aa9faa65a957741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff7630c736028eb5aa9faa65a957741">&#9670;&#160;</a></span>ContainsEnd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::ContainsEnd </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>检查是否包含指定标签名的 End 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>要检查的标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果包含指定标签名，且对应的值的类型匹配，则返回true，否则返回false </dd></dl>
<dl class="section note"><dt>注解</dt><dd>同时检查标签存在性和值类型 </dd></dl>

</div>
</div>
<a id="a922762a3648ef7932c990fe1176531d9" name="a922762a3648ef7932c990fe1176531d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922762a3648ef7932c990fe1176531d9">&#9670;&#160;</a></span>ContainsFloat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::ContainsFloat </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>检查是否包含指定标签名的 Float 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>要检查的标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果包含指定标签名，且对应的值的类型匹配，则返回true，否则返回false </dd></dl>
<dl class="section note"><dt>注解</dt><dd>同时检查标签存在性和值类型 </dd></dl>

</div>
</div>
<a id="ac1608a0c58243e1547981933e2686cb2" name="ac1608a0c58243e1547981933e2686cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1608a0c58243e1547981933e2686cb2">&#9670;&#160;</a></span>ContainsIf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename Predicate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::ContainsIf </td>
          <td>(</td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>pred</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>使用谓词检查是否存在满足条件的元素 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>谓词仿函数类型，需要接受value_type并返回bool </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>谓词仿函数对象 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在满足条件的元素返回true，否则返回false </dd></dl>
<dl class="section note"><dt>注解</dt><dd>具体用法参见标准库针对std::find_if的说明 </dd></dl>

</div>
</div>
<a id="a5d87587b61f5bb94d9464be4535d6afc" name="a5d87587b61f5bb94d9464be4535d6afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d87587b61f5bb94d9464be4535d6afc">&#9670;&#160;</a></span>ContainsInt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::ContainsInt </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>检查是否包含指定标签名的 Int 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>要检查的标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果包含指定标签名，且对应的值的类型匹配，则返回true，否则返回false </dd></dl>
<dl class="section note"><dt>注解</dt><dd>同时检查标签存在性和值类型 </dd></dl>

</div>
</div>
<a id="ab1fb82edbe7a54bb94dcd2e064941930" name="ab1fb82edbe7a54bb94dcd2e064941930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1fb82edbe7a54bb94dcd2e064941930">&#9670;&#160;</a></span>ContainsIntArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::ContainsIntArray </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>检查是否包含指定标签名的 IntArray 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>要检查的标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果包含指定标签名，且对应的值的类型匹配，则返回true，否则返回false </dd></dl>
<dl class="section note"><dt>注解</dt><dd>同时检查标签存在性和值类型 </dd></dl>

</div>
</div>
<a id="a0e8b8074fb4b014948dd8134f1ff47b6" name="a0e8b8074fb4b014948dd8134f1ff47b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8b8074fb4b014948dd8134f1ff47b6">&#9670;&#160;</a></span>ContainsList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::ContainsList </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>检查是否包含指定标签名的 List 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>要检查的标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果包含指定标签名，且对应的值的类型匹配，则返回true，否则返回false </dd></dl>
<dl class="section note"><dt>注解</dt><dd>同时检查标签存在性和值类型 </dd></dl>

</div>
</div>
<a id="a3e9eea1d0ce975e9889812630f9d003a" name="a3e9eea1d0ce975e9889812630f9d003a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e9eea1d0ce975e9889812630f9d003a">&#9670;&#160;</a></span>ContainsLong()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::ContainsLong </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>检查是否包含指定标签名的 Long 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>要检查的标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果包含指定标签名，且对应的值的类型匹配，则返回true，否则返回false </dd></dl>
<dl class="section note"><dt>注解</dt><dd>同时检查标签存在性和值类型 </dd></dl>

</div>
</div>
<a id="a366840540d4b75d3f632979fdc1844bc" name="a366840540d4b75d3f632979fdc1844bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366840540d4b75d3f632979fdc1844bc">&#9670;&#160;</a></span>ContainsLongArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::ContainsLongArray </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>检查是否包含指定标签名的 LongArray 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>要检查的标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果包含指定标签名，且对应的值的类型匹配，则返回true，否则返回false </dd></dl>
<dl class="section note"><dt>注解</dt><dd>同时检查标签存在性和值类型 </dd></dl>

</div>
</div>
<a id="ad1fafccf3fbe8b6444f29e9673577be9" name="ad1fafccf3fbe8b6444f29e9673577be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1fafccf3fbe8b6444f29e9673577be9">&#9670;&#160;</a></span>ContainsShort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::ContainsShort </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>检查是否包含指定标签名的 Short 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>要检查的标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果包含指定标签名，且对应的值的类型匹配，则返回true，否则返回false </dd></dl>
<dl class="section note"><dt>注解</dt><dd>同时检查标签存在性和值类型 </dd></dl>

</div>
</div>
<a id="a46713493383299a8bebafa53983f8867" name="a46713493383299a8bebafa53983f8867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46713493383299a8bebafa53983f8867">&#9670;&#160;</a></span>ContainsString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::ContainsString </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>检查是否包含指定标签名的 String 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>要检查的标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果包含指定标签名，且对应的值的类型匹配，则返回true，否则返回false </dd></dl>
<dl class="section note"><dt>注解</dt><dd>同时检查标签存在性和值类型 </dd></dl>

</div>
</div>
<a id="a8056943fb5c10dea13e72f8e82532567" name="a8056943fb5c10dea13e72f8e82532567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8056943fb5c10dea13e72f8e82532567">&#9670;&#160;</a></span>Empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::Empty </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>检查容器是否为空 </p>
<dl class="section return"><dt>返回</dt><dd>如果容器为空返回true，否则返回false </dd></dl>

</div>
</div>
<a id="a3d5ecf8fcdc474f3daef41aeb131ccef" name="a3d5ecf8fcdc474f3daef41aeb131ccef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d5ecf8fcdc474f3daef41aeb131ccef">&#9670;&#160;</a></span>Get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Compound::mapped_type &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::Get </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>根据标签名获取对应的NBT值 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>要查找的标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>标签名对应的值的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在则抛出异常，具体请参考std::unordered_map关于at的说明 </dd></dl>

</div>
</div>
<a id="a6b1029565d717d63724dccb698721703" name="a6b1029565d717d63724dccb698721703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1029565d717d63724dccb698721703">&#9670;&#160;</a></span>Get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Compound::mapped_type &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::Get </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>根据标签名获取对应的NBT值（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>要查找的标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>标签名对应的值的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在则抛出异常，具体请参考std::unordered_map关于at的说明 </dd></dl>

</div>
</div>
<a id="a4c220fc7f535a194a9cf4279443b4d79" name="a4c220fc7f535a194a9cf4279443b4d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c220fc7f535a194a9cf4279443b4d79">&#9670;&#160;</a></span>GetByte() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetByte </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定标签名的 Byte 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Byte 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在或类型不匹配则抛出异常， 具体请参考std::unordered_map关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a1340562ba1f06c37698e5eb82574034a" name="a1340562ba1f06c37698e5eb82574034a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1340562ba1f06c37698e5eb82574034a">&#9670;&#160;</a></span>GetByte() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetByte </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定标签名的 Byte 类型数据（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Byte 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在或类型不匹配则抛出异常， 具体请参考std::unordered_map关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="aa7dbdcbd98d17c99e4532ff43540eafc" name="aa7dbdcbd98d17c99e4532ff43540eafc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7dbdcbd98d17c99e4532ff43540eafc">&#9670;&#160;</a></span>GetByteArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetByteArray </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定标签名的 ByteArray 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>ByteArray 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在或类型不匹配则抛出异常， 具体请参考std::unordered_map关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="ada8ef2e474dbcb17459ef4e1438b40e1" name="ada8ef2e474dbcb17459ef4e1438b40e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8ef2e474dbcb17459ef4e1438b40e1">&#9670;&#160;</a></span>GetByteArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetByteArray </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定标签名的 ByteArray 类型数据（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>ByteArray 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在或类型不匹配则抛出异常， 具体请参考std::unordered_map关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="ade2437d0ff0a8864e77b5dc526d58d10" name="ade2437d0ff0a8864e77b5dc526d58d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2437d0ff0a8864e77b5dc526d58d10">&#9670;&#160;</a></span>GetCompound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetCompound </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定标签名的 Compound 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Compound 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在或类型不匹配则抛出异常， 具体请参考std::unordered_map关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a4c5e37a80b8b29f4036dd6106cee77e2" name="a4c5e37a80b8b29f4036dd6106cee77e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5e37a80b8b29f4036dd6106cee77e2">&#9670;&#160;</a></span>GetCompound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetCompound </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定标签名的 Compound 类型数据（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Compound 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在或类型不匹配则抛出异常， 具体请参考std::unordered_map关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a5179c66852b9e8d22fe3ba4c279f45b5" name="a5179c66852b9e8d22fe3ba4c279f45b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5179c66852b9e8d22fe3ba4c279f45b5">&#9670;&#160;</a></span>GetData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Compound &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetData </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取底层容器数据的常量引用 </p>
<dl class="section return"><dt>返回</dt><dd>底层容器数据的常量引用 </dd></dl>

</div>
</div>
<a id="a7fda7a7d85f93e964dd272e8142577fc" name="a7fda7a7d85f93e964dd272e8142577fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fda7a7d85f93e964dd272e8142577fc">&#9670;&#160;</a></span>GetDouble() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetDouble </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定标签名的 Double 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Double 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在或类型不匹配则抛出异常， 具体请参考std::unordered_map关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a9964a36ab631181300397edba81f7d1f" name="a9964a36ab631181300397edba81f7d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9964a36ab631181300397edba81f7d1f">&#9670;&#160;</a></span>GetDouble() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetDouble </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定标签名的 Double 类型数据（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Double 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在或类型不匹配则抛出异常， 具体请参考std::unordered_map关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a34cd55b3acf913109857785cdfdc7521" name="a34cd55b3acf913109857785cdfdc7521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34cd55b3acf913109857785cdfdc7521">&#9670;&#160;</a></span>GetEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetEnd </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定标签名的 End 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>End 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在或类型不匹配则抛出异常， 具体请参考std::unordered_map关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a4b607f16656439ccbb9af7cdf42f43f5" name="a4b607f16656439ccbb9af7cdf42f43f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b607f16656439ccbb9af7cdf42f43f5">&#9670;&#160;</a></span>GetEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetEnd </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定标签名的 End 类型数据（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>End 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在或类型不匹配则抛出异常， 具体请参考std::unordered_map关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a0a5f7bf33c381a5b542236c005c4c887" name="a0a5f7bf33c381a5b542236c005c4c887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5f7bf33c381a5b542236c005c4c887">&#9670;&#160;</a></span>GetFloat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetFloat </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定标签名的 Float 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Float 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在或类型不匹配则抛出异常， 具体请参考std::unordered_map关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a022759a06da04f74f905871cf72a9659" name="a022759a06da04f74f905871cf72a9659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022759a06da04f74f905871cf72a9659">&#9670;&#160;</a></span>GetFloat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetFloat </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定标签名的 Float 类型数据（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Float 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在或类型不匹配则抛出异常， 具体请参考std::unordered_map关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="ad89d2c200b1eb50c247ce5e85dbce873" name="ad89d2c200b1eb50c247ce5e85dbce873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad89d2c200b1eb50c247ce5e85dbce873">&#9670;&#160;</a></span>GetInt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetInt </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定标签名的 Int 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Int 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在或类型不匹配则抛出异常， 具体请参考std::unordered_map关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a30d30c93be7e93a0386688730025f088" name="a30d30c93be7e93a0386688730025f088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d30c93be7e93a0386688730025f088">&#9670;&#160;</a></span>GetInt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetInt </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定标签名的 Int 类型数据（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Int 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在或类型不匹配则抛出异常， 具体请参考std::unordered_map关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a64c4e4c5e171e9d578e7f65667e65f31" name="a64c4e4c5e171e9d578e7f65667e65f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c4e4c5e171e9d578e7f65667e65f31">&#9670;&#160;</a></span>GetIntArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetIntArray </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定标签名的 IntArray 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>IntArray 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在或类型不匹配则抛出异常， 具体请参考std::unordered_map关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a6662d2e9fe4fd2419c027ea65d92ce34" name="a6662d2e9fe4fd2419c027ea65d92ce34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6662d2e9fe4fd2419c027ea65d92ce34">&#9670;&#160;</a></span>GetIntArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetIntArray </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定标签名的 IntArray 类型数据（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>IntArray 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在或类型不匹配则抛出异常， 具体请参考std::unordered_map关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="afcbb0dd0a9c7700c392110f5dc75d297" name="afcbb0dd0a9c7700c392110f5dc75d297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcbb0dd0a9c7700c392110f5dc75d297">&#9670;&#160;</a></span>GetList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetList </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定标签名的 List 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>List 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在或类型不匹配则抛出异常， 具体请参考std::unordered_map关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="ae942fd3fdfc441ed35485a62da0ed31a" name="ae942fd3fdfc441ed35485a62da0ed31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae942fd3fdfc441ed35485a62da0ed31a">&#9670;&#160;</a></span>GetList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetList </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定标签名的 List 类型数据（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>List 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在或类型不匹配则抛出异常， 具体请参考std::unordered_map关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="aef80b3a8d9c9f23e22033d9a740d4804" name="aef80b3a8d9c9f23e22033d9a740d4804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef80b3a8d9c9f23e22033d9a740d4804">&#9670;&#160;</a></span>GetLong() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetLong </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定标签名的 Long 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Long 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在或类型不匹配则抛出异常， 具体请参考std::unordered_map关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a454381e6cfbba688e4e3317c76c514fd" name="a454381e6cfbba688e4e3317c76c514fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454381e6cfbba688e4e3317c76c514fd">&#9670;&#160;</a></span>GetLong() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetLong </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定标签名的 Long 类型数据（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Long 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在或类型不匹配则抛出异常， 具体请参考std::unordered_map关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a6fd25d1a0f1cee93cd583ff20dbc2f82" name="a6fd25d1a0f1cee93cd583ff20dbc2f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd25d1a0f1cee93cd583ff20dbc2f82">&#9670;&#160;</a></span>GetLongArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetLongArray </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定标签名的 LongArray 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>LongArray 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在或类型不匹配则抛出异常， 具体请参考std::unordered_map关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="aa286c9a9caf4cad0bc7b1fc98ca3e806" name="aa286c9a9caf4cad0bc7b1fc98ca3e806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa286c9a9caf4cad0bc7b1fc98ca3e806">&#9670;&#160;</a></span>GetLongArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetLongArray </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定标签名的 LongArray 类型数据（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>LongArray 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在或类型不匹配则抛出异常， 具体请参考std::unordered_map关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a272c02b2c776db56c9d5ed6d6879ee98" name="a272c02b2c776db56c9d5ed6d6879ee98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272c02b2c776db56c9d5ed6d6879ee98">&#9670;&#160;</a></span>GetShort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetShort </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定标签名的 Short 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Short 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在或类型不匹配则抛出异常， 具体请参考std::unordered_map关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="adc831c120e205d07feb99d01777dfc17" name="adc831c120e205d07feb99d01777dfc17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc831c120e205d07feb99d01777dfc17">&#9670;&#160;</a></span>GetShort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetShort </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定标签名的 Short 类型数据（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Short 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在或类型不匹配则抛出异常， 具体请参考std::unordered_map关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a0a337d6cf1fc13b895b4aa4c764c3a3a" name="a0a337d6cf1fc13b895b4aa4c764c3a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a337d6cf1fc13b895b4aa4c764c3a3a">&#9670;&#160;</a></span>GetString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetString </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定标签名的 String 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>String 类型数据的引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在或类型不匹配则抛出异常， 具体请参考std::unordered_map关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="ab324e609f0ac98617df6e0953082eaa3" name="ab324e609f0ac98617df6e0953082eaa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab324e609f0ac98617df6e0953082eaa3">&#9670;&#160;</a></span>GetString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::GetString </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定标签名的 String 类型数据（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>String 类型数据的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果标签不存在或类型不匹配则抛出异常， 具体请参考std::unordered_map关于at的说明与std::get的说明 </dd></dl>

</div>
</div>
<a id="a619c60233d9f9bf1613e082d4db0b888" name="a619c60233d9f9bf1613e082d4db0b888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619c60233d9f9bf1613e082d4db0b888">&#9670;&#160;</a></span>Has() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Compound::mapped_type * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::Has </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>搜索标签是否存在（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>要搜索的标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果找到，则返回指向标签名对应的值的常量指针，否则返回NULL指针 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="ac05d337c1c881ded7408bd9674079f5f" name="ac05d337c1c881ded7408bd9674079f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05d337c1c881ded7408bd9674079f5f">&#9670;&#160;</a></span>Has() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Compound::mapped_type * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::Has </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>搜索标签是否存在 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>要搜索的标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果找到，则返回指向标签名对应的值的指针，否则返回NULL指针 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="aefc770a8bb79829088acf2f43931aa53" name="aefc770a8bb79829088acf2f43931aa53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc770a8bb79829088acf2f43931aa53">&#9670;&#160;</a></span>HasByte() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::HasByte </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安全检查并获取指定标签名的 Byte 类型数据（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在且对应值的类型为 Byte 则返回指向数据的常量指针，否则返回NULL </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在或类型不为 Byte 时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="a5ad8b84b40dab1fb04f659d7bc8e5b13" name="a5ad8b84b40dab1fb04f659d7bc8e5b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad8b84b40dab1fb04f659d7bc8e5b13">&#9670;&#160;</a></span>HasByte() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::HasByte </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安全检查并获取指定标签名的 Byte 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在且对应值的类型为 Byte 则返回指向数据的指针，否则返回NULL </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在或类型不为 Byte 时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="a762477feeeb655e3015b63f50704beef" name="a762477feeeb655e3015b63f50704beef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762477feeeb655e3015b63f50704beef">&#9670;&#160;</a></span>HasByteArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::HasByteArray </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安全检查并获取指定标签名的 ByteArray 类型数据（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在且对应值的类型为 ByteArray 则返回指向数据的常量指针，否则返回NULL </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在或类型不为 ByteArray 时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="a16545c6d6bef0aa2fb90305aebc88df5" name="a16545c6d6bef0aa2fb90305aebc88df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16545c6d6bef0aa2fb90305aebc88df5">&#9670;&#160;</a></span>HasByteArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::HasByteArray </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安全检查并获取指定标签名的 ByteArray 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在且对应值的类型为 ByteArray 则返回指向数据的指针，否则返回NULL </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在或类型不为 ByteArray 时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="afc2f65dd527a94103fd5c4a7c9d41f25" name="afc2f65dd527a94103fd5c4a7c9d41f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc2f65dd527a94103fd5c4a7c9d41f25">&#9670;&#160;</a></span>HasCompound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::HasCompound </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安全检查并获取指定标签名的 Compound 类型数据（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在且对应值的类型为 Compound 则返回指向数据的常量指针，否则返回NULL </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在或类型不为 Compound 时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="a5bafc7cd170841c1f6d763918487f584" name="a5bafc7cd170841c1f6d763918487f584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bafc7cd170841c1f6d763918487f584">&#9670;&#160;</a></span>HasCompound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::HasCompound </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安全检查并获取指定标签名的 Compound 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在且对应值的类型为 Compound 则返回指向数据的指针，否则返回NULL </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在或类型不为 Compound 时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="a071345c7c1c07635870d4cd2d5e935ff" name="a071345c7c1c07635870d4cd2d5e935ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a071345c7c1c07635870d4cd2d5e935ff">&#9670;&#160;</a></span>HasDouble() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::HasDouble </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安全检查并获取指定标签名的 Double 类型数据（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在且对应值的类型为 Double 则返回指向数据的常量指针，否则返回NULL </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在或类型不为 Double 时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="a681de2649c31566b417851f45414b041" name="a681de2649c31566b417851f45414b041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681de2649c31566b417851f45414b041">&#9670;&#160;</a></span>HasDouble() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::HasDouble </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安全检查并获取指定标签名的 Double 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在且对应值的类型为 Double 则返回指向数据的指针，否则返回NULL </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在或类型不为 Double 时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="af6afeaa148af3f71021811b5491adada" name="af6afeaa148af3f71021811b5491adada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6afeaa148af3f71021811b5491adada">&#9670;&#160;</a></span>HasEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::HasEnd </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安全检查并获取指定标签名的 End 类型数据（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在且对应值的类型为 End 则返回指向数据的常量指针，否则返回NULL </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在或类型不为 End 时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="a57fe08c9964314989a3df362d314a3f1" name="a57fe08c9964314989a3df362d314a3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57fe08c9964314989a3df362d314a3f1">&#9670;&#160;</a></span>HasEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::HasEnd </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安全检查并获取指定标签名的 End 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在且对应值的类型为 End 则返回指向数据的指针，否则返回NULL </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在或类型不为 End 时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="a94ca4c28230badd8136c1ba5f08fe565" name="a94ca4c28230badd8136c1ba5f08fe565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ca4c28230badd8136c1ba5f08fe565">&#9670;&#160;</a></span>HasFloat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::HasFloat </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安全检查并获取指定标签名的 Float 类型数据（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在且对应值的类型为 Float 则返回指向数据的常量指针，否则返回NULL </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在或类型不为 Float 时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="a3882a91c268a5b98a279d28ed906d459" name="a3882a91c268a5b98a279d28ed906d459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3882a91c268a5b98a279d28ed906d459">&#9670;&#160;</a></span>HasFloat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::HasFloat </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安全检查并获取指定标签名的 Float 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在且对应值的类型为 Float 则返回指向数据的指针，否则返回NULL </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在或类型不为 Float 时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="a7c7d979feb1f0e49476b517f20daee58" name="a7c7d979feb1f0e49476b517f20daee58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7d979feb1f0e49476b517f20daee58">&#9670;&#160;</a></span>HasInt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::HasInt </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安全检查并获取指定标签名的 Int 类型数据（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在且对应值的类型为 Int 则返回指向数据的常量指针，否则返回NULL </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在或类型不为 Int 时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="abde90b8c5155e34166e02ded6c82f1f7" name="abde90b8c5155e34166e02ded6c82f1f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde90b8c5155e34166e02ded6c82f1f7">&#9670;&#160;</a></span>HasInt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::HasInt </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安全检查并获取指定标签名的 Int 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在且对应值的类型为 Int 则返回指向数据的指针，否则返回NULL </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在或类型不为 Int 时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="a64cc86ea1b7d789528c507b1ea7b3df7" name="a64cc86ea1b7d789528c507b1ea7b3df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64cc86ea1b7d789528c507b1ea7b3df7">&#9670;&#160;</a></span>HasIntArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::HasIntArray </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安全检查并获取指定标签名的 IntArray 类型数据（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在且对应值的类型为 IntArray 则返回指向数据的常量指针，否则返回NULL </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在或类型不为 IntArray 时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="af333f033a8b14e15caeec99af6328fd2" name="af333f033a8b14e15caeec99af6328fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af333f033a8b14e15caeec99af6328fd2">&#9670;&#160;</a></span>HasIntArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::HasIntArray </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安全检查并获取指定标签名的 IntArray 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在且对应值的类型为 IntArray 则返回指向数据的指针，否则返回NULL </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在或类型不为 IntArray 时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="a136f72bac8aa5468ef31eddb111e56c1" name="a136f72bac8aa5468ef31eddb111e56c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136f72bac8aa5468ef31eddb111e56c1">&#9670;&#160;</a></span>HasList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::HasList </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安全检查并获取指定标签名的 List 类型数据（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在且对应值的类型为 List 则返回指向数据的常量指针，否则返回NULL </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在或类型不为 List 时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="a6a5d16eeadc7f9baca20b3848a47bac0" name="a6a5d16eeadc7f9baca20b3848a47bac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5d16eeadc7f9baca20b3848a47bac0">&#9670;&#160;</a></span>HasList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::HasList </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安全检查并获取指定标签名的 List 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在且对应值的类型为 List 则返回指向数据的指针，否则返回NULL </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在或类型不为 List 时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="a753c71c95442129b12006e2e96f552d6" name="a753c71c95442129b12006e2e96f552d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753c71c95442129b12006e2e96f552d6">&#9670;&#160;</a></span>HasLong() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::HasLong </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安全检查并获取指定标签名的 Long 类型数据（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在且对应值的类型为 Long 则返回指向数据的常量指针，否则返回NULL </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在或类型不为 Long 时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="ac62f5bd0da9290fa5a9bb453501fc2eb" name="ac62f5bd0da9290fa5a9bb453501fc2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac62f5bd0da9290fa5a9bb453501fc2eb">&#9670;&#160;</a></span>HasLong() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::HasLong </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安全检查并获取指定标签名的 Long 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在且对应值的类型为 Long 则返回指向数据的指针，否则返回NULL </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在或类型不为 Long 时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="af5a9a362debc8fc7436e71c97d7df1fd" name="af5a9a362debc8fc7436e71c97d7df1fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a9a362debc8fc7436e71c97d7df1fd">&#9670;&#160;</a></span>HasLongArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::HasLongArray </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安全检查并获取指定标签名的 LongArray 类型数据（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在且对应值的类型为 LongArray 则返回指向数据的常量指针，否则返回NULL </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在或类型不为 LongArray 时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="ab3699d1549f430ff83e31cd5d3d03fbe" name="ab3699d1549f430ff83e31cd5d3d03fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3699d1549f430ff83e31cd5d3d03fbe">&#9670;&#160;</a></span>HasLongArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::HasLongArray </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安全检查并获取指定标签名的 LongArray 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在且对应值的类型为 LongArray 则返回指向数据的指针，否则返回NULL </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在或类型不为 LongArray 时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="a147b560514e009feed6817e8a5482dea" name="a147b560514e009feed6817e8a5482dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147b560514e009feed6817e8a5482dea">&#9670;&#160;</a></span>HasShort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::HasShort </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安全检查并获取指定标签名的 Short 类型数据（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在且对应值的类型为 Short 则返回指向数据的常量指针，否则返回NULL </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在或类型不为 Short 时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="af657c9b622ef53d17696b37db132d63f" name="af657c9b622ef53d17696b37db132d63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af657c9b622ef53d17696b37db132d63f">&#9670;&#160;</a></span>HasShort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::HasShort </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安全检查并获取指定标签名的 Short 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在且对应值的类型为 Short 则返回指向数据的指针，否则返回NULL </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在或类型不为 Short 时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="a67ba8e12d8455a86cd98a73392eb67bd" name="a67ba8e12d8455a86cd98a73392eb67bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ba8e12d8455a86cd98a73392eb67bd">&#9670;&#160;</a></span>HasString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::HasString </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安全检查并获取指定标签名的 String 类型数据（常量版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在且对应值的类型为 String 则返回指向数据的常量指针，否则返回NULL </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在或类型不为 String 时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="ada9902fea1e06ef14f54c993edf17486" name="ada9902fea1e06ef14f54c993edf17486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9902fea1e06ef14f54c993edf17486">&#9670;&#160;</a></span>HasString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> * <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::HasString </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安全检查并获取指定标签名的 String 类型数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果存在且对应值的类型为 String 则返回指向数据的指针，否则返回NULL </dd></dl>
<dl class="section note"><dt>注解</dt><dd>标签不存在或类型不为 String 时不会抛出异常，适用于检查性访问 </dd></dl>

</div>
</div>
<a id="ae6adf10c9807a2b2bfb46f6caeafad35" name="ae6adf10c9807a2b2bfb46f6caeafad35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6adf10c9807a2b2bfb46f6caeafad35">&#9670;&#160;</a></span>Merge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::Merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_Copy</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>合并另一个NBT_Compound的内容（拷贝） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Copy</td><td>要合并的源对象 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>将源对象的所有键值对合并到当前对象，重复的键不会被覆盖， 具体行为请参考std::unordered_map对于merge的说明 </dd></dl>

</div>
</div>
<a id="a40fc8cef70215966cc8c52216cd8dfad" name="a40fc8cef70215966cc8c52216cd8dfad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40fc8cef70215966cc8c52216cd8dfad">&#9670;&#160;</a></span>Merge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::Merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>_Move</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>合并另一个NBT_Compound的内容（移动） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Move</td><td>要合并的源对象 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>将源对象的所有键值对合并到当前对象，重复的键不会被覆盖， 具体行为请参考std::unordered_map关于merge的说明 </dd></dl>

</div>
</div>
<a id="a14298a425fd7d608cb5dfdc7af8f7964" name="a14298a425fd7d608cb5dfdc7af8f7964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14298a425fd7d608cb5dfdc7af8f7964">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_Right</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>不等比较运算符 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Right</td><td>要比较的右操作数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>是否不相等 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>转发底层容器的实现，具体信息请参考std::unordered_map的说明 </dd></dl>

</div>
</div>
<a id="a0fa486d01bcc56c5688fa1ec04b80088" name="a0fa486d01bcc56c5688fa1ec04b80088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa486d01bcc56c5688fa1ec04b80088">&#9670;&#160;</a></span>operator&lt;=&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::partial_ordering <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_Right</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>三路比较运算符 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Right</td><td>要比较的右操作数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>比较结果，通过std::partial_ordering返回 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果底层容器支持三路比较则转发其实现，否则使用容器的相等运算符比较，在相等时返回equivalent，不相等时返回unordered </dd></dl>

</div>
</div>
<a id="a20ac9ea08a74b07827910c5d7aed3652" name="a20ac9ea08a74b07827910c5d7aed3652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ac9ea08a74b07827910c5d7aed3652">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Compound.html">NBT_Compound</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_Copy</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>拷贝赋值运算符 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Copy</td><td>要拷贝的源对象 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>当前对象的引用 </dd></dl>

</div>
</div>
<a id="a2ba93a31d028e00c25220151e56cfbb2" name="a2ba93a31d028e00c25220151e56cfbb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba93a31d028e00c25220151e56cfbb2">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNBT__Compound.html">NBT_Compound</a> &amp; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>_Move</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>移动赋值运算符 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Move</td><td>要移动的源对象 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>当前对象的引用 </dd></dl>

</div>
</div>
<a id="ab3b6761149366721f803b7490b71c453" name="ab3b6761149366721f803b7490b71c453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b6761149366721f803b7490b71c453">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_Right</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>相等比较运算符 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Right</td><td>要比较的右操作数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>是否相等 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>转发底层容器的实现，具体信息请参考std::unordered_map的说明 </dd></dl>

</div>
</div>
<a id="a3f853b4f1ffd45ea41e8671b1e8f18bc" name="a3f853b4f1ffd45ea41e8671b1e8f18bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f853b4f1ffd45ea41e8671b1e8f18bc">&#9670;&#160;</a></span>Put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K, typename V&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt; &amp;&amp;std::constructible_from&lt;typename Compound::mapped_type, V &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::Put </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换键值对 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type </td></tr>
    <tr><td class="paramname">V</td><td>标签值类型，必须可构造为mapped_type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
    <tr><td class="paramname">vTagVal</td><td>标签名对应的值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a9b7c2ab2dd2a970bb95ca8647eb8fc81" name="a9b7c2ab2dd2a970bb95ca8647eb8fc81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7c2ab2dd2a970bb95ca8647eb8fc81">&#9670;&#160;</a></span>PutByte() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::PutByte </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换 Byte 类型的键值对（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Byte 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a26e58c7716cd0490e7757a8aa71ed76b" name="a26e58c7716cd0490e7757a8aa71ed76b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e58c7716cd0490e7757a8aa71ed76b">&#9670;&#160;</a></span>PutByte() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::PutByte </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换 Byte 类型的键值对（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Byte 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a279e52e1788c3fcc5d18c6e368ee1ff6" name="a279e52e1788c3fcc5d18c6e368ee1ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a279e52e1788c3fcc5d18c6e368ee1ff6">&#9670;&#160;</a></span>PutByteArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::PutByteArray </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换 ByteArray 类型的键值对（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 ByteArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="aa10a25e2efab9ea6e70aa0ad6b04ce26" name="aa10a25e2efab9ea6e70aa0ad6b04ce26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10a25e2efab9ea6e70aa0ad6b04ce26">&#9670;&#160;</a></span>PutByteArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::PutByteArray </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换 ByteArray 类型的键值对（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 ByteArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a8efadcf2bd59f76694e46c3e0ab86faf" name="a8efadcf2bd59f76694e46c3e0ab86faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8efadcf2bd59f76694e46c3e0ab86faf">&#9670;&#160;</a></span>PutCompound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::PutCompound </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换 Compound 类型的键值对（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Compound 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="ac7ea63ca63f7d4a7edbdf5fb95995886" name="ac7ea63ca63f7d4a7edbdf5fb95995886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ea63ca63f7d4a7edbdf5fb95995886">&#9670;&#160;</a></span>PutCompound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::PutCompound </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换 Compound 类型的键值对（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Compound 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a5295257da9bb2598920e1cb2cf42a8fa" name="a5295257da9bb2598920e1cb2cf42a8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5295257da9bb2598920e1cb2cf42a8fa">&#9670;&#160;</a></span>PutDouble() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::PutDouble </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换 Double 类型的键值对（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Double 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a3a11881d712bd23063f12d32673cbdcc" name="a3a11881d712bd23063f12d32673cbdcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a11881d712bd23063f12d32673cbdcc">&#9670;&#160;</a></span>PutDouble() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::PutDouble </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换 Double 类型的键值对（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Double 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a28d29885f0087dab56362a70831d16a1" name="a28d29885f0087dab56362a70831d16a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d29885f0087dab56362a70831d16a1">&#9670;&#160;</a></span>PutEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::PutEnd </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换 End 类型的键值对（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 End 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="abcfbb33dbb8f4de25271161b180eba6a" name="abcfbb33dbb8f4de25271161b180eba6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcfbb33dbb8f4de25271161b180eba6a">&#9670;&#160;</a></span>PutEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::PutEnd </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换 End 类型的键值对（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 End 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a7421c014cb72d5ee627082e7eb74eadb" name="a7421c014cb72d5ee627082e7eb74eadb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7421c014cb72d5ee627082e7eb74eadb">&#9670;&#160;</a></span>PutFloat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::PutFloat </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换 Float 类型的键值对（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Float 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="aa31f13d663e6fcbbaaebb707406164dd" name="aa31f13d663e6fcbbaaebb707406164dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa31f13d663e6fcbbaaebb707406164dd">&#9670;&#160;</a></span>PutFloat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::PutFloat </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换 Float 类型的键值对（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Float 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="ac002adf0d3f48399cd3b54cd013c50a5" name="ac002adf0d3f48399cd3b54cd013c50a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac002adf0d3f48399cd3b54cd013c50a5">&#9670;&#160;</a></span>PutInt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::PutInt </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换 Int 类型的键值对（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Int 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a1e02ecd14b37c5712382ea25e2b0c36a" name="a1e02ecd14b37c5712382ea25e2b0c36a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e02ecd14b37c5712382ea25e2b0c36a">&#9670;&#160;</a></span>PutInt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::PutInt </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换 Int 类型的键值对（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Int 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="ab3c12add9be12cbb685498c26d6686b9" name="ab3c12add9be12cbb685498c26d6686b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c12add9be12cbb685498c26d6686b9">&#9670;&#160;</a></span>PutIntArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::PutIntArray </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换 IntArray 类型的键值对（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 IntArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="aca8bc30d19336f5ac0812bdc6386b346" name="aca8bc30d19336f5ac0812bdc6386b346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8bc30d19336f5ac0812bdc6386b346">&#9670;&#160;</a></span>PutIntArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::PutIntArray </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换 IntArray 类型的键值对（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 IntArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="ab2bd20e56c3011c87993ed11243661f5" name="ab2bd20e56c3011c87993ed11243661f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2bd20e56c3011c87993ed11243661f5">&#9670;&#160;</a></span>PutList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::PutList </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换 List 类型的键值对（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 List 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a78e4b7574c8fa18745b85dcfddaa72e8" name="a78e4b7574c8fa18745b85dcfddaa72e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e4b7574c8fa18745b85dcfddaa72e8">&#9670;&#160;</a></span>PutList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::PutList </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换 List 类型的键值对（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 List 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a4e247528fd98728a841a2463a6b3862e" name="a4e247528fd98728a841a2463a6b3862e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e247528fd98728a841a2463a6b3862e">&#9670;&#160;</a></span>PutLong() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::PutLong </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换 Long 类型的键值对（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Long 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a98951c4f0e9039327c84d770bcb41293" name="a98951c4f0e9039327c84d770bcb41293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98951c4f0e9039327c84d770bcb41293">&#9670;&#160;</a></span>PutLong() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::PutLong </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换 Long 类型的键值对（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Long 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a7a11ab17f7bdbd6633a72f32910b3dc2" name="a7a11ab17f7bdbd6633a72f32910b3dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a11ab17f7bdbd6633a72f32910b3dc2">&#9670;&#160;</a></span>PutLongArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::PutLongArray </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换 LongArray 类型的键值对（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 LongArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="aaf7e994ea21ec09f2b4e2b19d1ee53f9" name="aaf7e994ea21ec09f2b4e2b19d1ee53f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7e994ea21ec09f2b4e2b19d1ee53f9">&#9670;&#160;</a></span>PutLongArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::PutLongArray </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换 LongArray 类型的键值对（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 LongArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="aa3eb7bb7094a1c772badc492d7a2a3cd" name="aa3eb7bb7094a1c772badc492d7a2a3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3eb7bb7094a1c772badc492d7a2a3cd">&#9670;&#160;</a></span>PutShort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::PutShort </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换 Short 类型的键值对（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Short 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="abc119c7a1239f422a4644916b1847eaf" name="abc119c7a1239f422a4644916b1847eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc119c7a1239f422a4644916b1847eaf">&#9670;&#160;</a></span>PutShort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::PutShort </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换 Short 类型的键值对（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Short 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a100531ab11aad918b852977fbfd37808" name="a100531ab11aad918b852977fbfd37808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100531ab11aad918b852977fbfd37808">&#9670;&#160;</a></span>PutString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::PutString </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换 String 类型的键值对（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 String 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a006acc33e043248f771161af74a4b8c6" name="a006acc33e043248f771161af74a4b8c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a006acc33e043248f771161af74a4b8c6">&#9670;&#160;</a></span>PutString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::PutString </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>插入或替换 String 类型的键值对（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 String 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则执行了替换 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="af55b9238e41a777d8971a58de3134877" name="af55b9238e41a777d8971a58de3134877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55b9238e41a777d8971a58de3134877">&#9670;&#160;</a></span>Remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::Remove </td>
          <td>(</td>
          <td class="paramtype">const typename Compound::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>删除指定标签 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>要删除的标签名 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>是否成功删除（标签存在且被删除返回true，否则返回false） </dd></dl>

</div>
</div>
<a id="a5449c52e28ba84e4e5ab7e207784cf2b" name="a5449c52e28ba84e4e5ab7e207784cf2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5449c52e28ba84e4e5ab7e207784cf2b">&#9670;&#160;</a></span>Size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::Size </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取容器中元素的数量 </p>
<dl class="section return"><dt>返回</dt><dd>容器中键值对的数量 </dd></dl>

</div>
</div>
<a id="a3b9392db95dee4f687be620a5be32b4b" name="a3b9392db95dee4f687be620a5be32b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9392db95dee4f687be620a5be32b4b">&#9670;&#160;</a></span>TryPut()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K, typename V&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt; &amp;&amp;std::constructible_from&lt;typename Compound::mapped_type, V &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPut </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>原位构造键值对 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type </td></tr>
    <tr><td class="paramname">V</td><td>标签值类型，必须可构造为mapped_type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名 </td></tr>
    <tr><td class="paramname">vTagVal</td><td>标签名对应的值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="ae587071b04f7b132bade6d6593833af9" name="ae587071b04f7b132bade6d6593833af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae587071b04f7b132bade6d6593833af9">&#9670;&#160;</a></span>TryPutByte() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPutByte </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试插入 Byte 类型的键值对（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Byte 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="affa8bdbbcc1ea6052c29477c873add0a" name="affa8bdbbcc1ea6052c29477c873add0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa8bdbbcc1ea6052c29477c873add0a">&#9670;&#160;</a></span>TryPutByte() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPutByte </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a09b5ce48dffc429ad8a7d05d007741c1">NBT_Type::Byte</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试插入 Byte 类型的键值对（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Byte 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a3763c25398295ccf8825b4912ef1e354" name="a3763c25398295ccf8825b4912ef1e354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3763c25398295ccf8825b4912ef1e354">&#9670;&#160;</a></span>TryPutByteArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPutByteArray </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试插入 ByteArray 类型的键值对（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 ByteArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="aa6668692f487712461263cc682d73c0a" name="aa6668692f487712461263cc682d73c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6668692f487712461263cc682d73c0a">&#9670;&#160;</a></span>TryPutByteArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPutByteArray </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a953bc9e67e1b5d82c0786b5992f00ed8">NBT_Type::ByteArray</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试插入 ByteArray 类型的键值对（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 ByteArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a46f9ed192c2297471a8c9d4fdd497393" name="a46f9ed192c2297471a8c9d4fdd497393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f9ed192c2297471a8c9d4fdd497393">&#9670;&#160;</a></span>TryPutCompound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPutCompound </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试插入 Compound 类型的键值对（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Compound 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a0d862516526c2c2f5b0e272aff135b7b" name="a0d862516526c2c2f5b0e272aff135b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d862516526c2c2f5b0e272aff135b7b">&#9670;&#160;</a></span>TryPutCompound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPutCompound </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a9dcd5050b96a10161f18d7ae4a22e7b3">NBT_Type::Compound</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试插入 Compound 类型的键值对（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Compound 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="af5d0d462f2a4ef1834c7a33a01935a50" name="af5d0d462f2a4ef1834c7a33a01935a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d0d462f2a4ef1834c7a33a01935a50">&#9670;&#160;</a></span>TryPutDouble() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPutDouble </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试插入 Double 类型的键值对（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Double 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="af583d8cd286b024767ad635ab3b74eeb" name="af583d8cd286b024767ad635ab3b74eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af583d8cd286b024767ad635ab3b74eeb">&#9670;&#160;</a></span>TryPutDouble() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPutDouble </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#aaea549797088fb63987679367bc9d39a">NBT_Type::Double</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试插入 Double 类型的键值对（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Double 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a7556e3513fd0c16329d18137d75ee100" name="a7556e3513fd0c16329d18137d75ee100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7556e3513fd0c16329d18137d75ee100">&#9670;&#160;</a></span>TryPutEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPutEnd </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试插入 End 类型的键值对（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 End 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a360f96856632f15542c54d5b89cece9c" name="a360f96856632f15542c54d5b89cece9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360f96856632f15542c54d5b89cece9c">&#9670;&#160;</a></span>TryPutEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPutEnd </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a16ac41e6cfe61a603407221527b6b16c">NBT_Type::End</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试插入 End 类型的键值对（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 End 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="ac23cfc1046dbe4d1b520c3eedcfca7b5" name="ac23cfc1046dbe4d1b520c3eedcfca7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23cfc1046dbe4d1b520c3eedcfca7b5">&#9670;&#160;</a></span>TryPutFloat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPutFloat </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试插入 Float 类型的键值对（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Float 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a043ffbf8ed0e18ccbeca5a02b7b6854d" name="a043ffbf8ed0e18ccbeca5a02b7b6854d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043ffbf8ed0e18ccbeca5a02b7b6854d">&#9670;&#160;</a></span>TryPutFloat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPutFloat </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a8a7ac779b8e8a7fdccb3456844abe5cf">NBT_Type::Float</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试插入 Float 类型的键值对（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Float 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a1d23f9d50c080c67e163ed6c9d82869e" name="a1d23f9d50c080c67e163ed6c9d82869e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d23f9d50c080c67e163ed6c9d82869e">&#9670;&#160;</a></span>TryPutInt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPutInt </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试插入 Int 类型的键值对（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Int 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="ab51d912c6c5e23830e020107ea982235" name="ab51d912c6c5e23830e020107ea982235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab51d912c6c5e23830e020107ea982235">&#9670;&#160;</a></span>TryPutInt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPutInt </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#afee0233d7f58b90cc9ce2b903da2da22">NBT_Type::Int</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试插入 Int 类型的键值对（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Int 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="aeda096fe05df1c07895b0946bf254915" name="aeda096fe05df1c07895b0946bf254915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeda096fe05df1c07895b0946bf254915">&#9670;&#160;</a></span>TryPutIntArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPutIntArray </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试插入 IntArray 类型的键值对（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 IntArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a0dd63d5f482f8176e20b88c88a0ce78b" name="a0dd63d5f482f8176e20b88c88a0ce78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd63d5f482f8176e20b88c88a0ce78b">&#9670;&#160;</a></span>TryPutIntArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPutIntArray </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a9c4ad0b2bcd4b5cafb0c9a3f083f9406">NBT_Type::IntArray</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试插入 IntArray 类型的键值对（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 IntArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a8e63d0ded95262538acff8ea7f6a01d1" name="a8e63d0ded95262538acff8ea7f6a01d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e63d0ded95262538acff8ea7f6a01d1">&#9670;&#160;</a></span>TryPutList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPutList </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试插入 List 类型的键值对（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 List 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a0c03308bd7e380460e4057777e64f093" name="a0c03308bd7e380460e4057777e64f093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c03308bd7e380460e4057777e64f093">&#9670;&#160;</a></span>TryPutList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPutList </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a87b4d71087e5c0ab1111a4999dace42f">NBT_Type::List</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试插入 List 类型的键值对（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 List 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a2c6e344f78f20e9301cef220594af15d" name="a2c6e344f78f20e9301cef220594af15d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6e344f78f20e9301cef220594af15d">&#9670;&#160;</a></span>TryPutLong() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPutLong </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试插入 Long 类型的键值对（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Long 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a4a9781f7ecbf5d6d977ff81ddd84a529" name="a4a9781f7ecbf5d6d977ff81ddd84a529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9781f7ecbf5d6d977ff81ddd84a529">&#9670;&#160;</a></span>TryPutLong() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPutLong </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a7f8ae2e6e2f87445d1e72f7e922ba053">NBT_Type::Long</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试插入 Long 类型的键值对（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Long 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a9ce2c49f7bfcb592f1be5cde66ad2add" name="a9ce2c49f7bfcb592f1be5cde66ad2add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce2c49f7bfcb592f1be5cde66ad2add">&#9670;&#160;</a></span>TryPutLongArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPutLongArray </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试插入 LongArray 类型的键值对（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 LongArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a5c753db05f49bca291588003558eef4e" name="a5c753db05f49bca291588003558eef4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c753db05f49bca291588003558eef4e">&#9670;&#160;</a></span>TryPutLongArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPutLongArray </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#aa2c61028536166272869c3bbc91d3197">NBT_Type::LongArray</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试插入 LongArray 类型的键值对（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 LongArray 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a9aab20d0d2f83848e377d11a5f521e55" name="a9aab20d0d2f83848e377d11a5f521e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aab20d0d2f83848e377d11a5f521e55">&#9670;&#160;</a></span>TryPutShort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPutShort </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试插入 Short 类型的键值对（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Short 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="a425d319fb6d02cedd2fb2d1d97e2fbfe" name="a425d319fb6d02cedd2fb2d1d97e2fbfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425d319fb6d02cedd2fb2d1d97e2fbfe">&#9670;&#160;</a></span>TryPutShort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPutShort </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a3e47d05c36743947da966f4223237262">NBT_Type::Short</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试插入 Short 类型的键值对（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 Short 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="aa63e7ce495c39ac232b34048f3793b53" name="aa63e7ce495c39ac232b34048f3793b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63e7ce495c39ac232b34048f3793b53">&#9670;&#160;</a></span>TryPutString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPutString </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试插入 String 类型的键值对（拷贝） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 String 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<a id="ae982961528a1f3d222fd6bcedced6860" name="ae982961528a1f3d222fd6bcedced6860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae982961528a1f3d222fd6bcedced6860">&#9670;&#160;</a></span>TryPutString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Compound&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; <br />
requires std::constructible_from&lt;typename Compound::key_type, K &amp;&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename Compound::iterator, bool &gt; <a class="el" href="classNBT__Compound.html">NBT_Compound</a>&lt; Compound &gt;::TryPutString </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sTagName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classNBT__Type.html#a8580dcb2a4494cd9bc52526d43f61865">NBT_Type::String</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vTagVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试插入 String 类型的键值对（移动） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>标签名类型，必须可构造为key_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTagName</td><td>标签名</td></tr>
    <tr><td class="paramname">vTagVal</td><td>要插入的 String 类型值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>包含迭代器和bool值的pair，迭代器指向插入或替换的元素，bool值为true则执行了插入，否则键已存在，不会进行拷贝或移动 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>允许插入End类型的值，这样设计的目的在于允许处理过程出现特殊值， 请确保输出前处理完毕所有End类型，否则通过NBT_Write输出时会忽略这些值并生成警告 </dd></dl>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li><a class="el" href="NBT__Compound_8hpp_source.html">NBT_Compound.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="classNBT__Compound.html">NBT_Compound</a></li>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
