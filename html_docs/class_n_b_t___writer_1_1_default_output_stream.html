<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>chenjunfu2-nbt-cpp: NBT_Writer::DefaultOutputStream&lt; T &gt; 模板类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">chenjunfu2-nbt-cpp<span id="projectnumber">&#160;v1.0.1</span>
   </div>
   <div id="projectbrief">一个基于CPP20的NBT(Named Binary Tag)库</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','搜索',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('class_n_b_t___writer_1_1_default_output_stream.html','','class_n_b_t___writer_1_1_default_output_stream-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">NBT_Writer::DefaultOutputStream&lt; T &gt; 模板类 参考</div></div>
</div><!--header-->
<div class="contents">

<p>默认输出流类，用于将数据写入到标准库容器中  
 <a href="#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="_n_b_t___writer_8hpp_source.html">NBT_Writer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public 类型</h2></td></tr>
<tr class="memitem:ad6b82f65988e7212474db2d6162b6148" id="r_ad6b82f65988e7212474db2d6162b6148"><td class="memItemLeft" align="right" valign="top"><a id="ad6b82f65988e7212474db2d6162b6148" name="ad6b82f65988e7212474db2d6162b6148"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>StreamType</b> = T</td></tr>
<tr class="memdesc:ad6b82f65988e7212474db2d6162b6148"><td class="mdescLeft">&#160;</td><td class="mdescRight">容器类型 <br /></td></tr>
<tr class="memitem:a144920e573e9f0ea1a5546d3e006de68" id="r_a144920e573e9f0ea1a5546d3e006de68"><td class="memItemLeft" align="right" valign="top"><a id="a144920e573e9f0ea1a5546d3e006de68" name="a144920e573e9f0ea1a5546d3e006de68"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ValueType</b> = typename T::value_type</td></tr>
<tr class="memdesc:a144920e573e9f0ea1a5546d3e006de68"><td class="mdescLeft">&#160;</td><td class="mdescRight">容器值类型 <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:a32271fdfbb95decbdbe5020aa9a57b57" id="r_a32271fdfbb95decbdbe5020aa9a57b57"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32271fdfbb95decbdbe5020aa9a57b57">DefaultOutputStream</a> (T &amp;_tData, size_t szStartIdx=0)</td></tr>
<tr class="memdesc:a32271fdfbb95decbdbe5020aa9a57b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">构造函数  <br /></td></tr>
<tr class="memitem:a63edd1e9ec0a03c633ed67a09fb967d6" id="r_a63edd1e9ec0a03c633ed67a09fb967d6"><td class="memItemLeft" align="right" valign="top"><a id="a63edd1e9ec0a03c633ed67a09fb967d6" name="a63edd1e9ec0a03c633ed67a09fb967d6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~DefaultOutputStream</b> (void)=default</td></tr>
<tr class="memdesc:a63edd1e9ec0a03c633ed67a09fb967d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">默认析构函数 <br /></td></tr>
<tr class="memitem:ae54eeef037515c018bba79f88d82db09" id="r_ae54eeef037515c018bba79f88d82db09"><td class="memItemLeft" align="right" valign="top"><a id="ae54eeef037515c018bba79f88d82db09" name="ae54eeef037515c018bba79f88d82db09"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DefaultOutputStream</b> (const DefaultOutputStream &amp;)=delete</td></tr>
<tr class="memdesc:ae54eeef037515c018bba79f88d82db09"><td class="mdescLeft">&#160;</td><td class="mdescRight">禁止拷贝构造 <br /></td></tr>
<tr class="memitem:a2de5076ed262454040823861db124076" id="r_a2de5076ed262454040823861db124076"><td class="memItemLeft" align="right" valign="top"><a id="a2de5076ed262454040823861db124076" name="a2de5076ed262454040823861db124076"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DefaultOutputStream</b> (DefaultOutputStream &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a2de5076ed262454040823861db124076"><td class="mdescLeft">&#160;</td><td class="mdescRight">禁止移动构造 <br /></td></tr>
<tr class="memitem:ab4e243486a1066828bd03c1c2ea50eed" id="r_ab4e243486a1066828bd03c1c2ea50eed"><td class="memItemLeft" align="right" valign="top"><a id="ab4e243486a1066828bd03c1c2ea50eed" name="ab4e243486a1066828bd03c1c2ea50eed"></a>
<a class="el" href="#a32271fdfbb95decbdbe5020aa9a57b57">DefaultOutputStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="#a32271fdfbb95decbdbe5020aa9a57b57">DefaultOutputStream</a> &amp;)=delete</td></tr>
<tr class="memdesc:ab4e243486a1066828bd03c1c2ea50eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">禁止拷贝赋值 <br /></td></tr>
<tr class="memitem:a8297138a0470171104eb4f0ea9ba0470" id="r_a8297138a0470171104eb4f0ea9ba0470"><td class="memItemLeft" align="right" valign="top"><a id="a8297138a0470171104eb4f0ea9ba0470" name="a8297138a0470171104eb4f0ea9ba0470"></a>
<a class="el" href="#a32271fdfbb95decbdbe5020aa9a57b57">DefaultOutputStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="#a32271fdfbb95decbdbe5020aa9a57b57">DefaultOutputStream</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a8297138a0470171104eb4f0ea9ba0470"><td class="mdescLeft">&#160;</td><td class="mdescRight">禁止移动赋值 <br /></td></tr>
<tr class="memitem:a918b004beb1e94d49174d88c25469977" id="r_a918b004beb1e94d49174d88c25469977"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a144920e573e9f0ea1a5546d3e006de68">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a918b004beb1e94d49174d88c25469977">operator[]</a> (size_t szIndex) const noexcept</td></tr>
<tr class="memdesc:a918b004beb1e94d49174d88c25469977"><td class="mdescLeft">&#160;</td><td class="mdescRight">下标访问运算符  <br /></td></tr>
<tr class="memitem:a580af57b2222d66062ef9fdad913fd74" id="r_a580af57b2222d66062ef9fdad913fd74"><td class="memTemplParams" colspan="2">template&lt;typename V&gt; <br />
requires (std::is_constructible_v&lt;<a class="el" href="#a144920e573e9f0ea1a5546d3e006de68">ValueType</a>, V &amp;&amp;&gt;)</td></tr>
<tr class="memitem:a580af57b2222d66062ef9fdad913fd74 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a580af57b2222d66062ef9fdad913fd74">PutOnce</a> (V &amp;&amp;c)</td></tr>
<tr class="memdesc:a580af57b2222d66062ef9fdad913fd74"><td class="mdescLeft">&#160;</td><td class="mdescRight">向流中写入写入单个值  <br /></td></tr>
<tr class="memitem:afc4066fff3524418e08fe8211b529955" id="r_afc4066fff3524418e08fe8211b529955"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc4066fff3524418e08fe8211b529955">PutRange</a> (const <a class="el" href="#a144920e573e9f0ea1a5546d3e006de68">ValueType</a> *pData, size_t szSize)</td></tr>
<tr class="memdesc:afc4066fff3524418e08fe8211b529955"><td class="mdescLeft">&#160;</td><td class="mdescRight">向流中写入一段数据  <br /></td></tr>
<tr class="memitem:aa42966418c995ba34a716e3f892f78b3" id="r_aa42966418c995ba34a716e3f892f78b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa42966418c995ba34a716e3f892f78b3">AddReserve</a> (size_t szAddSize)</td></tr>
<tr class="memdesc:aa42966418c995ba34a716e3f892f78b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">预分配额外容量  <br /></td></tr>
<tr class="memitem:ae36e5922755d8302dde26e28bf0b58ca" id="r_ae36e5922755d8302dde26e28bf0b58ca"><td class="memItemLeft" align="right" valign="top"><a id="ae36e5922755d8302dde26e28bf0b58ca" name="ae36e5922755d8302dde26e28bf0b58ca"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>UnPut</b> (void) noexcept</td></tr>
<tr class="memdesc:ae36e5922755d8302dde26e28bf0b58ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">删除（撤销）最后一个写入的字节 <br /></td></tr>
<tr class="memitem:af4bdb208f29cc230a1f18cd183891995" id="r_af4bdb208f29cc230a1f18cd183891995"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4bdb208f29cc230a1f18cd183891995">Size</a> (void) const noexcept</td></tr>
<tr class="memdesc:af4bdb208f29cc230a1f18cd183891995"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前字节流中已有的数据大小  <br /></td></tr>
<tr class="memitem:a1ca1cbe70ad1f18791f04dddc442ed10" id="r_a1ca1cbe70ad1f18791f04dddc442ed10"><td class="memItemLeft" align="right" valign="top"><a id="a1ca1cbe70ad1f18791f04dddc442ed10" name="a1ca1cbe70ad1f18791f04dddc442ed10"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Reset</b> (void) noexcept</td></tr>
<tr class="memdesc:a1ca1cbe70ad1f18791f04dddc442ed10"><td class="mdescLeft">&#160;</td><td class="mdescRight">重置流，清空所有数据 <br /></td></tr>
<tr class="memitem:ab140a014c8e9d3b74168b9cb4e23a11b" id="r_ab140a014c8e9d3b74168b9cb4e23a11b"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab140a014c8e9d3b74168b9cb4e23a11b">Data</a> (void) const noexcept</td></tr>
<tr class="memdesc:ab140a014c8e9d3b74168b9cb4e23a11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取底层数据的常量引用  <br /></td></tr>
<tr class="memitem:a6170c4d5598253aa0d717f1a4375aa0e" id="r_a6170c4d5598253aa0d717f1a4375aa0e"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6170c4d5598253aa0d717f1a4375aa0e">Data</a> (void) noexcept</td></tr>
<tr class="memdesc:a6170c4d5598253aa0d717f1a4375aa0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取底层数据的非常量引用  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">详细描述</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T = std::vector&lt;uint8_t&gt;&gt;<br />
class NBT_Writer::DefaultOutputStream&lt; T &gt;</div><p>默认输出流类，用于将数据写入到标准库容器中 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>数据容器类型，必须满足以下要求：<ul>
<li>value_type的大小必须为1字节</li>
<li>value_type必须是可平凡复制的类型 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>这个类用于标准库的顺序容器，非标准库容器顺序请使用其它的自定义流对象，而非使用此对象， 因为此对象对标准库容器的部分实现存在假设，其它非标准库容器极有可能不兼容导致未定义行为。 可以注意到部分接口在类中并未使用，这是未来扩展时可能用到的，如果自定义流对象，则可以省略部分未使用的接口。 </dd></dl>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">构造及析构函数说明</h2>
<a id="a32271fdfbb95decbdbe5020aa9a57b57" name="a32271fdfbb95decbdbe5020aa9a57b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32271fdfbb95decbdbe5020aa9a57b57">&#9670;&#160;</a></span>DefaultOutputStream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = std::vector&lt;uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_b_t___writer_1_1_default_output_stream.html">NBT_Writer::DefaultOutputStream</a>&lt; T &gt;::DefaultOutputStream </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>_tData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szStartIdx</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>构造函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">_tData</td><td>输出数据容器的引用 </td></tr>
    <tr><td class="paramname">szStartIdx</td><td>起始索引，容器会调整大小到此索引位置 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>索引位置后的数据都会被删除，然后从索引当前位置开始写入 </dd></dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">成员函数说明</h2>
<a id="aa42966418c995ba34a716e3f892f78b3" name="aa42966418c995ba34a716e3f892f78b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42966418c995ba34a716e3f892f78b3">&#9670;&#160;</a></span>AddReserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = std::vector&lt;uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_b_t___writer_1_1_default_output_stream.html">NBT_Writer::DefaultOutputStream</a>&lt; T &gt;::AddReserve </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szAddSize</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>预分配额外容量 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szAddSize</td><td>要额外分配的容量大小（字节数） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>这个接口一般是用于性能优化的，提前要求流预留空间以便后续的写入。 请不要假设在所有写入操作之前都会进行此调用，这个接口只有部分情况会用到。 </dd></dl>

</div>
</div>
<a id="ab140a014c8e9d3b74168b9cb4e23a11b" name="ab140a014c8e9d3b74168b9cb4e23a11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab140a014c8e9d3b74168b9cb4e23a11b">&#9670;&#160;</a></span>Data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = std::vector&lt;uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="class_n_b_t___writer_1_1_default_output_stream.html">NBT_Writer::DefaultOutputStream</a>&lt; T &gt;::Data </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取底层数据的常量引用 </p>
<dl class="section return"><dt>返回</dt><dd>底层数据容器的常量引用 </dd></dl>

</div>
</div>
<a id="a6170c4d5598253aa0d717f1a4375aa0e" name="a6170c4d5598253aa0d717f1a4375aa0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6170c4d5598253aa0d717f1a4375aa0e">&#9670;&#160;</a></span>Data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = std::vector&lt;uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="class_n_b_t___writer_1_1_default_output_stream.html">NBT_Writer::DefaultOutputStream</a>&lt; T &gt;::Data </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取底层数据的非常量引用 </p>
<dl class="section return"><dt>返回</dt><dd>底层数据容器的非常量引用 </dd></dl>

</div>
</div>
<a id="a918b004beb1e94d49174d88c25469977" name="a918b004beb1e94d49174d88c25469977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918b004beb1e94d49174d88c25469977">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = std::vector&lt;uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a144920e573e9f0ea1a5546d3e006de68">ValueType</a> &amp; <a class="el" href="class_n_b_t___writer_1_1_default_output_stream.html">NBT_Writer::DefaultOutputStream</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szIndex</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>下标访问运算符 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">szIndex</td><td>索引位置 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>对应位置的常量引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>这个接口一般用于随机访问流中的数据，而不修改流，调用者保证访问范围合法 </dd></dl>

</div>
</div>
<a id="a580af57b2222d66062ef9fdad913fd74" name="a580af57b2222d66062ef9fdad913fd74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580af57b2222d66062ef9fdad913fd74">&#9670;&#160;</a></span>PutOnce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = std::vector&lt;uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename V&gt; <br />
requires (std::is_constructible_v&lt;<a class="el" href="#a144920e573e9f0ea1a5546d3e006de68">ValueType</a>, V &amp;&amp;&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_b_t___writer_1_1_default_output_stream.html">NBT_Writer::DefaultOutputStream</a>&lt; T &gt;::PutOnce </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>向流中写入写入单个值 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>元素类型，必须可构造为ValueType </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>要写入的元素 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>这个接口一般用于逐个向流中写入数据 </dd></dl>

</div>
</div>
<a id="afc4066fff3524418e08fe8211b529955" name="afc4066fff3524418e08fe8211b529955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4066fff3524418e08fe8211b529955">&#9670;&#160;</a></span>PutRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = std::vector&lt;uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_n_b_t___writer_1_1_default_output_stream.html">NBT_Writer::DefaultOutputStream</a>&lt; T &gt;::PutRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a144920e573e9f0ea1a5546d3e006de68">ValueType</a> *</td>          <td class="paramname"><span class="paramname"><em>pData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>szSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>向流中写入一段数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pData</td><td>指向要写入数据的缓冲区的指针 </td></tr>
    <tr><td class="paramname">szSize</td><td>要写入的数据大小（字节数） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>这个接口一般用于批量向流中写入数据 </dd></dl>

</div>
</div>
<a id="af4bdb208f29cc230a1f18cd183891995" name="af4bdb208f29cc230a1f18cd183891995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4bdb208f29cc230a1f18cd183891995">&#9670;&#160;</a></span>Size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = std::vector&lt;uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_n_b_t___writer_1_1_default_output_stream.html">NBT_Writer::DefaultOutputStream</a>&lt; T &gt;::Size </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取当前字节流中已有的数据大小 </p>
<dl class="section return"><dt>返回</dt><dd>数据大小，以字节数计 </dd></dl>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>include/nbt_cpp/<a class="el" href="_n_b_t___writer_8hpp_source.html">NBT_Writer.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="class_n_b_t___writer.html">NBT_Writer</a></li><li class="navelem"><a href="class_n_b_t___writer_1_1_default_output_stream.html">DefaultOutputStream</a></li>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
